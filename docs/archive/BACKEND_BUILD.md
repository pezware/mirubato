# Mirubato Backend Build System

## Overview

The Mirubato backend uses a simplified, Cloudflare-native build system. This system lets Wrangler handle the build process directly, following Cloudflare best practices for Workers deployment.

## Architecture

### Simplified Build Pipeline

```
TypeScript Source → Wrangler Build → Deployment
        ↓                 ↓              ↓
   Standard TS        ESBuild +      Workers
   + GraphQL          Bundling       Runtime
```

### Key Principles

1. **Wrangler-First**: Let Wrangler handle TypeScript compilation and bundling
2. **No Build Hooks**: Avoid prebuild/postbuild complexity that causes loops
3. **Standard TypeScript**: Use standard `tsc` for local builds
4. **Simple Commands**: Each command has a single, clear purpose

## Commands

### Development

```bash
# Start development server (recommended)
npm run dev                # Runs: wrangler dev --env local

# Alternative development workflows
npm run dev:full          # Uses file watcher with auto-restart
npm run dev:watch         # TypeScript watch mode only
npm run dev:server        # Wrangler dev server only
```

### Production

```bash
# Production build
npm run build             # Runs: tsc

# Advanced build (with schema generation)
npm run dev:build         # Runs build-modern.js for special cases
```

### Deployment

```bash
# Deploy to different environments
npm run deploy:dev
npm run deploy:staging
npm run deploy:production

# Or use wrangler directly
wrangler deploy --env dev
```

## Environment Configuration

### Local Development (`--env local`)

- Uses placeholder database IDs
- Runs on localhost:8787
- Hot reload enabled via Wrangler

### Remote Environments

- `--env dev` - Development environment
- `--env staging` - Staging environment
- `--env production` - Production environment (default)

## Build Artifacts

### Wrangler-Generated Files

- `dist/index.js` - Main worker bundle (generated by Wrangler)
- Worker bindings (D1, KV) configured in `wrangler.toml`

### Source Files

- `src/schema/schema.graphql` - GraphQL schema definition
- TypeScript source files compiled automatically

## Troubleshooting

### Common Issues and Fallacies

1. **Build Fails with TypeScript Errors**

   ```bash
   # Check types without building
   npm run type-check

   # Generate types from wrangler
   npx wrangler types
   ```

2. **Missing Dependencies**

   ```bash
   # Clean install
   rm -rf node_modules package-lock.json
   npm install
   ```

3. **Wrangler Configuration Issues**

   ```bash
   # Validate wrangler config
   npx wrangler deploy --dry-run
   ```

4. **Entry Point Not Found: "The entry-point file at 'dist/index.js' was not found"**

   **Root Cause**: TypeScript preserves full directory structure when importing from outside project root

   **Symptoms**:
   - Build succeeds locally but fails on Cloudflare
   - Entry point file exists but at different path than expected
   - TypeScript outputs to `dist/backend/src/index.js` instead of `dist/index.js`

   **Solution**:
   - Update `wrangler.toml` main entry: `main = "dist/backend/src/index.js"`
   - This happens when importing from `../shared` outside the backend directory

   **Prevention**:
   - Always check TypeScript output structure after adding shared imports
   - Run `npm run build` and verify the actual output path

5. **Infinite Build Loop in Development**

   **Root Cause**: Circular dependency between wrangler.toml build command and npm scripts

   **Symptoms**:
   - `npm run dev` constantly rebuilds
   - Build completes but immediately restarts
   - High CPU usage during development

   **Solution**:
   - Remove `[build]` section from wrangler.toml
   - Use simple npm scripts without circular references
   - Let Wrangler handle TypeScript compilation directly

   **Prevention**:
   - Never reference npm scripts in wrangler.toml that call wrangler
   - Keep build commands simple and linear

6. **\_\_dirname is Not Defined in Workers**

   **Root Cause**: Cloudflare Workers don't have Node.js globals

   **Symptoms**:
   - Runtime error: "\_\_dirname is not defined"
   - Schema files can't be read at runtime
   - Works locally but fails in Workers environment

   **Solution**:
   - Pre-generate static content during build
   - Use build scripts to create importable modules
   - Example: `build-schema.js` generates `schema-content.js`

   **Prevention**:
   - Never use Node.js-specific globals in Workers code
   - Always bundle or pre-generate file content

7. **JavaScript Files in Shared Folder Break Tests**

   **Root Cause**: TypeScript compilation outputs JS files that Jest tries to process

   **Symptoms**:
   - Jest fails with "Unexpected token" errors
   - Tests pass individually but fail in CI
   - JavaScript files appear in shared/types directory

   **Solution**:
   - Add `shared/**/*.js` to .gitignore
   - Clean up generated JS files regularly
   - Configure Jest to ignore these files

   **Prevention**:
   - Never commit generated JavaScript files from TypeScript
   - Use source TypeScript files directly in monorepo

### Debug Mode

Enable verbose logging for detailed build information:

```bash
npm run build -- --verbose
```

### Build System Fallacies to Avoid

1. **"Setting Root Directory in Cloudflare Changes npm install Location"**
   - FALSE: Cloudflare always runs npm install from repository root
   - Even with `/backend/` as root directory, dependencies install from root
   - Solution: Use repository root and `cd backend` in commands

2. **"Frontend and Backend Should Have Same Build Process"**
   - FALSE: Frontend benefits from Vite's optimizations, backend from Wrangler's
   - Frontend doesn't import from outside its directory (no path issues)
   - Backend imports shared types, causing different TypeScript behavior

3. **"Version Command is Required for Deployment"**
   - FALSE: Version command is for gradual rollouts only
   - Standard deployments should leave it empty
   - Using it without proper setup causes deployment failures

4. **"Build Commands in wrangler.toml Improve Build Process"**
   - FALSE: They often create circular dependencies
   - Wrangler's built-in TypeScript support is sufficient
   - External build commands should be in npm scripts only

5. **"TypeScript Always Outputs to dist/ Directly"**
   - FALSE: TypeScript preserves relative import structure
   - Imports from `../shared` create `dist/backend/src/` structure
   - Always verify actual output structure after changes

## Migration from Legacy Build

### Legacy Files (Archived)

- `build-legacy.js` (was `build.js`)
- `build-fixed-legacy.js` (was `build-fixed.js`)
- `build-with-lock-legacy.js` (was `build-with-lock.js`)

### Key Improvements

1. **Reliability**: No more manual file copying and path manipulation
2. **Performance**: Faster builds using standard TypeScript compilation
3. **Maintainability**: Clear separation of concerns
4. **Validation**: Proper build artifact verification
5. **Environment Parity**: Consistent behavior across local/cloud

## CI/CD Integration

The build system integrates with GitHub Actions for:

- Build validation on PRs
- Type checking
- Bundle size monitoring
- Deployment dry-runs

See `.github/workflows/backend-build-validation.yml` for details.

### Cloudflare Dashboard Settings

For proper deployment, configure your Cloudflare Worker with these settings:

**Build Configuration:**

- Build command: `npm run build`
- Deploy command: `npx wrangler deploy` (for production/default environment)
- Root directory: `/`
- Version command: **Leave empty** (unless using gradual deployments)

**IMPORTANT**: Due to a Cloudflare limitation, even when root directory is set to `/backend/`,
it still installs dependencies from the repository root. Therefore, we recommend using `/` as
the root directory with the commands shown below.

**Understanding Wrangler Environments:**

- Top-level config in `wrangler.toml` is the default (production)
- Named environments use `[env.<name>]` sections
- Deploy to specific env: `npx wrangler deploy --env staging`
- Environment creates worker named: `<base-name>-<env-name>`

**Why Version Command Should Be Empty:**

1. `wrangler versions upload` is for gradual rollouts, not direct deployment
2. Requires initial deployment with `wrangler deploy` first
3. Standard deployments should use `wrangler deploy` only

**For Environment-Specific Deployment:**
If you need to deploy to a specific environment from Cloudflare dashboard:

- Production branch deploy command: `cd backend && npx wrangler deploy`
- Non-production branch deploy command: `cd backend && npx wrangler deploy --env staging`

**Branch Deployment Settings:**

- Production branches use top-level config (default)
- Non-production branches deploy to `staging` environment
- This prevents accidental deployment to production from feature branches
- Development environment (`--env dev`) is reserved for local development

## Working Build Configuration

### Critical Configuration That Works

**wrangler.toml**:

```toml
name = "mirubato-backend"
main = "dist/backend/src/index.js"  # NOT "dist/index.js"
# NO [build] section - causes infinite loops
```

**package.json scripts**:

```json
{
  "scripts": {
    "dev": "wrangler dev --env local",
    "build": "node scripts/build-schema.js && tsc && node scripts/build-schema.js",
    "deploy": "wrangler deploy"
  }
}
```

**Root package.json** (for Cloudflare deployment):

```json
{
  "scripts": {
    "build": "cd backend && npm run build"
  }
}
```

**Cloudflare Dashboard Settings**:

- Build command: `npm run build`
- Deploy command: `cd backend && npx wrangler deploy`
- Root directory: `/`
- Version command: **LEAVE EMPTY**

### Why This Configuration Works

1. **TypeScript Output Path**: When importing from `../shared`, TypeScript mirrors the directory structure, outputting to `dist/backend/src/` instead of `dist/`
2. **Schema Pre-generation**: The `build-schema.js` script generates static content to avoid runtime file reading
3. **No Circular Dependencies**: Build commands don't reference each other
4. **Cloudflare Compatibility**: Commands work from repository root as Cloudflare expects

## Best Practices

### Development Workflow

#### Recommended: Simple Development

```bash
npm run dev
```

- Uses Wrangler's built-in file watching
- Automatic TypeScript compilation and hot reload
- No build configuration needed
- Best for most development scenarios

#### Advanced: File Watcher with Auto-restart

```bash
npm run dev:full
```

- Custom file watcher that handles GraphQL schema changes
- Automatically restarts server on file changes
- Good for complex development scenarios

#### Manual Control

```bash
# TypeScript compilation only
npm run build

# Development server (requires built files)
npm run dev:server
```

#### Testing and Validation

1. Use `npm run type-check` for quick type validation
2. Test deployment with `wrangler deploy --dry-run`
3. Check logs with `wrangler tail`

### Production Deployment

1. Ensure all tests pass locally
2. Verify build artifacts are generated correctly
3. Check bundle size for optimization opportunities
4. Use environment-specific deployment commands

**Important:** When deploying via Cloudflare dashboard:

- The build runs from repository root (not `/backend/`)
- TypeScript compiles to `backend/dist/`
- Deploy commands must `cd backend` first to find wrangler.toml and dist/
- Entry point is `dist/index.js` (relative to backend directory)

## Future Enhancements

- [ ] Re-enable `wrangler types` generation when stable
- [ ] Add bundle analysis and optimization suggestions
- [ ] Implement build caching for faster CI/CD
- [ ] Add source map generation for debugging
