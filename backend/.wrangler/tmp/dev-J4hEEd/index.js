var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// .wrangler/tmp/bundle-kaawHL/strip-cf-connecting-ip-header.js
function stripCfConnectingIPHeader(input, init) {
  const request = new Request(input, init);
  request.headers.delete("CF-Connecting-IP");
  return request;
}
var init_strip_cf_connecting_ip_header = __esm({
  ".wrangler/tmp/bundle-kaawHL/strip-cf-connecting-ip-header.js"() {
    "use strict";
    __name(stripCfConnectingIPHeader, "stripCfConnectingIPHeader");
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        return Reflect.apply(target, thisArg, [
          stripCfConnectingIPHeader.apply(null, argArray)
        ]);
      }
    });
  }
});

// ../node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "../node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type2) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type2) {
        return this._entries.filter((e) => e.name === name && (!type2 || e.entryType === type2));
      }
      getEntriesByType(type2) {
        return this._entries.filter((e) => e.entryType === type2);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// ../node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "../node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// ../node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "../node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// ../node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "../node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// ../node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "../node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// ../node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "../node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// ../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// ../node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "../node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      emitWarning(warning, type2, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type2 ? `${type2}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      ref() {
      }
      unref() {
      }
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      mainModule = void 0;
      domain = void 0;
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// ../node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "../node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// ../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "../node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// ../node_modules/@apollo/utils.isnodelike/dist/index.js
var require_dist = __commonJS({
  "../node_modules/@apollo/utils.isnodelike/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isNodeLike = void 0;
    exports2.isNodeLike = typeof process === "object" && process && process.release && process.versions && typeof process.versions.node === "string";
  }
});

// ../node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js
var require_PrefixingKeyValueCache = __commonJS({
  "../node_modules/@apollo/utils.keyvaluecache/dist/PrefixingKeyValueCache.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PrefixingKeyValueCache = void 0;
    var prefixesAreUnnecessaryForIsolationSymbol = Symbol("prefixesAreUnnecessaryForIsolation");
    var PrefixingKeyValueCache2 = class _PrefixingKeyValueCache {
      static {
        __name(this, "PrefixingKeyValueCache");
      }
      constructor(wrapped, prefix) {
        this.wrapped = wrapped;
        if (_PrefixingKeyValueCache.prefixesAreUnnecessaryForIsolation(wrapped)) {
          this.prefix = "";
          this[prefixesAreUnnecessaryForIsolationSymbol] = true;
        } else {
          this.prefix = prefix;
        }
      }
      get(key) {
        return this.wrapped.get(this.prefix + key);
      }
      set(key, value, options) {
        return this.wrapped.set(this.prefix + key, value, options);
      }
      delete(key) {
        return this.wrapped.delete(this.prefix + key);
      }
      static prefixesAreUnnecessaryForIsolation(c) {
        return prefixesAreUnnecessaryForIsolationSymbol in c;
      }
      static cacheDangerouslyDoesNotNeedPrefixesForIsolation(c) {
        return new PrefixesAreUnnecessaryForIsolationCache(c);
      }
    };
    exports2.PrefixingKeyValueCache = PrefixingKeyValueCache2;
    var PrefixesAreUnnecessaryForIsolationCache = class {
      static {
        __name(this, "PrefixesAreUnnecessaryForIsolationCache");
      }
      constructor(wrapped) {
        this.wrapped = wrapped;
        this[_a] = true;
      }
      get(key) {
        return this.wrapped.get(key);
      }
      set(key, value, options) {
        return this.wrapped.set(key, value, options);
      }
      delete(key) {
        return this.wrapped.delete(key);
      }
    };
    _a = prefixesAreUnnecessaryForIsolationSymbol;
  }
});

// ../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../node_modules/lru-cache/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var perf2 = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController2 = typeof AbortController === "function";
    var AC2 = hasAbortController2 ? AbortController : class AbortController {
      static {
        __name(this, "AbortController");
      }
      constructor() {
        this.signal = new AS2();
      }
      abort(reason = new Error("This operation was aborted")) {
        this.signal.reason = this.signal.reason || reason;
        this.signal.aborted = true;
        this.signal.dispatchEvent({
          type: "abort",
          target: this.signal
        });
      }
    };
    var hasAbortSignal2 = typeof AbortSignal === "function";
    var hasACAbortSignal2 = typeof AC2.AbortSignal === "function";
    var AS2 = hasAbortSignal2 ? AbortSignal : hasACAbortSignal2 ? AC2.AbortController : class AbortSignal {
      static {
        __name(this, "AbortSignal");
      }
      constructor() {
        this.reason = void 0;
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(e) {
        if (e.type === "abort") {
          this.aborted = true;
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned2 = /* @__PURE__ */ new Set();
    var deprecatedOption2 = /* @__PURE__ */ __name((opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn2(code)) {
        warn4(code, `${opt} option`, `options.${instead}`, LRUCache2);
      }
    }, "deprecatedOption");
    var deprecatedMethod2 = /* @__PURE__ */ __name((method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn2(code)) {
        const { prototype } = LRUCache2;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn4(code, `${method} method`, `cache.${instead}()`, get);
      }
    }, "deprecatedMethod");
    var deprecatedProperty2 = /* @__PURE__ */ __name((field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn2(code)) {
        const { prototype } = LRUCache2;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn4(code, `${field} property`, `cache.${instead}`, get);
      }
    }, "deprecatedProperty");
    var emitWarning3 = /* @__PURE__ */ __name((...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    }, "emitWarning");
    var shouldWarn2 = /* @__PURE__ */ __name((code) => !warned2.has(code), "shouldWarn");
    var warn4 = /* @__PURE__ */ __name((code, what, instead, fn) => {
      warned2.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning3(msg, "DeprecationWarning", code, fn);
    }, "warn");
    var isPosInt2 = /* @__PURE__ */ __name((n) => n && n === Math.floor(n) && n > 0 && isFinite(n), "isPosInt");
    var getUintArray2 = /* @__PURE__ */ __name((max) => !isPosInt2(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray2 : null, "getUintArray");
    var ZeroArray2 = class extends Array {
      static {
        __name(this, "ZeroArray");
      }
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack2 = class {
      static {
        __name(this, "Stack");
      }
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray2(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache2 = class _LRUCache {
      static {
        __name(this, "LRUCache");
      }
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          maxEntrySize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt2(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray2(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize or maxEntrySize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack2(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt2(this.maxSize)) {
              throw new TypeError(
                "maxSize must be a positive integer if specified"
              );
            }
          }
          if (!isPosInt2(this.maxEntrySize)) {
            throw new TypeError(
              "maxEntrySize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt2(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt2(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn2(code)) {
            warned2.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning3(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption2("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption2("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption2("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray2(this.max);
        this.starts = new ZeroArray2(this.max);
        this.setItemTTL = (index, ttl, start = perf2.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf2.now() : 0;
        };
        this.statusTTL = (status, index) => {
          if (status) {
            status.ttl = this.ttls[index];
            status.start = this.starts[index];
            status.now = cachedNow || getNow();
            status.remainingTTL = status.now + status.ttl - status.start;
          }
        };
        let cachedNow = 0;
        const getNow = /* @__PURE__ */ __name(() => {
          const n = perf2.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        }, "getNow");
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(_index) {
      }
      statusTTL(_status, _index) {
      }
      setItemTTL(_index, _ttl, _start) {
      }
      isStale(_index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray2(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (this.isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt2(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt2(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size, status) => {
          this.sizes[index] = size;
          if (this.maxSize) {
            const maxSize = this.maxSize - this.sizes[index];
            while (this.calculatedSize > maxSize) {
              this.evict(true);
            }
          }
          this.calculatedSize += this.sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.calculatedSize;
          }
        };
      }
      removeItemSize(_index) {
      }
      addItemSize(_index, _size) {
      }
      requireSize(_k, _v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize or maxEntrySize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return index !== void 0 && this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          if (this.valList[i] !== void 0 && this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          if (this.valList[i] !== void 0 && this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          if (this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          if (this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *values() {
        for (const i of this.indexes()) {
          if (this.valList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          if (this.valList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions) {
        for (const i of this.indexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          if (fn(value, this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod2("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf2.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf2.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(_v, _k, _reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        status
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size, status);
          if (status) {
            status.set = "add";
          }
          noUpdateTTL = false;
        } else {
          this.moveToTail(index);
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, size, status);
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0) status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        this.statusTTL(status, index);
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            if (status) status.has = "hit";
            this.statusTTL(status, index);
            return true;
          } else if (status) {
            status.has = "stale";
            this.statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context2) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC2();
        if (options.signal) {
          options.signal.addEventListener(
            "abort",
            () => ac.abort(options.signal.reason)
          );
        }
        const fetchOpts = {
          signal: ac.signal,
          options,
          context: context2
        };
        const cb = /* @__PURE__ */ __name((v2, updateCache = false) => {
          const { aborted: aborted2 } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted2 && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort) options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted2 && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          if (this.valList[index] === p) {
            if (v2 === void 0) {
              if (p.__staleWhileFetching) {
                this.valList[index] = p.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              if (options.status) options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        }, "cb");
        const eb = /* @__PURE__ */ __name((er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        }, "eb");
        const fetchFail = /* @__PURE__ */ __name((er) => {
          const { aborted: aborted2 } = ac.signal;
          const allowStaleAborted = aborted2 && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          if (this.valList[index] === p) {
            const del = !noDelete || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && p.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return p.__staleWhileFetching;
          } else if (p.__returned === p) {
            throw er;
          }
        }, "fetchFail");
        const pcall = /* @__PURE__ */ __name((res, rej) => {
          this.fetchMethod(k, v, fetchOpts).then((v2) => res(v2), rej);
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res();
              if (options.allowStaleOnFetchAbort) {
                res = /* @__PURE__ */ __name((v2) => cb(v2, true), "res");
              }
            }
          });
        }, "pcall");
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, { ...fetchOpts.options, status: void 0 });
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        fetchContext = this.fetchContext,
        forceRefresh = false,
        status,
        signal
      } = {}) {
        if (!this.fetchMethod) {
          if (status) status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          if (status) status.fetch = "miss";
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale) status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.isStale(index);
          if (!forceRefresh && !isStale) {
            if (status) status.fetch = "hit";
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            this.statusTTL(status, index);
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = hasStale && isStale ? "stale" : "refresh";
            if (staleVal && isStale) status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        status
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          this.statusTTL(status, index);
          if (this.isStale(index)) {
            if (status) status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status) status.returnedStale = allowStale;
              return allowStale ? value : void 0;
            } else {
              if (status) {
                status.returnedStale = allowStale && value.__staleWhileFetching !== void 0;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status) status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod2("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod2("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty2("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC2;
      }
      static get AbortSignal() {
        return AS2;
      }
    };
    module2.exports = LRUCache2;
  }
});

// ../node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js
var require_InMemoryLRUCache = __commonJS({
  "../node_modules/@apollo/utils.keyvaluecache/dist/InMemoryLRUCache.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemoryLRUCache = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache());
    var InMemoryLRUCache2 = class _InMemoryLRUCache {
      static {
        __name(this, "InMemoryLRUCache");
      }
      constructor(lruCacheOpts) {
        this.cache = new lru_cache_1.default({
          sizeCalculation: _InMemoryLRUCache.sizeCalculation,
          maxSize: Math.pow(2, 20) * 30,
          ...lruCacheOpts
        });
      }
      static sizeCalculation(item) {
        if (typeof item === "string") {
          return item.length;
        }
        if (typeof item === "object") {
          return Buffer.byteLength(JSON.stringify(item), "utf8");
        }
        return 1;
      }
      async set(key, value, options) {
        if (options === null || options === void 0 ? void 0 : options.ttl) {
          this.cache.set(key, value, { ttl: options.ttl * 1e3 });
        } else {
          this.cache.set(key, value);
        }
      }
      async get(key) {
        return this.cache.get(key);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
      clear() {
        this.cache.clear();
      }
      keys() {
        return [...this.cache.keys()];
      }
    };
    exports2.InMemoryLRUCache = InMemoryLRUCache2;
  }
});

// ../node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js
var require_ErrorsAreMissesCache = __commonJS({
  "../node_modules/@apollo/utils.keyvaluecache/dist/ErrorsAreMissesCache.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = void 0;
    var ErrorsAreMissesCache = class {
      static {
        __name(this, "ErrorsAreMissesCache");
      }
      constructor(cache, logger) {
        this.cache = cache;
        this.logger = logger;
      }
      async get(key) {
        try {
          return await this.cache.get(key);
        } catch (e) {
          if (this.logger) {
            if (e instanceof Error) {
              this.logger.error(e.message);
            } else {
              this.logger.error(e);
            }
          }
          return void 0;
        }
      }
      async set(key, value, opts) {
        return this.cache.set(key, value, opts);
      }
      async delete(key) {
        return this.cache.delete(key);
      }
    };
    exports2.ErrorsAreMissesCache = ErrorsAreMissesCache;
  }
});

// ../node_modules/@apollo/utils.keyvaluecache/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/@apollo/utils.keyvaluecache/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ErrorsAreMissesCache = exports2.InMemoryLRUCache = exports2.PrefixingKeyValueCache = void 0;
    var PrefixingKeyValueCache_1 = require_PrefixingKeyValueCache();
    Object.defineProperty(exports2, "PrefixingKeyValueCache", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return PrefixingKeyValueCache_1.PrefixingKeyValueCache;
    }, "get") });
    var InMemoryLRUCache_1 = require_InMemoryLRUCache();
    Object.defineProperty(exports2, "InMemoryLRUCache", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return InMemoryLRUCache_1.InMemoryLRUCache;
    }, "get") });
    var ErrorsAreMissesCache_1 = require_ErrorsAreMissesCache();
    Object.defineProperty(exports2, "ErrorsAreMissesCache", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ErrorsAreMissesCache_1.ErrorsAreMissesCache;
    }, "get") });
  }
});

// ../node_modules/graphql/version.js
var require_version = __commonJS({
  "../node_modules/graphql/version.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.versionInfo = exports2.version = void 0;
    var version3 = "16.11.0";
    exports2.version = version3;
    var versionInfo = Object.freeze({
      major: 16,
      minor: 11,
      patch: 0,
      preReleaseTag: null
    });
    exports2.versionInfo = versionInfo;
  }
});

// ../node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "../node_modules/graphql/jsutils/devAssert.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.devAssert = devAssert;
    function devAssert(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
    __name(devAssert, "devAssert");
  }
});

// ../node_modules/graphql/jsutils/isPromise.js
var require_isPromise = __commonJS({
  "../node_modules/graphql/jsutils/isPromise.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPromise = isPromise2;
    function isPromise2(value) {
      return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
    }
    __name(isPromise2, "isPromise");
  }
});

// ../node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../node_modules/graphql/jsutils/isObjectLike.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isObjectLike = isObjectLike;
    function isObjectLike(value) {
      return typeof value == "object" && value !== null;
    }
    __name(isObjectLike, "isObjectLike");
  }
});

// ../node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS({
  "../node_modules/graphql/jsutils/invariant.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.invariant = invariant;
    function invariant(condition, message) {
      const booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(
          message != null ? message : "Unexpected invariant triggered."
        );
      }
    }
    __name(invariant, "invariant");
  }
});

// ../node_modules/graphql/language/location.js
var require_location = __commonJS({
  "../node_modules/graphql/language/location.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocation = getLocation;
    var _invariant = require_invariant();
    var LineRegExp = /\r\n|[\n\r]/g;
    function getLocation(source, position) {
      let lastLineStart = 0;
      let line = 1;
      for (const match of source.body.matchAll(LineRegExp)) {
        typeof match.index === "number" || (0, _invariant.invariant)(false);
        if (match.index >= position) {
          break;
        }
        lastLineStart = match.index + match[0].length;
        line += 1;
      }
      return {
        line,
        column: position + 1 - lastLineStart
      };
    }
    __name(getLocation, "getLocation");
  }
});

// ../node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "../node_modules/graphql/language/printLocation.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printLocation = printLocation;
    exports2.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(
        location.source,
        (0, _location.getLocation)(location.source, location.start)
      );
    }
    __name(printLocation, "printLocation");
    function printSourceLocation(source, sourceLocation) {
      const firstLineColumnOffset = source.locationOffset.column - 1;
      const body = "".padStart(firstLineColumnOffset) + source.body;
      const lineIndex = sourceLocation.line - 1;
      const lineOffset = source.locationOffset.line - 1;
      const lineNum = sourceLocation.line + lineOffset;
      const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      const columnNum = sourceLocation.column + columnOffset;
      const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
      const lines = body.split(/\r\n|[\n\r]/g);
      const locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        const subLineIndex = Math.floor(columnNum / 80);
        const subLineColumnNum = columnNum % 80;
        const subLines = [];
        for (let i = 0; i < locationLine.length; i += 80) {
          subLines.push(locationLine.slice(i, i + 80));
        }
        return locationStr + printPrefixedLines([
          [`${lineNum} |`, subLines[0]],
          ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
          ["|", "^".padStart(subLineColumnNum)],
          ["|", subLines[subLineIndex + 1]]
        ]);
      }
      return locationStr + printPrefixedLines([
        // Lines specified like this: ["prefix", "string"],
        [`${lineNum - 1} |`, lines[lineIndex - 1]],
        [`${lineNum} |`, locationLine],
        ["|", "^".padStart(columnNum)],
        [`${lineNum + 1} |`, lines[lineIndex + 1]]
      ]);
    }
    __name(printSourceLocation, "printSourceLocation");
    function printPrefixedLines(lines) {
      const existingLines = lines.filter(([_, line]) => line !== void 0);
      const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
      return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
    }
    __name(printPrefixedLines, "printPrefixedLines");
  }
});

// ../node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "../node_modules/graphql/error/GraphQLError.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLError = void 0;
    exports2.formatError = formatError2;
    exports2.printError = printError;
    var _isObjectLike = require_isObjectLike();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function toNormalizedOptions(args) {
      const firstArg = args[0];
      if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
        return {
          nodes: firstArg,
          source: args[1],
          positions: args[2],
          path: args[3],
          originalError: args[4],
          extensions: args[5]
        };
      }
      return firstArg;
    }
    __name(toNormalizedOptions, "toNormalizedOptions");
    var GraphQLError9 = class _GraphQLError extends Error {
      static {
        __name(this, "GraphQLError");
      }
      /**
       * An array of `{ line, column }` locations within the source GraphQL document
       * which correspond to this error.
       *
       * Errors during validation often contain multiple locations, for example to
       * point out two things with the same name. Errors during execution include a
       * single location, the field which produced the error.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array describing the JSON-path into the execution response which
       * corresponds to this error. Only included for errors during execution.
       *
       * Enumerable, and appears in the result of JSON.stringify().
       */
      /**
       * An array of GraphQL AST Nodes corresponding to this error.
       */
      /**
       * The source GraphQL document for the first location of this error.
       *
       * Note that if this Error represents more than one node, the source may not
       * represent nodes after the first node.
       */
      /**
       * An array of character offsets within the source GraphQL document
       * which correspond to this error.
       */
      /**
       * The original error thrown from a field resolver during execution.
       */
      /**
       * Extension fields to add to the formatted error.
       */
      /**
       * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
       */
      constructor(message, ...rawArgs) {
        var _this$nodes, _nodeLocations$, _ref;
        const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
        super(message);
        this.name = "GraphQLError";
        this.path = path !== null && path !== void 0 ? path : void 0;
        this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        this.nodes = undefinedIfEmpty(
          Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
        );
        const nodeLocations = undefinedIfEmpty(
          (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
        );
        this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
        this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
        this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
          (loc) => (0, _location.getLocation)(loc.source, loc.start)
        );
        const originalExtensions = (0, _isObjectLike.isObjectLike)(
          originalError === null || originalError === void 0 ? void 0 : originalError.extensions
        ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
        this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
        Object.defineProperties(this, {
          message: {
            writable: true,
            enumerable: true
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(this, "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _GraphQLError);
        } else {
          Object.defineProperty(this, "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let output = this.message;
        if (this.nodes) {
          for (const node of this.nodes) {
            if (node.loc) {
              output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const location of this.locations) {
            output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
          }
        }
        return output;
      }
      toJSON() {
        const formattedError = {
          message: this.message
        };
        if (this.locations != null) {
          formattedError.locations = this.locations;
        }
        if (this.path != null) {
          formattedError.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          formattedError.extensions = this.extensions;
        }
        return formattedError;
      }
    };
    exports2.GraphQLError = GraphQLError9;
    function undefinedIfEmpty(array) {
      return array === void 0 || array.length === 0 ? void 0 : array;
    }
    __name(undefinedIfEmpty, "undefinedIfEmpty");
    function printError(error3) {
      return error3.toString();
    }
    __name(printError, "printError");
    function formatError2(error3) {
      return error3.toJSON();
    }
    __name(formatError2, "formatError");
  }
});

// ../node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "../node_modules/graphql/error/syntaxError.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position, description) {
      return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
        source,
        positions: [position]
      });
    }
    __name(syntaxError, "syntaxError");
  }
});

// ../node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "../node_modules/graphql/language/ast.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Token = exports2.QueryDocumentKeys = exports2.OperationTypeNode = exports2.Location = void 0;
    exports2.isNode = isNode;
    var Location = class {
      static {
        __name(this, "Location");
      }
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The Token at which this Node begins.
       */
      /**
       * The Token at which this Node ends.
       */
      /**
       * The Source document the AST represents.
       */
      constructor(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return {
          start: this.start,
          end: this.end
        };
      }
    };
    exports2.Location = Location;
    var Token = class {
      static {
        __name(this, "Token");
      }
      /**
       * The kind of Token.
       */
      /**
       * The character offset at which this Node begins.
       */
      /**
       * The character offset at which this Node ends.
       */
      /**
       * The 1-indexed line number on which this Token appears.
       */
      /**
       * The 1-indexed column number at which this Token begins.
       */
      /**
       * For non-punctuation tokens, represents the interpreted value of the token.
       *
       * Note: is undefined for punctuation tokens, but typed as string for
       * convenience in the parser.
       */
      /**
       * Tokens exist as nodes in a double-linked-list amongst all tokens
       * including ignored tokens. <SOF> is always the first node and <EOF>
       * the last.
       */
      constructor(kind, start, end, line, column, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      }
    };
    exports2.Token = Token;
    var QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: [
        "name",
        "variableDefinitions",
        "directives",
        "selectionSet"
      ],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        // Note: fragment variable definitions are deprecated and will removed in v17.0.0
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: [
        "description",
        "name",
        "type",
        "defaultValue",
        "directives"
      ],
      InterfaceTypeDefinition: [
        "description",
        "name",
        "interfaces",
        "directives",
        "fields"
      ],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    exports2.QueryDocumentKeys = QueryDocumentKeys;
    var kindValues = new Set(Object.keys(QueryDocumentKeys));
    function isNode(maybeNode) {
      const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
      return typeof maybeKind === "string" && kindValues.has(maybeKind);
    }
    __name(isNode, "isNode");
    var OperationTypeNode;
    exports2.OperationTypeNode = OperationTypeNode;
    (function(OperationTypeNode2) {
      OperationTypeNode2["QUERY"] = "query";
      OperationTypeNode2["MUTATION"] = "mutation";
      OperationTypeNode2["SUBSCRIPTION"] = "subscription";
    })(OperationTypeNode || (exports2.OperationTypeNode = OperationTypeNode = {}));
  }
});

// ../node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "../node_modules/graphql/language/directiveLocation.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation;
    exports2.DirectiveLocation = DirectiveLocation;
    (function(DirectiveLocation2) {
      DirectiveLocation2["QUERY"] = "QUERY";
      DirectiveLocation2["MUTATION"] = "MUTATION";
      DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
      DirectiveLocation2["FIELD"] = "FIELD";
      DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      DirectiveLocation2["SCHEMA"] = "SCHEMA";
      DirectiveLocation2["SCALAR"] = "SCALAR";
      DirectiveLocation2["OBJECT"] = "OBJECT";
      DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      DirectiveLocation2["INTERFACE"] = "INTERFACE";
      DirectiveLocation2["UNION"] = "UNION";
      DirectiveLocation2["ENUM"] = "ENUM";
      DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
      DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
      DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(DirectiveLocation || (exports2.DirectiveLocation = DirectiveLocation = {}));
  }
});

// ../node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "../node_modules/graphql/language/kinds.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Kind = void 0;
    var Kind20;
    exports2.Kind = Kind20;
    (function(Kind21) {
      Kind21["NAME"] = "Name";
      Kind21["DOCUMENT"] = "Document";
      Kind21["OPERATION_DEFINITION"] = "OperationDefinition";
      Kind21["VARIABLE_DEFINITION"] = "VariableDefinition";
      Kind21["SELECTION_SET"] = "SelectionSet";
      Kind21["FIELD"] = "Field";
      Kind21["ARGUMENT"] = "Argument";
      Kind21["FRAGMENT_SPREAD"] = "FragmentSpread";
      Kind21["INLINE_FRAGMENT"] = "InlineFragment";
      Kind21["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      Kind21["VARIABLE"] = "Variable";
      Kind21["INT"] = "IntValue";
      Kind21["FLOAT"] = "FloatValue";
      Kind21["STRING"] = "StringValue";
      Kind21["BOOLEAN"] = "BooleanValue";
      Kind21["NULL"] = "NullValue";
      Kind21["ENUM"] = "EnumValue";
      Kind21["LIST"] = "ListValue";
      Kind21["OBJECT"] = "ObjectValue";
      Kind21["OBJECT_FIELD"] = "ObjectField";
      Kind21["DIRECTIVE"] = "Directive";
      Kind21["NAMED_TYPE"] = "NamedType";
      Kind21["LIST_TYPE"] = "ListType";
      Kind21["NON_NULL_TYPE"] = "NonNullType";
      Kind21["SCHEMA_DEFINITION"] = "SchemaDefinition";
      Kind21["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      Kind21["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      Kind21["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      Kind21["FIELD_DEFINITION"] = "FieldDefinition";
      Kind21["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      Kind21["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      Kind21["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      Kind21["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      Kind21["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      Kind21["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      Kind21["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      Kind21["SCHEMA_EXTENSION"] = "SchemaExtension";
      Kind21["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      Kind21["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      Kind21["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      Kind21["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      Kind21["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      Kind21["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(Kind20 || (exports2.Kind = Kind20 = {}));
  }
});

// ../node_modules/graphql/language/characterClasses.js
var require_characterClasses = __commonJS({
  "../node_modules/graphql/language/characterClasses.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isDigit = isDigit;
    exports2.isLetter = isLetter;
    exports2.isNameContinue = isNameContinue;
    exports2.isNameStart = isNameStart;
    exports2.isWhiteSpace = isWhiteSpace;
    function isWhiteSpace(code) {
      return code === 9 || code === 32;
    }
    __name(isWhiteSpace, "isWhiteSpace");
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    __name(isDigit, "isDigit");
    function isLetter(code) {
      return code >= 97 && code <= 122 || // A-Z
      code >= 65 && code <= 90;
    }
    __name(isLetter, "isLetter");
    function isNameStart(code) {
      return isLetter(code) || code === 95;
    }
    __name(isNameStart, "isNameStart");
    function isNameContinue(code) {
      return isLetter(code) || isDigit(code) || code === 95;
    }
    __name(isNameContinue, "isNameContinue");
  }
});

// ../node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "../node_modules/graphql/language/blockString.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dedentBlockStringLines = dedentBlockStringLines;
    exports2.isPrintableAsBlockString = isPrintableAsBlockString;
    exports2.printBlockString = printBlockString2;
    var _characterClasses = require_characterClasses();
    function dedentBlockStringLines(lines) {
      var _firstNonEmptyLine2;
      let commonIndent = Number.MAX_SAFE_INTEGER;
      let firstNonEmptyLine = null;
      let lastNonEmptyLine = -1;
      for (let i = 0; i < lines.length; ++i) {
        var _firstNonEmptyLine;
        const line = lines[i];
        const indent2 = leadingWhitespace2(line);
        if (indent2 === line.length) {
          continue;
        }
        firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
        lastNonEmptyLine = i;
        if (i !== 0 && indent2 < commonIndent) {
          commonIndent = indent2;
        }
      }
      return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
        (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
        lastNonEmptyLine + 1
      );
    }
    __name(dedentBlockStringLines, "dedentBlockStringLines");
    function leadingWhitespace2(str) {
      let i = 0;
      while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
        ++i;
      }
      return i;
    }
    __name(leadingWhitespace2, "leadingWhitespace");
    function isPrintableAsBlockString(value) {
      if (value === "") {
        return true;
      }
      let isEmptyLine = true;
      let hasIndent = false;
      let hasCommonIndent = true;
      let seenNonEmptyLine = false;
      for (let i = 0; i < value.length; ++i) {
        switch (value.codePointAt(i)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 11:
          case 12:
          case 14:
          case 15:
            return false;
          // Has non-printable characters
          case 13:
            return false;
          // Has \r or \r\n which will be replaced as \n
          case 10:
            if (isEmptyLine && !seenNonEmptyLine) {
              return false;
            }
            seenNonEmptyLine = true;
            isEmptyLine = true;
            hasIndent = false;
            break;
          case 9:
          //   \t
          case 32:
            hasIndent || (hasIndent = isEmptyLine);
            break;
          default:
            hasCommonIndent && (hasCommonIndent = hasIndent);
            isEmptyLine = false;
        }
      }
      if (isEmptyLine) {
        return false;
      }
      if (hasCommonIndent && seenNonEmptyLine) {
        return false;
      }
      return true;
    }
    __name(isPrintableAsBlockString, "isPrintableAsBlockString");
    function printBlockString2(value, options) {
      const escapedValue = value.replace(/"""/g, '\\"""');
      const lines = escapedValue.split(/\r\n|[\n\r]/g);
      const isSingleLine = lines.length === 1;
      const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
        (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
      );
      const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
      const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
      const hasTrailingSlash = value.endsWith("\\");
      const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
      const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
      (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
      let result = "";
      const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
      if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
        result += "\n";
      }
      result += escapedValue;
      if (printAsMultipleLines || forceTrailingNewline) {
        result += "\n";
      }
      return '"""' + result + '"""';
    }
    __name(printBlockString2, "printBlockString");
  }
});

// ../node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "../node_modules/graphql/language/tokenKind.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenKind = void 0;
    var TokenKind2;
    exports2.TokenKind = TokenKind2;
    (function(TokenKind3) {
      TokenKind3["SOF"] = "<SOF>";
      TokenKind3["EOF"] = "<EOF>";
      TokenKind3["BANG"] = "!";
      TokenKind3["DOLLAR"] = "$";
      TokenKind3["AMP"] = "&";
      TokenKind3["PAREN_L"] = "(";
      TokenKind3["PAREN_R"] = ")";
      TokenKind3["SPREAD"] = "...";
      TokenKind3["COLON"] = ":";
      TokenKind3["EQUALS"] = "=";
      TokenKind3["AT"] = "@";
      TokenKind3["BRACKET_L"] = "[";
      TokenKind3["BRACKET_R"] = "]";
      TokenKind3["BRACE_L"] = "{";
      TokenKind3["PIPE"] = "|";
      TokenKind3["BRACE_R"] = "}";
      TokenKind3["NAME"] = "Name";
      TokenKind3["INT"] = "Int";
      TokenKind3["FLOAT"] = "Float";
      TokenKind3["STRING"] = "String";
      TokenKind3["BLOCK_STRING"] = "BlockString";
      TokenKind3["COMMENT"] = "Comment";
    })(TokenKind2 || (exports2.TokenKind = TokenKind2 = {}));
  }
});

// ../node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "../node_modules/graphql/language/lexer.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Lexer = void 0;
    exports2.isPunctuatorTokenKind = isPunctuatorTokenKind;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _blockString = require_blockString();
    var _characterClasses = require_characterClasses();
    var _tokenKind = require_tokenKind();
    var Lexer = class {
      static {
        __name(this, "Lexer");
      }
      /**
       * The previously focused non-ignored token.
       */
      /**
       * The currently focused non-ignored token.
       */
      /**
       * The (1-indexed) line containing the current token.
       */
      /**
       * The character offset at which the current line begins.
       */
      constructor(source) {
        const startOfFileToken = new _ast.Token(
          _tokenKind.TokenKind.SOF,
          0,
          0,
          0,
          0
        );
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      /**
       * Advances the token stream to the next non-ignored token.
       */
      advance() {
        this.lastToken = this.token;
        const token = this.token = this.lookahead();
        return token;
      }
      /**
       * Looks ahead and returns the next non-ignored token, but does not change
       * the state of Lexer.
       */
      lookahead() {
        let token = this.token;
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          do {
            if (token.next) {
              token = token.next;
            } else {
              const nextToken = readNextToken(this, token.end);
              token.next = nextToken;
              nextToken.prev = token;
              token = nextToken;
            }
          } while (token.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token;
      }
    };
    exports2.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    __name(isPunctuatorTokenKind, "isPunctuatorTokenKind");
    function isUnicodeScalarValue(code) {
      return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
    }
    __name(isUnicodeScalarValue, "isUnicodeScalarValue");
    function isSupplementaryCodePoint(body, location) {
      return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
    }
    __name(isSupplementaryCodePoint, "isSupplementaryCodePoint");
    function isLeadingSurrogate(code) {
      return code >= 55296 && code <= 56319;
    }
    __name(isLeadingSurrogate, "isLeadingSurrogate");
    function isTrailingSurrogate(code) {
      return code >= 56320 && code <= 57343;
    }
    __name(isTrailingSurrogate, "isTrailingSurrogate");
    function printCodePointAt(lexer, location) {
      const code = lexer.source.body.codePointAt(location);
      if (code === void 0) {
        return _tokenKind.TokenKind.EOF;
      } else if (code >= 32 && code <= 126) {
        const char = String.fromCodePoint(code);
        return char === '"' ? `'"'` : `"${char}"`;
      }
      return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
    }
    __name(printCodePointAt, "printCodePointAt");
    function createToken(lexer, kind, start, end, value) {
      const line = lexer.line;
      const col = 1 + start - lexer.lineStart;
      return new _ast.Token(kind, start, end, line, col, value);
    }
    __name(createToken, "createToken");
    function readNextToken(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        switch (code) {
          // Ignored ::
          //   - UnicodeBOM
          //   - WhiteSpace
          //   - LineTerminator
          //   - Comment
          //   - Comma
          //
          // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
          //
          // WhiteSpace ::
          //   - "Horizontal Tab (U+0009)"
          //   - "Space (U+0020)"
          //
          // Comma :: ,
          case 65279:
          // <BOM>
          case 9:
          // \t
          case 32:
          // <space>
          case 44:
            ++position;
            continue;
          // LineTerminator ::
          //   - "New Line (U+000A)"
          //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
          //   - "Carriage Return (U+000D)" "New Line (U+000A)"
          case 10:
            ++position;
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          case 13:
            if (body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            ++lexer.line;
            lexer.lineStart = position;
            continue;
          // Comment
          case 35:
            return readComment(lexer, position);
          // Token ::
          //   - Punctuator
          //   - Name
          //   - IntValue
          //   - FloatValue
          //   - StringValue
          //
          // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
          case 33:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BANG,
              position,
              position + 1
            );
          case 36:
            return createToken(
              lexer,
              _tokenKind.TokenKind.DOLLAR,
              position,
              position + 1
            );
          case 38:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AMP,
              position,
              position + 1
            );
          case 40:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_L,
              position,
              position + 1
            );
          case 41:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PAREN_R,
              position,
              position + 1
            );
          case 46:
            if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
              return createToken(
                lexer,
                _tokenKind.TokenKind.SPREAD,
                position,
                position + 3
              );
            }
            break;
          case 58:
            return createToken(
              lexer,
              _tokenKind.TokenKind.COLON,
              position,
              position + 1
            );
          case 61:
            return createToken(
              lexer,
              _tokenKind.TokenKind.EQUALS,
              position,
              position + 1
            );
          case 64:
            return createToken(
              lexer,
              _tokenKind.TokenKind.AT,
              position,
              position + 1
            );
          case 91:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_L,
              position,
              position + 1
            );
          case 93:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACKET_R,
              position,
              position + 1
            );
          case 123:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_L,
              position,
              position + 1
            );
          case 124:
            return createToken(
              lexer,
              _tokenKind.TokenKind.PIPE,
              position,
              position + 1
            );
          case 125:
            return createToken(
              lexer,
              _tokenKind.TokenKind.BRACE_R,
              position,
              position + 1
            );
          // StringValue
          case 34:
            if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
              return readBlockString(lexer, position);
            }
            return readString(lexer, position);
        }
        if ((0, _characterClasses.isDigit)(code) || code === 45) {
          return readNumber(lexer, position, code);
        }
        if ((0, _characterClasses.isNameStart)(code)) {
          return readName(lexer, position);
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
        );
      }
      return createToken(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
    }
    __name(readNextToken, "readNextToken");
    function readComment(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.COMMENT,
        start,
        position,
        body.slice(start + 1, position)
      );
    }
    __name(readComment, "readComment");
    function readNumber(lexer, start, firstCode) {
      const body = lexer.source.body;
      let position = start;
      let code = firstCode;
      let isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position);
      }
      if (code === 48) {
        code = body.charCodeAt(++position);
        if ((0, _characterClasses.isDigit)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, unexpected digit after 0: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      } else {
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position);
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(lexer, position, code);
        code = body.charCodeAt(position);
      }
      if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
      return createToken(
        lexer,
        isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
        start,
        position,
        body.slice(start, position)
      );
    }
    __name(readNumber, "readNumber");
    function readDigits(lexer, start, firstCode) {
      if (!(0, _characterClasses.isDigit)(firstCode)) {
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          start,
          `Invalid number, expected digit but got: ${printCodePointAt(
            lexer,
            start
          )}.`
        );
      }
      const body = lexer.source.body;
      let position = start + 1;
      while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
        ++position;
      }
      return position;
    }
    __name(readDigits, "readDigits");
    function readString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      let chunkStart = position;
      let value = "";
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34) {
          value += body.slice(chunkStart, position);
          return createToken(
            lexer,
            _tokenKind.TokenKind.STRING,
            start,
            position + 1,
            value
          );
        }
        if (code === 92) {
          value += body.slice(chunkStart, position);
          const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
          value += escape.value;
          position += escape.size;
          chunkStart = position;
          continue;
        }
        if (code === 10 || code === 13) {
          break;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    __name(readString, "readString");
    function readEscapedUnicodeVariableWidth(lexer, position) {
      const body = lexer.source.body;
      let point = 0;
      let size = 3;
      while (size < 12) {
        const code = body.charCodeAt(position + size++);
        if (code === 125) {
          if (size < 5 || !isUnicodeScalarValue(point)) {
            break;
          }
          return {
            value: String.fromCodePoint(point),
            size
          };
        }
        point = point << 4 | readHexDigit(code);
        if (point < 0) {
          break;
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(
          position,
          position + size
        )}".`
      );
    }
    __name(readEscapedUnicodeVariableWidth, "readEscapedUnicodeVariableWidth");
    function readEscapedUnicodeFixedWidth(lexer, position) {
      const body = lexer.source.body;
      const code = read16BitHexCode(body, position + 2);
      if (isUnicodeScalarValue(code)) {
        return {
          value: String.fromCodePoint(code),
          size: 6
        };
      }
      if (isLeadingSurrogate(code)) {
        if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
          const trailingCode = read16BitHexCode(body, position + 8);
          if (isTrailingSurrogate(trailingCode)) {
            return {
              value: String.fromCodePoint(code, trailingCode),
              size: 12
            };
          }
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
      );
    }
    __name(readEscapedUnicodeFixedWidth, "readEscapedUnicodeFixedWidth");
    function read16BitHexCode(body, position) {
      return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
    }
    __name(read16BitHexCode, "read16BitHexCode");
    function readHexDigit(code) {
      return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
    }
    __name(readHexDigit, "readHexDigit");
    function readEscapedCharacter(lexer, position) {
      const body = lexer.source.body;
      const code = body.charCodeAt(position + 1);
      switch (code) {
        case 34:
          return {
            value: '"',
            size: 2
          };
        case 92:
          return {
            value: "\\",
            size: 2
          };
        case 47:
          return {
            value: "/",
            size: 2
          };
        case 98:
          return {
            value: "\b",
            size: 2
          };
        case 102:
          return {
            value: "\f",
            size: 2
          };
        case 110:
          return {
            value: "\n",
            size: 2
          };
        case 114:
          return {
            value: "\r",
            size: 2
          };
        case 116:
          return {
            value: "	",
            size: 2
          };
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        `Invalid character escape sequence: "${body.slice(
          position,
          position + 2
        )}".`
      );
    }
    __name(readEscapedCharacter, "readEscapedCharacter");
    function readBlockString(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let lineStart = lexer.lineStart;
      let position = start + 3;
      let chunkStart = position;
      let currentLine = "";
      const blockLines = [];
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          const token = createToken(
            lexer,
            _tokenKind.TokenKind.BLOCK_STRING,
            start,
            position + 3,
            // Return a string of the lines joined with U+000A.
            (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
          );
          lexer.line += blockLines.length - 1;
          lexer.lineStart = lineStart;
          return token;
        }
        if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
          currentLine += body.slice(chunkStart, position);
          chunkStart = position + 1;
          position += 4;
          continue;
        }
        if (code === 10 || code === 13) {
          currentLine += body.slice(chunkStart, position);
          blockLines.push(currentLine);
          if (code === 13 && body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          currentLine = "";
          chunkStart = position;
          lineStart = position;
          continue;
        }
        if (isUnicodeScalarValue(code)) {
          ++position;
        } else if (isSupplementaryCodePoint(body, position)) {
          position += 2;
        } else {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid character within String: ${printCodePointAt(
              lexer,
              position
            )}.`
          );
        }
      }
      throw (0, _syntaxError.syntaxError)(
        lexer.source,
        position,
        "Unterminated string."
      );
    }
    __name(readBlockString, "readBlockString");
    function readName(lexer, start) {
      const body = lexer.source.body;
      const bodyLength = body.length;
      let position = start + 1;
      while (position < bodyLength) {
        const code = body.charCodeAt(position);
        if ((0, _characterClasses.isNameContinue)(code)) {
          ++position;
        } else {
          break;
        }
      }
      return createToken(
        lexer,
        _tokenKind.TokenKind.NAME,
        start,
        position,
        body.slice(start, position)
      );
    }
    __name(readName, "readName");
  }
});

// ../node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "../node_modules/graphql/jsutils/inspect.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.inspect = inspect3;
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH2 = 2;
    function inspect3(value) {
      return formatValue2(value, []);
    }
    __name(inspect3, "inspect");
    function formatValue2(value, seenValues) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? `[function ${value.name}]` : "[function]";
        case "object":
          return formatObjectValue2(value, seenValues);
        default:
          return String(value);
      }
    }
    __name(formatValue2, "formatValue");
    function formatObjectValue2(value, previouslySeenValues) {
      if (value === null) {
        return "null";
      }
      if (previouslySeenValues.includes(value)) {
        return "[Circular]";
      }
      const seenValues = [...previouslySeenValues, value];
      if (isJSONable2(value)) {
        const jsonValue = value.toJSON();
        if (jsonValue !== value) {
          return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray2(value, seenValues);
      }
      return formatObject2(value, seenValues);
    }
    __name(formatObjectValue2, "formatObjectValue");
    function isJSONable2(value) {
      return typeof value.toJSON === "function";
    }
    __name(isJSONable2, "isJSONable");
    function formatObject2(object, seenValues) {
      const entries = Object.entries(object);
      if (entries.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[" + getObjectTag2(object) + "]";
      }
      const properties = entries.map(
        ([key, value]) => key + ": " + formatValue2(value, seenValues)
      );
      return "{ " + properties.join(", ") + " }";
    }
    __name(formatObject2, "formatObject");
    function formatArray2(array, seenValues) {
      if (array.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
        return "[Array]";
      }
      const len = Math.min(MAX_ARRAY_LENGTH, array.length);
      const remaining = array.length - len;
      const items = [];
      for (let i = 0; i < len; ++i) {
        items.push(formatValue2(array[i], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push(`... ${remaining} more items`);
      }
      return "[" + items.join(", ") + "]";
    }
    __name(formatArray2, "formatArray");
    function getObjectTag2(object) {
      const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object.constructor === "function") {
        const name = object.constructor.name;
        if (typeof name === "string" && name !== "") {
          return name;
        }
      }
      return tag;
    }
    __name(getObjectTag2, "getObjectTag");
  }
});

// ../node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "../node_modules/graphql/jsutils/instanceOf.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.instanceOf = void 0;
    var _inspect = require_inspect();
    var isProduction = globalThis.process && // eslint-disable-next-line no-undef
    false;
    var instanceOf = (
      /* c8 ignore next 6 */
      // FIXME: https://github.com/graphql/graphql-js/issues/2317
      isProduction ? /* @__PURE__ */ __name(function instanceOf2(value, constructor) {
        return value instanceof constructor;
      }, "instanceOf") : /* @__PURE__ */ __name(function instanceOf2(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (typeof value === "object" && value !== null) {
          var _value$constructor;
          const className = constructor.prototype[Symbol.toStringTag];
          const valueClassName = (
            // We still need to support constructor's name to detect conflicts with older versions of this library.
            Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
          );
          if (className === valueClassName) {
            const stringifiedValue = (0, _inspect.inspect)(value);
            throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
          }
        }
        return false;
      }, "instanceOf")
    );
    exports2.instanceOf = instanceOf;
  }
});

// ../node_modules/graphql/language/source.js
var require_source = __commonJS({
  "../node_modules/graphql/language/source.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Source = void 0;
    exports2.isSource = isSource;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var Source2 = class {
      static {
        __name(this, "Source");
      }
      constructor(body, name = "GraphQL request", locationOffset = {
        line: 1,
        column: 1
      }) {
        typeof body === "string" || (0, _devAssert.devAssert)(
          false,
          `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
        );
        this.body = body;
        this.name = name;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
          false,
          "line in locationOffset is 1-indexed and must be positive."
        );
        this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
          false,
          "column in locationOffset is 1-indexed and must be positive."
        );
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    };
    exports2.Source = Source2;
    function isSource(source) {
      return (0, _instanceOf.instanceOf)(source, Source2);
    }
    __name(isSource, "isSource");
  }
});

// ../node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "../node_modules/graphql/language/parser.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Parser = void 0;
    exports2.parse = parse3;
    exports2.parseConstValue = parseConstValue;
    exports2.parseType = parseType;
    exports2.parseValue = parseValue2;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function parse3(source, options) {
      const parser = new Parser(source, options);
      const document = parser.parseDocument();
      Object.defineProperty(document, "tokenCount", {
        enumerable: false,
        value: parser.tokenCount
      });
      return document;
    }
    __name(parse3, "parse");
    function parseValue2(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    __name(parseValue2, "parseValue");
    function parseConstValue(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const value = parser.parseConstValueLiteral();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    __name(parseConstValue, "parseConstValue");
    function parseType(source, options) {
      const parser = new Parser(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      const type2 = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type2;
    }
    __name(parseType, "parseType");
    var Parser = class {
      static {
        __name(this, "Parser");
      }
      constructor(source, options = {}) {
        const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options;
        this._tokenCounter = 0;
      }
      get tokenCount() {
        return this._tokenCounter;
      }
      /**
       * Converts a name lex token into a name parse node.
       */
      parseName() {
        const token = this.expectToken(_tokenKind.TokenKind.NAME);
        return this.node(token, {
          kind: _kinds.Kind.NAME,
          value: token.value
        });
      }
      // Implements the parsing rules in the Document section.
      /**
       * Document : Definition+
       */
      parseDocument() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(
            _tokenKind.TokenKind.SOF,
            this.parseDefinition,
            _tokenKind.TokenKind.EOF
          )
        });
      }
      /**
       * Definition :
       *   - ExecutableDefinition
       *   - TypeSystemDefinition
       *   - TypeSystemExtension
       *
       * ExecutableDefinition :
       *   - OperationDefinition
       *   - FragmentDefinition
       *
       * TypeSystemDefinition :
       *   - SchemaDefinition
       *   - TypeDefinition
       *   - DirectiveDefinition
       *
       * TypeDefinition :
       *   - ScalarTypeDefinition
       *   - ObjectTypeDefinition
       *   - InterfaceTypeDefinition
       *   - UnionTypeDefinition
       *   - EnumTypeDefinition
       *   - InputObjectTypeDefinition
       */
      parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const hasDescription = this.peekDescription();
        const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (hasDescription) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (keywordToken.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      // Implements the parsing rules in the Operations section.
      /**
       * OperationDefinition :
       *  - SelectionSet
       *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
       */
      parseOperationDefinition() {
        const start = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: _ast.OperationTypeNode.QUERY,
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet()
          });
        }
        const operation = this.parseOperationType();
        let name;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name = this.parseName();
        }
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * OperationType : one of query mutation subscription
       */
      parseOperationType() {
        const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return _ast.OperationTypeNode.QUERY;
          case "mutation":
            return _ast.OperationTypeNode.MUTATION;
          case "subscription":
            return _ast.OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(operationToken);
      }
      /**
       * VariableDefinitions : ( VariableDefinition+ )
       */
      parseVariableDefinitions() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseVariableDefinition,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
       */
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
          directives: this.parseConstDirectives()
        });
      }
      /**
       * Variable : $ Name
       */
      parseVariable() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return this.node(start, {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName()
        });
      }
      /**
       * ```
       * SelectionSet : { Selection+ }
       * ```
       */
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseSelection,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      /**
       * Selection :
       *   - Field
       *   - FragmentSpread
       *   - InlineFragment
       */
      parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      /**
       * Field : Alias? Name Arguments? Directives? SelectionSet?
       *
       * Alias : Name :
       */
      parseField() {
        const start = this._lexer.token;
        const nameOrAlias = this.parseName();
        let alias;
        let name;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name = this.parseName();
        } else {
          name = nameOrAlias;
        }
        return this.node(start, {
          kind: _kinds.Kind.FIELD,
          alias,
          name,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
        });
      }
      /**
       * Arguments[Const] : ( Argument[?Const]+ )
       */
      parseArguments(isConst) {
        const item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          item,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * Argument[Const] : Name : Value[?Const]
       */
      parseArgument(isConst = false) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.ARGUMENT,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      // Implements the parsing rules in the Fragments section.
      /**
       * Corresponds to both FragmentSpread and InlineFragment in the spec.
       *
       * FragmentSpread : ... FragmentName Directives?
       *
       * InlineFragment : ... TypeCondition? Directives? SelectionSet
       */
      parseFragment() {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        const hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false)
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentDefinition :
       *   - fragment FragmentName on TypeCondition Directives? SelectionSet
       *
       * TypeCondition : NamedType
       */
      parseFragmentDefinition() {
        const start = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        return this.node(start, {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      /**
       * FragmentName : Name but not `on`
       */
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      // Implements the parsing rules in the Values section.
      /**
       * Value[Const] :
       *   - [~Const] Variable
       *   - IntValue
       *   - FloatValue
       *   - StringValue
       *   - BooleanValue
       *   - NullValue
       *   - EnumValue
       *   - ListValue[?Const]
       *   - ObjectValue[?Const]
       *
       * BooleanValue : one of `true` `false`
       *
       * NullValue : `null`
       *
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseValueLiteral(isConst) {
        const token = this._lexer.token;
        switch (token.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.INT,
              value: token.value
            });
          case _tokenKind.TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(token, {
              kind: _kinds.Kind.FLOAT,
              value: token.value
            });
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this.advanceLexer();
            switch (token.value) {
              case "true":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true
                });
              case "false":
                return this.node(token, {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false
                });
              case "null":
                return this.node(token, {
                  kind: _kinds.Kind.NULL
                });
              default:
                return this.node(token, {
                  kind: _kinds.Kind.ENUM,
                  value: token.value
                });
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (isConst) {
              this.expectToken(_tokenKind.TokenKind.DOLLAR);
              if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                const varName = this._lexer.token.value;
                throw (0, _syntaxError.syntaxError)(
                  this._lexer.source,
                  token.start,
                  `Unexpected variable "$${varName}" in constant value.`
                );
              } else {
                throw this.unexpected(token);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const token = this._lexer.token;
        this.advanceLexer();
        return this.node(token, {
          kind: _kinds.Kind.STRING,
          value: token.value,
          block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
        });
      }
      /**
       * ListValue[Const] :
       *   - [ ]
       *   - [ Value[?Const]+ ]
       */
      parseList(isConst) {
        const item = /* @__PURE__ */ __name(() => this.parseValueLiteral(isConst), "item");
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.LIST,
          values: this.any(
            _tokenKind.TokenKind.BRACKET_L,
            item,
            _tokenKind.TokenKind.BRACKET_R
          )
        });
      }
      /**
       * ```
       * ObjectValue[Const] :
       *   - { }
       *   - { ObjectField[?Const]+ }
       * ```
       */
      parseObject(isConst) {
        const item = /* @__PURE__ */ __name(() => this.parseObjectField(isConst), "item");
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(
            _tokenKind.TokenKind.BRACE_L,
            item,
            _tokenKind.TokenKind.BRACE_R
          )
        });
      }
      /**
       * ObjectField[Const] : Name : Value[?Const]
       */
      parseObjectField(isConst) {
        const start = this._lexer.token;
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_FIELD,
          name,
          value: this.parseValueLiteral(isConst)
        });
      }
      // Implements the parsing rules in the Directives section.
      /**
       * Directives[Const] : Directive[?Const]+
       */
      parseDirectives(isConst) {
        const directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      /**
       * ```
       * Directive[Const] : @ Name Arguments[?Const]?
       * ```
       */
      parseDirective(isConst) {
        const start = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst)
        });
      }
      // Implements the parsing rules in the Types section.
      /**
       * Type :
       *   - NamedType
       *   - ListType
       *   - NonNullType
       */
      parseTypeReference() {
        const start = this._lexer.token;
        let type2;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          const innerType = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type2 = this.node(start, {
            kind: _kinds.Kind.LIST_TYPE,
            type: innerType
          });
        } else {
          type2 = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return this.node(start, {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type: type2
          });
        }
        return type2;
      }
      /**
       * NamedType : Name
       */
      parseNamedType() {
        return this.node(this._lexer.token, {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName()
        });
      }
      // Implements the parsing rules in the Type Definition section.
      peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      }
      /**
       * Description : StringValue
       */
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      /**
       * ```
       * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
       * ```
       */
      parseSchemaDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.many(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes
        });
      }
      /**
       * OperationTypeDefinition : OperationType : NamedType
       */
      parseOperationTypeDefinition() {
        const start = this._lexer.token;
        const operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type2 = this.parseNamedType();
        return this.node(start, {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type: type2
        });
      }
      /**
       * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
       */
      parseScalarTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * ObjectTypeDefinition :
       *   Description?
       *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
       */
      parseObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * ImplementsInterfaces :
       *   - implements `&`? NamedType
       *   - ImplementsInterfaces & NamedType
       */
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
      }
      /**
       * ```
       * FieldsDefinition : { FieldDefinition+ }
       * ```
       */
      parseFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseFieldDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * FieldDefinition :
       *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
       */
      parseFieldDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type2 = this.parseTypeReference();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name,
          arguments: args,
          type: type2,
          directives
        });
      }
      /**
       * ArgumentsDefinition : ( InputValueDefinition+ )
       */
      parseArgumentDefs() {
        return this.optionalMany(
          _tokenKind.TokenKind.PAREN_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.PAREN_R
        );
      }
      /**
       * InputValueDefinition :
       *   - Description? Name : Type DefaultValue? Directives[Const]?
       */
      parseInputValueDef() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        const type2 = this.parseTypeReference();
        let defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseConstValueLiteral();
        }
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name,
          type: type2,
          defaultValue,
          directives
        });
      }
      /**
       * InterfaceTypeDefinition :
       *   - Description? interface Name Directives[Const]? FieldsDefinition?
       */
      parseInterfaceTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeDefinition :
       *   - Description? union Name Directives[Const]? UnionMemberTypes?
       */
      parseUnionTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types3 = this.parseUnionMemberTypes();
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name,
          directives,
          types: types3
        });
      }
      /**
       * UnionMemberTypes :
       *   - = `|`? NamedType
       *   - UnionMemberTypes | NamedType
       */
      parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      }
      /**
       * EnumTypeDefinition :
       *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
       */
      parseEnumTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name,
          directives,
          values
        });
      }
      /**
       * ```
       * EnumValuesDefinition : { EnumValueDefinition+ }
       * ```
       */
      parseEnumValuesDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseEnumValueDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * EnumValueDefinition : Description? EnumValue Directives[Const]?
       */
      parseEnumValueDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        const name = this.parseEnumValueName();
        const directives = this.parseConstDirectives();
        return this.node(start, {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name,
          directives
        });
      }
      /**
       * EnumValue : Name but not `true`, `false` or `null`
       */
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(
              this._lexer.token
            )} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      /**
       * InputObjectTypeDefinition :
       *   - Description? input Name Directives[Const]? InputFieldsDefinition?
       */
      parseInputObjectTypeDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * InputFieldsDefinition : { InputValueDefinition+ }
       * ```
       */
      parseInputFieldsDefinition() {
        return this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseInputValueDef,
          _tokenKind.TokenKind.BRACE_R
        );
      }
      /**
       * TypeSystemExtension :
       *   - SchemaExtension
       *   - TypeExtension
       *
       * TypeExtension :
       *   - ScalarTypeExtension
       *   - ObjectTypeExtension
       *   - InterfaceTypeExtension
       *   - UnionTypeExtension
       *   - EnumTypeExtension
       *   - InputObjectTypeDefinition
       */
      parseTypeSystemExtension() {
        const keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      }
      /**
       * ```
       * SchemaExtension :
       *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
       *  - extend schema Directives[Const]
       * ```
       */
      parseSchemaExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const directives = this.parseConstDirectives();
        const operationTypes = this.optionalMany(
          _tokenKind.TokenKind.BRACE_L,
          this.parseOperationTypeDefinition,
          _tokenKind.TokenKind.BRACE_R
        );
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes
        });
      }
      /**
       * ScalarTypeExtension :
       *   - extend scalar Name Directives[Const]
       */
      parseScalarTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name,
          directives
        });
      }
      /**
       * ObjectTypeExtension :
       *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend type Name ImplementsInterfaces? Directives[Const]
       *  - extend type Name ImplementsInterfaces
       */
      parseObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * InterfaceTypeExtension :
       *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
       *  - extend interface Name ImplementsInterfaces? Directives[Const]
       *  - extend interface Name ImplementsInterfaces
       */
      parseInterfaceTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const name = this.parseName();
        const interfaces = this.parseImplementsInterfaces();
        const directives = this.parseConstDirectives();
        const fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name,
          interfaces,
          directives,
          fields
        });
      }
      /**
       * UnionTypeExtension :
       *   - extend union Name Directives[Const]? UnionMemberTypes
       *   - extend union Name Directives[Const]
       */
      parseUnionTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const types3 = this.parseUnionMemberTypes();
        if (directives.length === 0 && types3.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name,
          directives,
          types: types3
        });
      }
      /**
       * EnumTypeExtension :
       *   - extend enum Name Directives[Const]? EnumValuesDefinition
       *   - extend enum Name Directives[Const]
       */
      parseEnumTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name,
          directives,
          values
        });
      }
      /**
       * InputObjectTypeExtension :
       *   - extend input Name Directives[Const]? InputFieldsDefinition
       *   - extend input Name Directives[Const]
       */
      parseInputObjectTypeExtension() {
        const start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const name = this.parseName();
        const directives = this.parseConstDirectives();
        const fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return this.node(start, {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name,
          directives,
          fields
        });
      }
      /**
       * ```
       * DirectiveDefinition :
       *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
       * ```
       */
      parseDirectiveDefinition() {
        const start = this._lexer.token;
        const description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        const name = this.parseName();
        const args = this.parseArgumentDefs();
        const repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const locations = this.parseDirectiveLocations();
        return this.node(start, {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name,
          arguments: args,
          repeatable,
          locations
        });
      }
      /**
       * DirectiveLocations :
       *   - `|`? DirectiveLocation
       *   - DirectiveLocations | DirectiveLocation
       */
      parseDirectiveLocations() {
        return this.delimitedMany(
          _tokenKind.TokenKind.PIPE,
          this.parseDirectiveLocation
        );
      }
      /*
       * DirectiveLocation :
       *   - ExecutableDirectiveLocation
       *   - TypeSystemDirectiveLocation
       *
       * ExecutableDirectiveLocation : one of
       *   `QUERY`
       *   `MUTATION`
       *   `SUBSCRIPTION`
       *   `FIELD`
       *   `FRAGMENT_DEFINITION`
       *   `FRAGMENT_SPREAD`
       *   `INLINE_FRAGMENT`
       *
       * TypeSystemDirectiveLocation : one of
       *   `SCHEMA`
       *   `SCALAR`
       *   `OBJECT`
       *   `FIELD_DEFINITION`
       *   `ARGUMENT_DEFINITION`
       *   `INTERFACE`
       *   `UNION`
       *   `ENUM`
       *   `ENUM_VALUE`
       *   `INPUT_OBJECT`
       *   `INPUT_FIELD_DEFINITION`
       */
      parseDirectiveLocation() {
        const start = this._lexer.token;
        const name = this.parseName();
        if (Object.prototype.hasOwnProperty.call(
          _directiveLocation.DirectiveLocation,
          name.value
        )) {
          return name;
        }
        throw this.unexpected(start);
      }
      // Core parsing utility functions
      /**
       * Returns a node that, if configured to do so, sets a "loc" field as a
       * location object, used to identify the place in the source that created a
       * given parsed object.
       */
      node(startToken, node) {
        if (this._options.noLocation !== true) {
          node.loc = new _ast.Location(
            startToken,
            this._lexer.lastToken,
            this._lexer.source
          );
        }
        return node;
      }
      /**
       * Determines if the next token is of a given kind
       */
      peek(kind) {
        return this._lexer.token.kind === kind;
      }
      /**
       * If the next token is of the given kind, return that token after advancing the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return token;
        }
        throw (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
        );
      }
      /**
       * If the next token is of the given kind, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalToken(kind) {
        const token = this._lexer.token;
        if (token.kind === kind) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * If the next token is a given keyword, advance the lexer.
       * Otherwise, do not change the parser state and throw an error.
       */
      expectKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
        } else {
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Expected "${value}", found ${getTokenDesc(token)}.`
          );
        }
      }
      /**
       * If the next token is a given keyword, return "true" after advancing the lexer.
       * Otherwise, do not change the parser state and return "false".
       */
      expectOptionalKeyword(value) {
        const token = this._lexer.token;
        if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      /**
       * Helper function for creating an error when an unexpected lexed token is encountered.
       */
      unexpected(atToken) {
        const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(
          this._lexer.source,
          token.start,
          `Unexpected ${getTokenDesc(token)}.`
        );
      }
      /**
       * Returns a possibly empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      }
      /**
       * Returns a list of parse nodes, determined by the parseFn.
       * It can be empty only if open token is missing otherwise it will always return non-empty list
       * that begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list begins with a lex token of openKind and ends with a lex token of closeKind.
       * Advances the parser to the next lex token after the closing token.
       */
      many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      /**
       * Returns a non-empty list of parse nodes, determined by the parseFn.
       * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
       * Advances the parser to the next lex token after last item in the list.
       */
      delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      }
      advanceLexer() {
        const { maxTokens } = this._options;
        const token = this._lexer.advance();
        if (token.kind !== _tokenKind.TokenKind.EOF) {
          ++this._tokenCounter;
          if (maxTokens !== void 0 && this._tokenCounter > maxTokens) {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token.start,
              `Document contains more that ${maxTokens} tokens. Parsing aborted.`
            );
          }
        }
      }
    };
    exports2.Parser = Parser;
    function getTokenDesc(token) {
      const value = token.value;
      return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
    }
    __name(getTokenDesc, "getTokenDesc");
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
    }
    __name(getTokenKindDesc, "getTokenKindDesc");
  }
});

// ../node_modules/graphql/jsutils/didYouMean.js
var require_didYouMean = __commonJS({
  "../node_modules/graphql/jsutils/didYouMean.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.didYouMean = didYouMean;
    var MAX_SUGGESTIONS = 5;
    function didYouMean(firstArg, secondArg) {
      const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
      let message = " Did you mean ";
      if (subMessage) {
        message += subMessage + " ";
      }
      const suggestions = suggestionsArg.map((x) => `"${x}"`);
      switch (suggestions.length) {
        case 0:
          return "";
        case 1:
          return message + suggestions[0] + "?";
        case 2:
          return message + suggestions[0] + " or " + suggestions[1] + "?";
      }
      const selected = suggestions.slice(0, MAX_SUGGESTIONS);
      const lastItem = selected.pop();
      return message + selected.join(", ") + ", or " + lastItem + "?";
    }
    __name(didYouMean, "didYouMean");
  }
});

// ../node_modules/graphql/jsutils/identityFunc.js
var require_identityFunc = __commonJS({
  "../node_modules/graphql/jsutils/identityFunc.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.identityFunc = identityFunc;
    function identityFunc(x) {
      return x;
    }
    __name(identityFunc, "identityFunc");
  }
});

// ../node_modules/graphql/jsutils/keyMap.js
var require_keyMap = __commonJS({
  "../node_modules/graphql/jsutils/keyMap.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyMap = keyMap;
    function keyMap(list, keyFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = item;
      }
      return result;
    }
    __name(keyMap, "keyMap");
  }
});

// ../node_modules/graphql/jsutils/keyValMap.js
var require_keyValMap = __commonJS({
  "../node_modules/graphql/jsutils/keyValMap.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keyValMap = keyValMap;
    function keyValMap(list, keyFn, valFn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const item of list) {
        result[keyFn(item)] = valFn(item);
      }
      return result;
    }
    __name(keyValMap, "keyValMap");
  }
});

// ../node_modules/graphql/jsutils/mapValue.js
var require_mapValue = __commonJS({
  "../node_modules/graphql/jsutils/mapValue.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapValue = mapValue;
    function mapValue(map, fn) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map)) {
        result[key] = fn(map[key], key);
      }
      return result;
    }
    __name(mapValue, "mapValue");
  }
});

// ../node_modules/graphql/jsutils/naturalCompare.js
var require_naturalCompare = __commonJS({
  "../node_modules/graphql/jsutils/naturalCompare.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.naturalCompare = naturalCompare;
    function naturalCompare(aStr, bStr) {
      let aIndex = 0;
      let bIndex = 0;
      while (aIndex < aStr.length && bIndex < bStr.length) {
        let aChar = aStr.charCodeAt(aIndex);
        let bChar = bStr.charCodeAt(bIndex);
        if (isDigit(aChar) && isDigit(bChar)) {
          let aNum = 0;
          do {
            ++aIndex;
            aNum = aNum * 10 + aChar - DIGIT_0;
            aChar = aStr.charCodeAt(aIndex);
          } while (isDigit(aChar) && aNum > 0);
          let bNum = 0;
          do {
            ++bIndex;
            bNum = bNum * 10 + bChar - DIGIT_0;
            bChar = bStr.charCodeAt(bIndex);
          } while (isDigit(bChar) && bNum > 0);
          if (aNum < bNum) {
            return -1;
          }
          if (aNum > bNum) {
            return 1;
          }
        } else {
          if (aChar < bChar) {
            return -1;
          }
          if (aChar > bChar) {
            return 1;
          }
          ++aIndex;
          ++bIndex;
        }
      }
      return aStr.length - bStr.length;
    }
    __name(naturalCompare, "naturalCompare");
    var DIGIT_0 = 48;
    var DIGIT_9 = 57;
    function isDigit(code) {
      return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
    }
    __name(isDigit, "isDigit");
  }
});

// ../node_modules/graphql/jsutils/suggestionList.js
var require_suggestionList = __commonJS({
  "../node_modules/graphql/jsutils/suggestionList.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.suggestionList = suggestionList;
    var _naturalCompare = require_naturalCompare();
    function suggestionList(input, options) {
      const optionsByDistance = /* @__PURE__ */ Object.create(null);
      const lexicalDistance = new LexicalDistance(input);
      const threshold = Math.floor(input.length * 0.4) + 1;
      for (const option of options) {
        const distance = lexicalDistance.measure(option, threshold);
        if (distance !== void 0) {
          optionsByDistance[option] = distance;
        }
      }
      return Object.keys(optionsByDistance).sort((a, b) => {
        const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
        return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a, b);
      });
    }
    __name(suggestionList, "suggestionList");
    var LexicalDistance = class {
      static {
        __name(this, "LexicalDistance");
      }
      constructor(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0),
          new Array(input.length + 1).fill(0)
        ];
      }
      measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        const optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        let a = stringToArray(optionLowerCase);
        let b = this._inputArray;
        if (a.length < b.length) {
          const tmp = a;
          a = b;
          b = tmp;
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        const rows = this._rows;
        for (let j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (let i = 1; i <= aLength; i++) {
          const upRow = rows[(i - 1) % 3];
          const currentRow = rows[i % 3];
          let smallestCell = currentRow[0] = i;
          for (let j = 1; j <= bLength; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            let currentCell = Math.min(
              upRow[j] + 1,
              // delete
              currentRow[j - 1] + 1,
              // insert
              upRow[j - 1] + cost
              // substitute
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        const distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      }
    };
    function stringToArray(str) {
      const strLength = str.length;
      const array = new Array(strLength);
      for (let i = 0; i < strLength; ++i) {
        array[i] = str.charCodeAt(i);
      }
      return array;
    }
    __name(stringToArray, "stringToArray");
  }
});

// ../node_modules/graphql/jsutils/toObjMap.js
var require_toObjMap = __commonJS({
  "../node_modules/graphql/jsutils/toObjMap.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toObjMap = toObjMap;
    function toObjMap(obj) {
      if (obj == null) {
        return /* @__PURE__ */ Object.create(null);
      }
      if (Object.getPrototypeOf(obj) === null) {
        return obj;
      }
      const map = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(obj)) {
        map[key] = value;
      }
      return map;
    }
    __name(toObjMap, "toObjMap");
  }
});

// ../node_modules/graphql/language/printString.js
var require_printString = __commonJS({
  "../node_modules/graphql/language/printString.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printString = printString;
    function printString(str) {
      return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
    }
    __name(printString, "printString");
    var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(str) {
      return escapeSequences[str.charCodeAt(0)];
    }
    __name(escapedReplacer, "escapedReplacer");
    var escapeSequences = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 2F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 3F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 4F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      // 5F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      // 6F
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F"
    ];
  }
});

// ../node_modules/graphql/language/visitor.js
var require_visitor = __commonJS({
  "../node_modules/graphql/language/visitor.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BREAK = void 0;
    exports2.getEnterLeaveForKind = getEnterLeaveForKind;
    exports2.getVisitFn = getVisitFn;
    exports2.visit = visit2;
    exports2.visitInParallel = visitInParallel;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var BREAK = Object.freeze({});
    exports2.BREAK = BREAK;
    function visit2(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
      const enterLeaveMap = /* @__PURE__ */ new Map();
      for (const kind of Object.values(_kinds.Kind)) {
        enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
      }
      let stack = void 0;
      let inArray = Array.isArray(root);
      let keys = [root];
      let index = -1;
      let edits = [];
      let node = root;
      let key = void 0;
      let parent = void 0;
      const path = [];
      const ancestors = [];
      do {
        index++;
        const isLeaving = index === keys.length;
        const isEdited = isLeaving && edits.length !== 0;
        if (isLeaving) {
          key = ancestors.length === 0 ? void 0 : path[path.length - 1];
          node = parent;
          parent = ancestors.pop();
          if (isEdited) {
            if (inArray) {
              node = node.slice();
              let editOffset = 0;
              for (const [editKey, editValue] of edits) {
                const arrayKey = editKey - editOffset;
                if (editValue === null) {
                  node.splice(arrayKey, 1);
                  editOffset++;
                } else {
                  node[arrayKey] = editValue;
                }
              }
            } else {
              node = { ...node };
              for (const [editKey, editValue] of edits) {
                node[editKey] = editValue;
              }
            }
          }
          index = stack.index;
          keys = stack.keys;
          edits = stack.edits;
          inArray = stack.inArray;
          stack = stack.prev;
        } else if (parent) {
          key = inArray ? index : keys[index];
          node = parent[key];
          if (node === null || node === void 0) {
            continue;
          }
          path.push(key);
        }
        let result;
        if (!Array.isArray(node)) {
          var _enterLeaveMap$get, _enterLeaveMap$get2;
          (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
            false,
            `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
          );
          const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
          result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
          if (result === BREAK) {
            break;
          }
          if (result === false) {
            if (!isLeaving) {
              path.pop();
              continue;
            }
          } else if (result !== void 0) {
            edits.push([key, result]);
            if (!isLeaving) {
              if ((0, _ast.isNode)(result)) {
                node = result;
              } else {
                path.pop();
                continue;
              }
            }
          }
        }
        if (result === void 0 && isEdited) {
          edits.push([key, node]);
        }
        if (isLeaving) {
          path.pop();
        } else {
          var _node$kind;
          stack = {
            inArray,
            index,
            keys,
            edits,
            prev: stack
          };
          inArray = Array.isArray(node);
          keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
          index = -1;
          edits = [];
          if (parent) {
            ancestors.push(parent);
          }
          parent = node;
        }
      } while (stack !== void 0);
      if (edits.length !== 0) {
        return edits[edits.length - 1][1];
      }
      return root;
    }
    __name(visit2, "visit");
    function visitInParallel(visitors) {
      const skipping = new Array(visitors.length).fill(null);
      const mergedVisitor = /* @__PURE__ */ Object.create(null);
      for (const kind of Object.values(_kinds.Kind)) {
        let hasVisitor = false;
        const enterList = new Array(visitors.length).fill(void 0);
        const leaveList = new Array(visitors.length).fill(void 0);
        for (let i = 0; i < visitors.length; ++i) {
          const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
          hasVisitor || (hasVisitor = enter != null || leave != null);
          enterList[i] = enter;
          leaveList[i] = leave;
        }
        if (!hasVisitor) {
          continue;
        }
        const mergedEnterLeave = {
          enter(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _enterList$i;
                const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                if (result === false) {
                  skipping[i] = node;
                } else if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0) {
                  return result;
                }
              }
            }
          },
          leave(...args) {
            const node = args[0];
            for (let i = 0; i < visitors.length; i++) {
              if (skipping[i] === null) {
                var _leaveList$i;
                const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                if (result === BREAK) {
                  skipping[i] = BREAK;
                } else if (result !== void 0 && result !== false) {
                  return result;
                }
              } else if (skipping[i] === node) {
                skipping[i] = null;
              }
            }
          }
        };
        mergedVisitor[kind] = mergedEnterLeave;
      }
      return mergedVisitor;
    }
    __name(visitInParallel, "visitInParallel");
    function getEnterLeaveForKind(visitor, kind) {
      const kindVisitor = visitor[kind];
      if (typeof kindVisitor === "object") {
        return kindVisitor;
      } else if (typeof kindVisitor === "function") {
        return {
          enter: kindVisitor,
          leave: void 0
        };
      }
      return {
        enter: visitor.enter,
        leave: visitor.leave
      };
    }
    __name(getEnterLeaveForKind, "getEnterLeaveForKind");
    function getVisitFn(visitor, kind, isLeaving) {
      const { enter, leave } = getEnterLeaveForKind(visitor, kind);
      return isLeaving ? leave : enter;
    }
    __name(getVisitFn, "getVisitFn");
  }
});

// ../node_modules/graphql/language/printer.js
var require_printer = __commonJS({
  "../node_modules/graphql/language/printer.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.print = print4;
    var _blockString = require_blockString();
    var _printString = require_printString();
    var _visitor = require_visitor();
    function print4(ast) {
      return (0, _visitor.visit)(ast, printDocASTReducer2);
    }
    __name(print4, "print");
    var MAX_LINE_LENGTH2 = 80;
    var printDocASTReducer2 = {
      Name: {
        leave: /* @__PURE__ */ __name((node) => node.value, "leave")
      },
      Variable: {
        leave: /* @__PURE__ */ __name((node) => "$" + node.name, "leave")
      },
      // Document
      Document: {
        leave: /* @__PURE__ */ __name((node) => join2(node.definitions, "\n\n"), "leave")
      },
      OperationDefinition: {
        leave(node) {
          const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
          const prefix = join2(
            [
              node.operation,
              join2([node.name, varDefs]),
              join2(node.directives, " ")
            ],
            " "
          );
          return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
        }
      },
      VariableDefinition: {
        leave: /* @__PURE__ */ __name(({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives, " ")), "leave")
      },
      SelectionSet: {
        leave: /* @__PURE__ */ __name(({ selections }) => block2(selections), "leave")
      },
      Field: {
        leave({ alias, name, arguments: args, directives, selectionSet }) {
          const prefix = wrap2("", alias, ": ") + name;
          let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
          if (argsLine.length > MAX_LINE_LENGTH2) {
            argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
          }
          return join2([argsLine, join2(directives, " "), selectionSet], " ");
        }
      },
      Argument: {
        leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave")
      },
      // Fragments
      FragmentSpread: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => "..." + name + wrap2(" ", join2(directives, " ")), "leave")
      },
      InlineFragment: {
        leave: /* @__PURE__ */ __name(({ typeCondition, directives, selectionSet }) => join2(
          [
            "...",
            wrap2("on ", typeCondition),
            join2(directives, " "),
            selectionSet
          ],
          " "
        ), "leave")
      },
      FragmentDefinition: {
        leave: /* @__PURE__ */ __name(({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
          // or removed in the future.
          `fragment ${name}${wrap2("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join2(directives, " "), " ")}` + selectionSet
        ), "leave")
      },
      // Value
      IntValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value, "leave")
      },
      FloatValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value, "leave")
      },
      StringValue: {
        leave: /* @__PURE__ */ __name(({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value), "leave")
      },
      BooleanValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value ? "true" : "false", "leave")
      },
      NullValue: {
        leave: /* @__PURE__ */ __name(() => "null", "leave")
      },
      EnumValue: {
        leave: /* @__PURE__ */ __name(({ value }) => value, "leave")
      },
      ListValue: {
        leave: /* @__PURE__ */ __name(({ values }) => "[" + join2(values, ", ") + "]", "leave")
      },
      ObjectValue: {
        leave: /* @__PURE__ */ __name(({ fields }) => "{" + join2(fields, ", ") + "}", "leave")
      },
      ObjectField: {
        leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave")
      },
      // Directive
      Directive: {
        leave: /* @__PURE__ */ __name(({ name, arguments: args }) => "@" + name + wrap2("(", join2(args, ", "), ")"), "leave")
      },
      // Type
      NamedType: {
        leave: /* @__PURE__ */ __name(({ name }) => name, "leave")
      },
      ListType: {
        leave: /* @__PURE__ */ __name(({ type: type2 }) => "[" + type2 + "]", "leave")
      },
      NonNullType: {
        leave: /* @__PURE__ */ __name(({ type: type2 }) => type2 + "!", "leave")
      },
      // Type System Definitions
      SchemaDefinition: {
        leave: /* @__PURE__ */ __name(({ description, directives, operationTypes }) => wrap2("", description, "\n") + join2(["schema", join2(directives, " "), block2(operationTypes)], " "), "leave")
      },
      OperationTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ operation, type: type2 }) => operation + ": " + type2, "leave")
      },
      ScalarTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives }) => wrap2("", description, "\n") + join2(["scalar", name, join2(directives, " ")], " "), "leave")
      },
      ObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join2(
          [
            "type",
            name,
            wrap2("implements ", join2(interfaces, " & ")),
            join2(directives, " "),
            block2(fields)
          ],
          " "
        ), "leave")
      },
      FieldDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, arguments: args, type: type2, directives }) => wrap2("", description, "\n") + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type2 + wrap2(" ", join2(directives, " ")), "leave")
      },
      InputValueDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, type: type2, defaultValue, directives }) => wrap2("", description, "\n") + join2(
          [name + ": " + type2, wrap2("= ", defaultValue), join2(directives, " ")],
          " "
        ), "leave")
      },
      InterfaceTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, interfaces, directives, fields }) => wrap2("", description, "\n") + join2(
          [
            "interface",
            name,
            wrap2("implements ", join2(interfaces, " & ")),
            join2(directives, " "),
            block2(fields)
          ],
          " "
        ), "leave")
      },
      UnionTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives, types: types3 }) => wrap2("", description, "\n") + join2(
          ["union", name, join2(directives, " "), wrap2("= ", join2(types3, " | "))],
          " "
        ), "leave")
      },
      EnumTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives, values }) => wrap2("", description, "\n") + join2(["enum", name, join2(directives, " "), block2(values)], " "), "leave")
      },
      EnumValueDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives }) => wrap2("", description, "\n") + join2([name, join2(directives, " ")], " "), "leave")
      },
      InputObjectTypeDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, directives, fields }) => wrap2("", description, "\n") + join2(["input", name, join2(directives, " "), block2(fields)], " "), "leave")
      },
      DirectiveDefinition: {
        leave: /* @__PURE__ */ __name(({ description, name, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | "), "leave")
      },
      SchemaExtension: {
        leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join2(
          ["extend schema", join2(directives, " "), block2(operationTypes)],
          " "
        ), "leave")
      },
      ScalarTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives }) => join2(["extend scalar", name, join2(directives, " ")], " "), "leave")
      },
      ObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join2(
          [
            "extend type",
            name,
            wrap2("implements ", join2(interfaces, " & ")),
            join2(directives, " "),
            block2(fields)
          ],
          " "
        ), "leave")
      },
      InterfaceTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join2(
          [
            "extend interface",
            name,
            wrap2("implements ", join2(interfaces, " & ")),
            join2(directives, " "),
            block2(fields)
          ],
          " "
        ), "leave")
      },
      UnionTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join2(
          [
            "extend union",
            name,
            join2(directives, " "),
            wrap2("= ", join2(types3, " | "))
          ],
          " "
        ), "leave")
      },
      EnumTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, values }) => join2(["extend enum", name, join2(directives, " "), block2(values)], " "), "leave")
      },
      InputObjectTypeExtension: {
        leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join2(["extend input", name, join2(directives, " "), block2(fields)], " "), "leave")
      }
    };
    function join2(maybeArray, separator = "") {
      var _maybeArray$filter$jo;
      return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
    }
    __name(join2, "join");
    function block2(array) {
      return wrap2("{\n", indent2(join2(array, "\n")), "\n}");
    }
    __name(block2, "block");
    function wrap2(start, maybeString, end = "") {
      return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
    }
    __name(wrap2, "wrap");
    function indent2(str) {
      return wrap2("  ", str.replace(/\n/g, "\n  "));
    }
    __name(indent2, "indent");
    function hasMultilineItems2(maybeArray) {
      var _maybeArray$some;
      return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
    }
    __name(hasMultilineItems2, "hasMultilineItems");
  }
});

// ../node_modules/graphql/utilities/valueFromASTUntyped.js
var require_valueFromASTUntyped = __commonJS({
  "../node_modules/graphql/utilities/valueFromASTUntyped.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromASTUntyped = valueFromASTUntyped;
    var _keyValMap = require_keyValMap();
    var _kinds = require_kinds();
    function valueFromASTUntyped(valueNode, variables) {
      switch (valueNode.kind) {
        case _kinds.Kind.NULL:
          return null;
        case _kinds.Kind.INT:
          return parseInt(valueNode.value, 10);
        case _kinds.Kind.FLOAT:
          return parseFloat(valueNode.value);
        case _kinds.Kind.STRING:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.BOOLEAN:
          return valueNode.value;
        case _kinds.Kind.LIST:
          return valueNode.values.map(
            (node) => valueFromASTUntyped(node, variables)
          );
        case _kinds.Kind.OBJECT:
          return (0, _keyValMap.keyValMap)(
            valueNode.fields,
            (field) => field.name.value,
            (field) => valueFromASTUntyped(field.value, variables)
          );
        case _kinds.Kind.VARIABLE:
          return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
      }
    }
    __name(valueFromASTUntyped, "valueFromASTUntyped");
  }
});

// ../node_modules/graphql/type/assertName.js
var require_assertName = __commonJS({
  "../node_modules/graphql/type/assertName.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertEnumValueName = assertEnumValueName;
    exports2.assertName = assertName;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _characterClasses = require_characterClasses();
    function assertName(name) {
      name != null || (0, _devAssert.devAssert)(false, "Must provide name.");
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.length === 0) {
        throw new _GraphQLError.GraphQLError(
          "Expected name to be a non-empty string."
        );
      }
      for (let i = 1; i < name.length; ++i) {
        if (!(0, _characterClasses.isNameContinue)(name.charCodeAt(i))) {
          throw new _GraphQLError.GraphQLError(
            `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
          );
        }
      }
      if (!(0, _characterClasses.isNameStart)(name.charCodeAt(0))) {
        throw new _GraphQLError.GraphQLError(
          `Names must start with [_a-zA-Z] but "${name}" does not.`
        );
      }
      return name;
    }
    __name(assertName, "assertName");
    function assertEnumValueName(name) {
      if (name === "true" || name === "false" || name === "null") {
        throw new _GraphQLError.GraphQLError(
          `Enum values cannot be named: ${name}`
        );
      }
      return assertName(name);
    }
    __name(assertEnumValueName, "assertEnumValueName");
  }
});

// ../node_modules/graphql/type/definition.js
var require_definition = __commonJS({
  "../node_modules/graphql/type/definition.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLUnionType = exports2.GraphQLScalarType = exports2.GraphQLObjectType = exports2.GraphQLNonNull = exports2.GraphQLList = exports2.GraphQLInterfaceType = exports2.GraphQLInputObjectType = exports2.GraphQLEnumType = void 0;
    exports2.argsToArgsConfig = argsToArgsConfig;
    exports2.assertAbstractType = assertAbstractType;
    exports2.assertCompositeType = assertCompositeType;
    exports2.assertEnumType = assertEnumType;
    exports2.assertInputObjectType = assertInputObjectType;
    exports2.assertInputType = assertInputType;
    exports2.assertInterfaceType = assertInterfaceType;
    exports2.assertLeafType = assertLeafType;
    exports2.assertListType = assertListType;
    exports2.assertNamedType = assertNamedType;
    exports2.assertNonNullType = assertNonNullType;
    exports2.assertNullableType = assertNullableType;
    exports2.assertObjectType = assertObjectType;
    exports2.assertOutputType = assertOutputType;
    exports2.assertScalarType = assertScalarType;
    exports2.assertType = assertType;
    exports2.assertUnionType = assertUnionType;
    exports2.assertWrappingType = assertWrappingType;
    exports2.defineArguments = defineArguments;
    exports2.getNamedType = getNamedType6;
    exports2.getNullableType = getNullableType2;
    exports2.isAbstractType = isAbstractType;
    exports2.isCompositeType = isCompositeType2;
    exports2.isEnumType = isEnumType5;
    exports2.isInputObjectType = isInputObjectType7;
    exports2.isInputType = isInputType;
    exports2.isInterfaceType = isInterfaceType7;
    exports2.isLeafType = isLeafType4;
    exports2.isListType = isListType6;
    exports2.isNamedType = isNamedType4;
    exports2.isNonNullType = isNonNullType6;
    exports2.isNullableType = isNullableType;
    exports2.isObjectType = isObjectType11;
    exports2.isOutputType = isOutputType;
    exports2.isRequiredArgument = isRequiredArgument;
    exports2.isRequiredInputField = isRequiredInputField;
    exports2.isScalarType = isScalarType7;
    exports2.isType = isType;
    exports2.isUnionType = isUnionType6;
    exports2.isWrappingType = isWrappingType;
    exports2.resolveObjMapThunk = resolveObjMapThunk;
    exports2.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
    var _devAssert = require_devAssert();
    var _didYouMean = require_didYouMean();
    var _identityFunc = require_identityFunc();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _keyMap = require_keyMap();
    var _keyValMap = require_keyValMap();
    var _mapValue = require_mapValue();
    var _suggestionList = require_suggestionList();
    var _toObjMap = require_toObjMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _assertName = require_assertName();
    function isType(type2) {
      return isScalarType7(type2) || isObjectType11(type2) || isInterfaceType7(type2) || isUnionType6(type2) || isEnumType5(type2) || isInputObjectType7(type2) || isListType6(type2) || isNonNullType6(type2);
    }
    __name(isType, "isType");
    function assertType(type2) {
      if (!isType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL type.`
        );
      }
      return type2;
    }
    __name(assertType, "assertType");
    function isScalarType7(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLScalarType4);
    }
    __name(isScalarType7, "isScalarType");
    function assertScalarType(type2) {
      if (!isScalarType7(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Scalar type.`
        );
      }
      return type2;
    }
    __name(assertScalarType, "assertScalarType");
    function isObjectType11(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLObjectType6);
    }
    __name(isObjectType11, "isObjectType");
    function assertObjectType(type2) {
      if (!isObjectType11(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Object type.`
        );
      }
      return type2;
    }
    __name(assertObjectType, "assertObjectType");
    function isInterfaceType7(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLInterfaceType5);
    }
    __name(isInterfaceType7, "isInterfaceType");
    function assertInterfaceType(type2) {
      if (!isInterfaceType7(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Interface type.`
        );
      }
      return type2;
    }
    __name(assertInterfaceType, "assertInterfaceType");
    function isUnionType6(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLUnionType3);
    }
    __name(isUnionType6, "isUnionType");
    function assertUnionType(type2) {
      if (!isUnionType6(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Union type.`
        );
      }
      return type2;
    }
    __name(assertUnionType, "assertUnionType");
    function isEnumType5(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLEnumType4);
    }
    __name(isEnumType5, "isEnumType");
    function assertEnumType(type2) {
      if (!isEnumType5(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Enum type.`
        );
      }
      return type2;
    }
    __name(assertEnumType, "assertEnumType");
    function isInputObjectType7(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLInputObjectType4);
    }
    __name(isInputObjectType7, "isInputObjectType");
    function assertInputObjectType(type2) {
      if (!isInputObjectType7(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(
            type2
          )} to be a GraphQL Input Object type.`
        );
      }
      return type2;
    }
    __name(assertInputObjectType, "assertInputObjectType");
    function isListType6(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLList5);
    }
    __name(isListType6, "isListType");
    function assertListType(type2) {
      if (!isListType6(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL List type.`
        );
      }
      return type2;
    }
    __name(assertListType, "assertListType");
    function isNonNullType6(type2) {
      return (0, _instanceOf.instanceOf)(type2, GraphQLNonNull5);
    }
    __name(isNonNullType6, "isNonNullType");
    function assertNonNullType(type2) {
      if (!isNonNullType6(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL Non-Null type.`
        );
      }
      return type2;
    }
    __name(assertNonNullType, "assertNonNullType");
    function isInputType(type2) {
      return isScalarType7(type2) || isEnumType5(type2) || isInputObjectType7(type2) || isWrappingType(type2) && isInputType(type2.ofType);
    }
    __name(isInputType, "isInputType");
    function assertInputType(type2) {
      if (!isInputType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL input type.`
        );
      }
      return type2;
    }
    __name(assertInputType, "assertInputType");
    function isOutputType(type2) {
      return isScalarType7(type2) || isObjectType11(type2) || isInterfaceType7(type2) || isUnionType6(type2) || isEnumType5(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
    }
    __name(isOutputType, "isOutputType");
    function assertOutputType(type2) {
      if (!isOutputType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL output type.`
        );
      }
      return type2;
    }
    __name(assertOutputType, "assertOutputType");
    function isLeafType4(type2) {
      return isScalarType7(type2) || isEnumType5(type2);
    }
    __name(isLeafType4, "isLeafType");
    function assertLeafType(type2) {
      if (!isLeafType4(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL leaf type.`
        );
      }
      return type2;
    }
    __name(assertLeafType, "assertLeafType");
    function isCompositeType2(type2) {
      return isObjectType11(type2) || isInterfaceType7(type2) || isUnionType6(type2);
    }
    __name(isCompositeType2, "isCompositeType");
    function assertCompositeType(type2) {
      if (!isCompositeType2(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL composite type.`
        );
      }
      return type2;
    }
    __name(assertCompositeType, "assertCompositeType");
    function isAbstractType(type2) {
      return isInterfaceType7(type2) || isUnionType6(type2);
    }
    __name(isAbstractType, "isAbstractType");
    function assertAbstractType(type2) {
      if (!isAbstractType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL abstract type.`
        );
      }
      return type2;
    }
    __name(assertAbstractType, "assertAbstractType");
    var GraphQLList5 = class {
      static {
        __name(this, "GraphQLList");
      }
      constructor(ofType) {
        isType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLList = GraphQLList5;
    var GraphQLNonNull5 = class {
      static {
        __name(this, "GraphQLNonNull");
      }
      constructor(ofType) {
        isNullableType(ofType) || (0, _devAssert.devAssert)(
          false,
          `Expected ${(0, _inspect.inspect)(
            ofType
          )} to be a GraphQL nullable type.`
        );
        this.ofType = ofType;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLNonNull = GraphQLNonNull5;
    function isWrappingType(type2) {
      return isListType6(type2) || isNonNullType6(type2);
    }
    __name(isWrappingType, "isWrappingType");
    function assertWrappingType(type2) {
      if (!isWrappingType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL wrapping type.`
        );
      }
      return type2;
    }
    __name(assertWrappingType, "assertWrappingType");
    function isNullableType(type2) {
      return isType(type2) && !isNonNullType6(type2);
    }
    __name(isNullableType, "isNullableType");
    function assertNullableType(type2) {
      if (!isNullableType(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL nullable type.`
        );
      }
      return type2;
    }
    __name(assertNullableType, "assertNullableType");
    function getNullableType2(type2) {
      if (type2) {
        return isNonNullType6(type2) ? type2.ofType : type2;
      }
    }
    __name(getNullableType2, "getNullableType");
    function isNamedType4(type2) {
      return isScalarType7(type2) || isObjectType11(type2) || isInterfaceType7(type2) || isUnionType6(type2) || isEnumType5(type2) || isInputObjectType7(type2);
    }
    __name(isNamedType4, "isNamedType");
    function assertNamedType(type2) {
      if (!isNamedType4(type2)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(type2)} to be a GraphQL named type.`
        );
      }
      return type2;
    }
    __name(assertNamedType, "assertNamedType");
    function getNamedType6(type2) {
      if (type2) {
        let unwrappedType = type2;
        while (isWrappingType(unwrappedType)) {
          unwrappedType = unwrappedType.ofType;
        }
        return unwrappedType;
      }
    }
    __name(getNamedType6, "getNamedType");
    function resolveReadonlyArrayThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    __name(resolveReadonlyArrayThunk, "resolveReadonlyArrayThunk");
    function resolveObjMapThunk(thunk) {
      return typeof thunk === "function" ? thunk() : thunk;
    }
    __name(resolveObjMapThunk, "resolveObjMapThunk");
    var GraphQLScalarType4 = class {
      static {
        __name(this, "GraphQLScalarType");
      }
      constructor(config2) {
        var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
        const parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.specifiedByURL = config2.specifiedByURL;
        this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
        this.parseValue = parseValue2;
        this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(
          (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables)
        );
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config2.specifiedByURL)}.`
        );
        config2.serialize == null || typeof config2.serialize === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
        );
        if (config2.parseLiteral) {
          typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
          );
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLScalarType = GraphQLScalarType4;
    var GraphQLObjectType6 = class {
      static {
        __name(this, "GraphQLObjectType");
      }
      constructor(config2) {
        var _config$extensionASTN2;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.isTypeOf = config2.isTypeOf;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
        this._fields = () => defineFieldMap(config2);
        this._interfaces = () => defineInterfaces(config2);
        config2.isTypeOf == null || typeof config2.isTypeOf === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config2.isTypeOf)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLObjectType = GraphQLObjectType6;
    function defineInterfaces(config2) {
      var _config$interfaces;
      const interfaces = resolveReadonlyArrayThunk(
        (_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
      );
      Array.isArray(interfaces) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} interfaces must be an Array or a function which returns an Array.`
      );
      return interfaces;
    }
    __name(defineInterfaces, "defineInterfaces");
    function defineFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        var _fieldConfig$args;
        isPlainObj(fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field config must be an object.`
        );
        fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`
        );
        const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
        isPlainObj(argsConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} args must be an object with argument names as keys.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          args: defineArguments(argsConfig),
          resolve: fieldConfig.resolve,
          subscribe: fieldConfig.subscribe,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    __name(defineFieldMap, "defineFieldMap");
    function defineArguments(config2) {
      return Object.entries(config2).map(([argName, argConfig]) => ({
        name: (0, _assertName.assertName)(argName),
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
        astNode: argConfig.astNode
      }));
    }
    __name(defineArguments, "defineArguments");
    function isPlainObj(obj) {
      return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
    }
    __name(isPlainObj, "isPlainObj");
    function fieldsToFieldsConfig(fields) {
      return (0, _mapValue.mapValue)(fields, (field) => ({
        description: field.description,
        type: field.type,
        args: argsToArgsConfig(field.args),
        resolve: field.resolve,
        subscribe: field.subscribe,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      }));
    }
    __name(fieldsToFieldsConfig, "fieldsToFieldsConfig");
    function argsToArgsConfig(args) {
      return (0, _keyValMap.keyValMap)(
        args,
        (arg) => arg.name,
        (arg) => ({
          description: arg.description,
          type: arg.type,
          defaultValue: arg.defaultValue,
          deprecationReason: arg.deprecationReason,
          extensions: arg.extensions,
          astNode: arg.astNode
        })
      );
    }
    __name(argsToArgsConfig, "argsToArgsConfig");
    function isRequiredArgument(arg) {
      return isNonNullType6(arg.type) && arg.defaultValue === void 0;
    }
    __name(isRequiredArgument, "isRequiredArgument");
    var GraphQLInterfaceType5 = class {
      static {
        __name(this, "GraphQLInterfaceType");
      }
      constructor(config2) {
        var _config$extensionASTN3;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
        this._fields = defineFieldMap.bind(void 0, config2);
        this._interfaces = defineInterfaces.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInterfaceType = GraphQLInterfaceType5;
    var GraphQLUnionType3 = class {
      static {
        __name(this, "GraphQLUnionType");
      }
      constructor(config2) {
        var _config$extensionASTN4;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.resolveType = config2.resolveType;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
        this._types = defineTypes.bind(void 0, config2);
        config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
          false,
          `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
        );
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLUnionType = GraphQLUnionType3;
    function defineTypes(config2) {
      const types3 = resolveReadonlyArrayThunk(config2.types);
      Array.isArray(types3) || (0, _devAssert.devAssert)(
        false,
        `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`
      );
      return types3;
    }
    __name(defineTypes, "defineTypes");
    var GraphQLEnumType4 = class {
      static {
        __name(this, "GraphQLEnumType");
      }
      /* <T> */
      constructor(config2) {
        var _config$extensionASTN5;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
        this._values = typeof config2.values === "function" ? config2.values : defineEnumValues(this.name, config2.values);
        this._valueLookup = null;
        this._nameLookup = null;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        if (typeof this._values === "function") {
          this._values = defineEnumValues(this.name, this._values());
        }
        return this._values;
      }
      getValue(name) {
        if (this._nameLookup === null) {
          this._nameLookup = (0, _keyMap.keyMap)(
            this.getValues(),
            (value) => value.name
          );
        }
        return this._nameLookup[name];
      }
      serialize(outputValue) {
        if (this._valueLookup === null) {
          this._valueLookup = new Map(
            this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
          );
        }
        const enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(
              outputValue
            )}`
          );
        }
        return enumValue.name;
      }
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          const valueStr = (0, _inspect.inspect)(inputValue);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
          );
        }
        const enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new _GraphQLError.GraphQLError(
            `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
          );
        }
        return enumValue.value;
      }
      parseLiteral(valueNode, _variables) {
        if (valueNode.kind !== _kinds.Kind.ENUM) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        const enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          const valueStr = (0, _printer.print)(valueNode);
          throw new _GraphQLError.GraphQLError(
            `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
            {
              nodes: valueNode
            }
          );
        }
        return enumValue.value;
      }
      toConfig() {
        const values = (0, _keyValMap.keyValMap)(
          this.getValues(),
          (value) => value.name,
          (value) => ({
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          })
        );
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLEnumType = GraphQLEnumType4;
    function didYouMeanEnumValue(enumType, unknownValueStr) {
      const allNames = enumType.getValues().map((value) => value.name);
      const suggestedValues = (0, _suggestionList.suggestionList)(
        unknownValueStr,
        allNames
      );
      return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
    }
    __name(didYouMeanEnumValue, "didYouMeanEnumValue");
    function defineEnumValues(typeName, valueMap) {
      isPlainObj(valueMap) || (0, _devAssert.devAssert)(
        false,
        `${typeName} values must be an object with value names as keys.`
      );
      return Object.entries(valueMap).map(([valueName, valueConfig]) => {
        isPlainObj(valueConfig) || (0, _devAssert.devAssert)(
          false,
          `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(
            valueConfig
          )}.`
        );
        return {
          name: (0, _assertName.assertEnumValueName)(valueName),
          description: valueConfig.description,
          value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
          deprecationReason: valueConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
          astNode: valueConfig.astNode
        };
      });
    }
    __name(defineEnumValues, "defineEnumValues");
    var GraphQLInputObjectType4 = class {
      static {
        __name(this, "GraphQLInputObjectType");
      }
      constructor(config2) {
        var _config$extensionASTN6, _config$isOneOf;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
        this.isOneOf = (_config$isOneOf = config2.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
        this._fields = defineInputFieldMap.bind(void 0, config2);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
          description: field.description,
          type: field.type,
          defaultValue: field.defaultValue,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
        return {
          name: this.name,
          description: this.description,
          fields,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          isOneOf: this.isOneOf
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLInputObjectType = GraphQLInputObjectType4;
    function defineInputFieldMap(config2) {
      const fieldMap = resolveObjMapThunk(config2.fields);
      isPlainObj(fieldMap) || (0, _devAssert.devAssert)(
        false,
        `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
      );
      return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
        !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(
          false,
          `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
        );
        return {
          name: (0, _assertName.assertName)(fieldName),
          description: fieldConfig.description,
          type: fieldConfig.type,
          defaultValue: fieldConfig.defaultValue,
          deprecationReason: fieldConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
          astNode: fieldConfig.astNode
        };
      });
    }
    __name(defineInputFieldMap, "defineInputFieldMap");
    function isRequiredInputField(field) {
      return isNonNullType6(field.type) && field.defaultValue === void 0;
    }
    __name(isRequiredInputField, "isRequiredInputField");
  }
});

// ../node_modules/graphql/utilities/typeComparators.js
var require_typeComparators = __commonJS({
  "../node_modules/graphql/utilities/typeComparators.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.doTypesOverlap = doTypesOverlap;
    exports2.isEqualType = isEqualType;
    exports2.isTypeSubTypeOf = isTypeSubTypeOf;
    var _definition = require_definition();
    function isEqualType(typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
        return isEqualType(typeA.ofType, typeB.ofType);
      }
      return false;
    }
    __name(isEqualType, "isEqualType");
    function isTypeSubTypeOf(schema, maybeSubType, superType) {
      if (maybeSubType === superType) {
        return true;
      }
      if ((0, _definition.isNonNullType)(superType)) {
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isNonNullType)(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
      }
      if ((0, _definition.isListType)(superType)) {
        if ((0, _definition.isListType)(maybeSubType)) {
          return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
        }
        return false;
      }
      if ((0, _definition.isListType)(maybeSubType)) {
        return false;
      }
      return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
    }
    __name(isTypeSubTypeOf, "isTypeSubTypeOf");
    function doTypesOverlap(schema, typeA, typeB) {
      if (typeA === typeB) {
        return true;
      }
      if ((0, _definition.isAbstractType)(typeA)) {
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
        }
        return schema.isSubType(typeA, typeB);
      }
      if ((0, _definition.isAbstractType)(typeB)) {
        return schema.isSubType(typeB, typeA);
      }
      return false;
    }
    __name(doTypesOverlap, "doTypesOverlap");
  }
});

// ../node_modules/graphql/type/scalars.js
var require_scalars = __commonJS({
  "../node_modules/graphql/type/scalars.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLString = exports2.GraphQLInt = exports2.GraphQLID = exports2.GraphQLFloat = exports2.GraphQLBoolean = exports2.GRAPHQL_MIN_INT = exports2.GRAPHQL_MAX_INT = void 0;
    exports2.isSpecifiedScalarType = isSpecifiedScalarType4;
    exports2.specifiedScalarTypes = void 0;
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var GRAPHQL_MAX_INT = 2147483647;
    exports2.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT;
    var GRAPHQL_MIN_INT = -2147483648;
    exports2.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT;
    var GraphQLInt2 = new _definition.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isInteger(num)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            "Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue)
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${inputValue}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non-integer value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        const num = parseInt(valueNode.value, 10);
        if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
          throw new _GraphQLError.GraphQLError(
            `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
            {
              nodes: valueNode
            }
          );
        }
        return num;
      }
    });
    exports2.GraphQLInt = GraphQLInt2;
    var GraphQLFloat2 = new _definition.GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue ? 1 : 0;
        }
        let num = coercedValue;
        if (typeof coercedValue === "string" && coercedValue !== "") {
          num = Number(coercedValue);
        }
        if (typeof num !== "number" || !Number.isFinite(num)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        }
        return num;
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            `Float cannot represent non numeric value: ${(0, _printer.print)(
              valueNode
            )}`,
            valueNode
          );
        }
        return parseFloat(valueNode.value);
      }
    });
    exports2.GraphQLFloat = GraphQLFloat2;
    var GraphQLString2 = new _definition.GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (typeof coercedValue === "boolean") {
          return coercedValue ? "true" : "false";
        }
        if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
          return coercedValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "string") {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING) {
          throw new _GraphQLError.GraphQLError(
            `String cannot represent a non string value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLString = GraphQLString2;
    var GraphQLBoolean2 = new _definition.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "boolean") {
          return coercedValue;
        }
        if (Number.isFinite(coercedValue)) {
          return coercedValue !== 0;
        }
        throw new _GraphQLError.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
            coercedValue
          )}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue !== "boolean") {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
              inputValue
            )}`
          );
        }
        return inputValue;
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _printer.print)(
              valueNode
            )}`,
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLBoolean = GraphQLBoolean2;
    var GraphQLID2 = new _definition.GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(outputValue) {
        const coercedValue = serializeObject(outputValue);
        if (typeof coercedValue === "string") {
          return coercedValue;
        }
        if (Number.isInteger(coercedValue)) {
          return String(coercedValue);
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
        );
      },
      parseValue(inputValue) {
        if (typeof inputValue === "string") {
          return inputValue;
        }
        if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
          return inputValue.toString();
        }
        throw new _GraphQLError.GraphQLError(
          `ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`
        );
      },
      parseLiteral(valueNode) {
        if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
          throw new _GraphQLError.GraphQLError(
            "ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode),
            {
              nodes: valueNode
            }
          );
        }
        return valueNode.value;
      }
    });
    exports2.GraphQLID = GraphQLID2;
    var specifiedScalarTypes = Object.freeze([
      GraphQLString2,
      GraphQLInt2,
      GraphQLFloat2,
      GraphQLBoolean2,
      GraphQLID2
    ]);
    exports2.specifiedScalarTypes = specifiedScalarTypes;
    function isSpecifiedScalarType4(type2) {
      return specifiedScalarTypes.some(({ name }) => type2.name === name);
    }
    __name(isSpecifiedScalarType4, "isSpecifiedScalarType");
    function serializeObject(outputValue) {
      if ((0, _isObjectLike.isObjectLike)(outputValue)) {
        if (typeof outputValue.valueOf === "function") {
          const valueOfResult = outputValue.valueOf();
          if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
            return valueOfResult;
          }
        }
        if (typeof outputValue.toJSON === "function") {
          return outputValue.toJSON();
        }
      }
      return outputValue;
    }
    __name(serializeObject, "serializeObject");
  }
});

// ../node_modules/graphql/type/directives.js
var require_directives = __commonJS({
  "../node_modules/graphql/type/directives.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSpecifiedByDirective = exports2.GraphQLSkipDirective = exports2.GraphQLOneOfDirective = exports2.GraphQLIncludeDirective = exports2.GraphQLDirective = exports2.GraphQLDeprecatedDirective = exports2.DEFAULT_DEPRECATION_REASON = void 0;
    exports2.assertDirective = assertDirective;
    exports2.isDirective = isDirective;
    exports2.isSpecifiedDirective = isSpecifiedDirective3;
    exports2.specifiedDirectives = void 0;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _directiveLocation = require_directiveLocation();
    var _assertName = require_assertName();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function isDirective(directive) {
      return (0, _instanceOf.instanceOf)(directive, GraphQLDirective2);
    }
    __name(isDirective, "isDirective");
    function assertDirective(directive) {
      if (!isDirective(directive)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`
        );
      }
      return directive;
    }
    __name(assertDirective, "assertDirective");
    var GraphQLDirective2 = class {
      static {
        __name(this, "GraphQLDirective");
      }
      constructor(config2) {
        var _config$isRepeatable, _config$args;
        this.name = (0, _assertName.assertName)(config2.name);
        this.description = config2.description;
        this.locations = config2.locations;
        this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        Array.isArray(config2.locations) || (0, _devAssert.devAssert)(
          false,
          `@${config2.name} locations must be an Array.`
        );
        const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
        (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(
          false,
          `@${config2.name} args must be an object with argument names as keys.`
        );
        this.args = (0, _definition.defineArguments)(args);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, _definition.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    };
    exports2.GraphQLDirective = GraphQLDirective2;
    var GraphQLIncludeDirective = new GraphQLDirective2({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    exports2.GraphQLIncludeDirective = GraphQLIncludeDirective;
    var GraphQLSkipDirective = new GraphQLDirective2({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD,
        _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
        _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
      ],
      args: {
        if: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    exports2.GraphQLSkipDirective = GraphQLSkipDirective;
    var DEFAULT_DEPRECATION_REASON = "No longer supported";
    exports2.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON;
    var GraphQLDeprecatedDirective2 = new GraphQLDirective2({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
        _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
        _directiveLocation.DirectiveLocation.ENUM_VALUE
      ],
      args: {
        reason: {
          type: _scalars.GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    exports2.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective2;
    var GraphQLSpecifiedByDirective = new GraphQLDirective2({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [_directiveLocation.DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          description: "The URL that specifies the behavior of this scalar."
        }
      }
    });
    exports2.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective;
    var GraphQLOneOfDirective = new GraphQLDirective2({
      name: "oneOf",
      description: "Indicates exactly one field must be supplied and this field must not be `null`.",
      locations: [_directiveLocation.DirectiveLocation.INPUT_OBJECT],
      args: {}
    });
    exports2.GraphQLOneOfDirective = GraphQLOneOfDirective;
    var specifiedDirectives = Object.freeze([
      GraphQLIncludeDirective,
      GraphQLSkipDirective,
      GraphQLDeprecatedDirective2,
      GraphQLSpecifiedByDirective,
      GraphQLOneOfDirective
    ]);
    exports2.specifiedDirectives = specifiedDirectives;
    function isSpecifiedDirective3(directive) {
      return specifiedDirectives.some(({ name }) => name === directive.name);
    }
    __name(isSpecifiedDirective3, "isSpecifiedDirective");
  }
});

// ../node_modules/graphql/jsutils/isIterableObject.js
var require_isIterableObject = __commonJS({
  "../node_modules/graphql/jsutils/isIterableObject.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIterableObject = isIterableObject;
    function isIterableObject(maybeIterable) {
      return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
    }
    __name(isIterableObject, "isIterableObject");
  }
});

// ../node_modules/graphql/utilities/astFromValue.js
var require_astFromValue = __commonJS({
  "../node_modules/graphql/utilities/astFromValue.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.astFromValue = astFromValue2;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _scalars = require_scalars();
    function astFromValue2(value, type2) {
      if ((0, _definition.isNonNullType)(type2)) {
        const astValue = astFromValue2(value, type2.ofType);
        if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
          return null;
        }
        return astValue;
      }
      if (value === null) {
        return {
          kind: _kinds.Kind.NULL
        };
      }
      if (value === void 0) {
        return null;
      }
      if ((0, _definition.isListType)(type2)) {
        const itemType = type2.ofType;
        if ((0, _isIterableObject.isIterableObject)(value)) {
          const valuesNodes = [];
          for (const item of value) {
            const itemNode = astFromValue2(item, itemType);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return {
            kind: _kinds.Kind.LIST,
            values: valuesNodes
          };
        }
        return astFromValue2(value, itemType);
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        if (!(0, _isObjectLike.isObjectLike)(value)) {
          return null;
        }
        const fieldNodes = [];
        for (const field of Object.values(type2.getFields())) {
          const fieldValue = astFromValue2(value[field.name], field.type);
          if (fieldValue) {
            fieldNodes.push({
              kind: _kinds.Kind.OBJECT_FIELD,
              name: {
                kind: _kinds.Kind.NAME,
                value: field.name
              },
              value: fieldValue
            });
          }
        }
        return {
          kind: _kinds.Kind.OBJECT,
          fields: fieldNodes
        };
      }
      if ((0, _definition.isLeafType)(type2)) {
        const serialized = type2.serialize(value);
        if (serialized == null) {
          return null;
        }
        if (typeof serialized === "boolean") {
          return {
            kind: _kinds.Kind.BOOLEAN,
            value: serialized
          };
        }
        if (typeof serialized === "number" && Number.isFinite(serialized)) {
          const stringNum = String(serialized);
          return integerStringRegExp2.test(stringNum) ? {
            kind: _kinds.Kind.INT,
            value: stringNum
          } : {
            kind: _kinds.Kind.FLOAT,
            value: stringNum
          };
        }
        if (typeof serialized === "string") {
          if ((0, _definition.isEnumType)(type2)) {
            return {
              kind: _kinds.Kind.ENUM,
              value: serialized
            };
          }
          if (type2 === _scalars.GraphQLID && integerStringRegExp2.test(serialized)) {
            return {
              kind: _kinds.Kind.INT,
              value: serialized
            };
          }
          return {
            kind: _kinds.Kind.STRING,
            value: serialized
          };
        }
        throw new TypeError(
          `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`
        );
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(astFromValue2, "astFromValue");
    var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// ../node_modules/graphql/type/introspection.js
var require_introspection = __commonJS({
  "../node_modules/graphql/type/introspection.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionTypes = exports2.__TypeKind = exports2.__Type = exports2.__Schema = exports2.__InputValue = exports2.__Field = exports2.__EnumValue = exports2.__DirectiveLocation = exports2.__Directive = exports2.TypeNameMetaFieldDef = exports2.TypeMetaFieldDef = exports2.TypeKind = exports2.SchemaMetaFieldDef = void 0;
    exports2.isIntrospectionType = isIntrospectionType2;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _directiveLocation = require_directiveLocation();
    var _printer = require_printer();
    var _astFromValue = require_astFromValue();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var __Schema = new _definition.GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: /* @__PURE__ */ __name(() => ({
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((schema) => schema.description, "resolve")
        },
        types: {
          description: "A list of all types supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type))
          ),
          resolve(schema) {
            return Object.values(schema.getTypeMap());
          }
        },
        queryType: {
          description: "The type that query operations will be rooted at.",
          type: new _definition.GraphQLNonNull(__Type),
          resolve: /* @__PURE__ */ __name((schema) => schema.getQueryType(), "resolve")
        },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: __Type,
          resolve: /* @__PURE__ */ __name((schema) => schema.getMutationType(), "resolve")
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: __Type,
          resolve: /* @__PURE__ */ __name((schema) => schema.getSubscriptionType(), "resolve")
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__Directive)
            )
          ),
          resolve: /* @__PURE__ */ __name((schema) => schema.getDirectives(), "resolve")
        }
      }), "fields")
    });
    exports2.__Schema = __Schema;
    var __Directive = new _definition.GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((directive) => directive.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((directive) => directive.description, "resolve")
        },
        isRepeatable: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((directive) => directive.isRepeatable, "resolve")
        },
        locations: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__DirectiveLocation)
            )
          ),
          resolve: /* @__PURE__ */ __name((directive) => directive.locations, "resolve")
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        }
      }), "fields")
    });
    exports2.__Directive = __Directive;
    var __DirectiveLocation = new _definition.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: _directiveLocation.DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: _directiveLocation.DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: _directiveLocation.DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: _directiveLocation.DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: _directiveLocation.DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: _directiveLocation.DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: _directiveLocation.DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: _directiveLocation.DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: _directiveLocation.DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    exports2.__DirectiveLocation = __DirectiveLocation;
    var __Type = new _definition.GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: /* @__PURE__ */ __name(() => ({
        kind: {
          type: new _definition.GraphQLNonNull(__TypeKind),
          resolve(type2) {
            if ((0, _definition.isScalarType)(type2)) {
              return TypeKind.SCALAR;
            }
            if ((0, _definition.isObjectType)(type2)) {
              return TypeKind.OBJECT;
            }
            if ((0, _definition.isInterfaceType)(type2)) {
              return TypeKind.INTERFACE;
            }
            if ((0, _definition.isUnionType)(type2)) {
              return TypeKind.UNION;
            }
            if ((0, _definition.isEnumType)(type2)) {
              return TypeKind.ENUM;
            }
            if ((0, _definition.isInputObjectType)(type2)) {
              return TypeKind.INPUT_OBJECT;
            }
            if ((0, _definition.isListType)(type2)) {
              return TypeKind.LIST;
            }
            if ((0, _definition.isNonNullType)(type2)) {
              return TypeKind.NON_NULL;
            }
            (0, _invariant.invariant)(
              false,
              `Unexpected type: "${(0, _inspect.inspect)(type2)}".`
            );
          }
        },
        name: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((type2) => "name" in type2 ? type2.name : void 0, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((type2) => (
            /* c8 ignore next */
            "description" in type2 ? type2.description : void 0
          ), "resolve")
        },
        specifiedByURL: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0, "resolve")
        },
        fields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__Field)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type2, { includeDeprecated }) {
            if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
              const fields = Object.values(type2.getFields());
              return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
            }
          }
        },
        interfaces: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type2) {
            if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
              return type2.getInterfaces();
            }
          }
        },
        possibleTypes: {
          type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type)),
          resolve(type2, _args, _context, { schema }) {
            if ((0, _definition.isAbstractType)(type2)) {
              return schema.getPossibleTypes(type2);
            }
          }
        },
        enumValues: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__EnumValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type2, { includeDeprecated }) {
            if ((0, _definition.isEnumType)(type2)) {
              const values = type2.getValues();
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        inputFields: {
          type: new _definition.GraphQLList(
            new _definition.GraphQLNonNull(__InputValue)
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(type2, { includeDeprecated }) {
            if ((0, _definition.isInputObjectType)(type2)) {
              const values = Object.values(type2.getFields());
              return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
            }
          }
        },
        ofType: {
          type: __Type,
          resolve: /* @__PURE__ */ __name((type2) => "ofType" in type2 ? type2.ofType : void 0, "resolve")
        },
        isOneOf: {
          type: _scalars.GraphQLBoolean,
          resolve: /* @__PURE__ */ __name((type2) => {
            if ((0, _definition.isInputObjectType)(type2)) {
              return type2.isOneOf;
            }
          }, "resolve")
        }
      }), "fields")
    });
    exports2.__Type = __Type;
    var __Field = new _definition.GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((field) => field.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((field) => field.description, "resolve")
        },
        args: {
          type: new _definition.GraphQLNonNull(
            new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue)
            )
          ),
          args: {
            includeDeprecated: {
              type: _scalars.GraphQLBoolean,
              defaultValue: false
            }
          },
          resolve(field, { includeDeprecated }) {
            return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
          }
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: /* @__PURE__ */ __name((field) => field.type, "resolve")
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((field) => field.deprecationReason != null, "resolve")
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((field) => field.deprecationReason, "resolve")
        }
      }), "fields")
    });
    exports2.__Field = __Field;
    var __InputValue = new _definition.GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((inputValue) => inputValue.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((inputValue) => inputValue.description, "resolve")
        },
        type: {
          type: new _definition.GraphQLNonNull(__Type),
          resolve: /* @__PURE__ */ __name((inputValue) => inputValue.type, "resolve")
        },
        defaultValue: {
          type: _scalars.GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(inputValue) {
            const { type: type2, defaultValue } = inputValue;
            const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type2);
            return valueAST ? (0, _printer.print)(valueAST) : null;
          }
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((field) => field.deprecationReason != null, "resolve")
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((obj) => obj.deprecationReason, "resolve")
        }
      }), "fields")
    });
    exports2.__InputValue = __InputValue;
    var __EnumValue = new _definition.GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: /* @__PURE__ */ __name(() => ({
        name: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.name, "resolve")
        },
        description: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.description, "resolve")
        },
        isDeprecated: {
          type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.deprecationReason != null, "resolve")
        },
        deprecationReason: {
          type: _scalars.GraphQLString,
          resolve: /* @__PURE__ */ __name((enumValue) => enumValue.deprecationReason, "resolve")
        }
      }), "fields")
    });
    exports2.__EnumValue = __EnumValue;
    var TypeKind;
    exports2.TypeKind = TypeKind;
    (function(TypeKind2) {
      TypeKind2["SCALAR"] = "SCALAR";
      TypeKind2["OBJECT"] = "OBJECT";
      TypeKind2["INTERFACE"] = "INTERFACE";
      TypeKind2["UNION"] = "UNION";
      TypeKind2["ENUM"] = "ENUM";
      TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
      TypeKind2["LIST"] = "LIST";
      TypeKind2["NON_NULL"] = "NON_NULL";
    })(TypeKind || (exports2.TypeKind = TypeKind = {}));
    var __TypeKind = new _definition.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    exports2.__TypeKind = __TypeKind;
    var SchemaMetaFieldDef = {
      name: "__schema",
      type: new _definition.GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: /* @__PURE__ */ __name((_source, _args, _context, { schema }) => schema, "resolve"),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.SchemaMetaFieldDef = SchemaMetaFieldDef;
    var TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: void 0,
          type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
          defaultValue: void 0,
          deprecationReason: void 0,
          extensions: /* @__PURE__ */ Object.create(null),
          astNode: void 0
        }
      ],
      resolve: /* @__PURE__ */ __name((_source, { name }, _context, { schema }) => schema.getType(name), "resolve"),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeMetaFieldDef = TypeMetaFieldDef;
    var TypeNameMetaFieldDef = {
      name: "__typename",
      type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: /* @__PURE__ */ __name((_source, _args, _context, { parentType }) => parentType.name, "resolve"),
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    };
    exports2.TypeNameMetaFieldDef = TypeNameMetaFieldDef;
    var introspectionTypes = Object.freeze([
      __Schema,
      __Directive,
      __DirectiveLocation,
      __Type,
      __Field,
      __InputValue,
      __EnumValue,
      __TypeKind
    ]);
    exports2.introspectionTypes = introspectionTypes;
    function isIntrospectionType2(type2) {
      return introspectionTypes.some(({ name }) => type2.name === name);
    }
    __name(isIntrospectionType2, "isIntrospectionType");
  }
});

// ../node_modules/graphql/type/schema.js
var require_schema = __commonJS({
  "../node_modules/graphql/type/schema.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GraphQLSchema = void 0;
    exports2.assertSchema = assertSchema;
    exports2.isSchema = isSchema3;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _instanceOf = require_instanceOf();
    var _isObjectLike = require_isObjectLike();
    var _toObjMap = require_toObjMap();
    var _ast = require_ast();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    function isSchema3(schema) {
      return (0, _instanceOf.instanceOf)(schema, GraphQLSchema2);
    }
    __name(isSchema3, "isSchema");
    function assertSchema(schema) {
      if (!isSchema3(schema)) {
        throw new Error(
          `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`
        );
      }
      return schema;
    }
    __name(assertSchema, "assertSchema");
    var GraphQLSchema2 = class {
      static {
        __name(this, "GraphQLSchema");
      }
      // Used as a cache for validateSchema().
      constructor(config2) {
        var _config$extensionASTN, _config$directives;
        this.__validationErrors = config2.assumeValid === true ? [] : void 0;
        (0, _isObjectLike.isObjectLike)(config2) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
        !config2.types || Array.isArray(config2.types) || (0, _devAssert.devAssert)(
          false,
          `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
            config2.types
          )}.`
        );
        !config2.directives || Array.isArray(config2.directives) || (0, _devAssert.devAssert)(
          false,
          `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config2.directives)}.`
        );
        this.description = config2.description;
        this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
        this.astNode = config2.astNode;
        this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
        this._queryType = config2.query;
        this._mutationType = config2.mutation;
        this._subscriptionType = config2.subscription;
        this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
        const allReferencedTypes = new Set(config2.types);
        if (config2.types != null) {
          for (const type2 of config2.types) {
            allReferencedTypes.delete(type2);
            collectReferencedTypes(type2, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (const directive of this._directives) {
          if ((0, _directives.isDirective)(directive)) {
            for (const arg of directive.args) {
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(_introspection.__Schema, allReferencedTypes);
        this._typeMap = /* @__PURE__ */ Object.create(null);
        this._subTypeMap = /* @__PURE__ */ Object.create(null);
        this._implementationsMap = /* @__PURE__ */ Object.create(null);
        for (const namedType of allReferencedTypes) {
          if (namedType == null) {
            continue;
          }
          const typeName = namedType.name;
          typeName || (0, _devAssert.devAssert)(
            false,
            "One of the provided types for building the Schema is missing a name."
          );
          if (this._typeMap[typeName] !== void 0) {
            throw new Error(
              `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
            );
          }
          this._typeMap[typeName] = namedType;
          if ((0, _definition.isInterfaceType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if ((0, _definition.isObjectType)(namedType)) {
            for (const iface of namedType.getInterfaces()) {
              if ((0, _definition.isInterfaceType)(iface)) {
                let implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return this.getQueryType();
          case _ast.OperationTypeNode.MUTATION:
            return this.getMutationType();
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(name) {
        return this.getTypeMap()[name];
      }
      getPossibleTypes(abstractType) {
        return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      }
      getImplementations(interfaceType) {
        const implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      }
      isSubType(abstractType, maybeSubType) {
        let map = this._subTypeMap[abstractType.name];
        if (map === void 0) {
          map = /* @__PURE__ */ Object.create(null);
          if ((0, _definition.isUnionType)(abstractType)) {
            for (const type2 of abstractType.getTypes()) {
              map[type2.name] = true;
            }
          } else {
            const implementations = this.getImplementations(abstractType);
            for (const type2 of implementations.objects) {
              map[type2.name] = true;
            }
            for (const type2 of implementations.interfaces) {
              map[type2.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map;
        }
        return map[maybeSubType.name] !== void 0;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(name) {
        return this.getDirectives().find((directive) => directive.name === name);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== void 0
        };
      }
    };
    exports2.GraphQLSchema = GraphQLSchema2;
    function collectReferencedTypes(type2, typeSet) {
      const namedType = (0, _definition.getNamedType)(type2);
      if (!typeSet.has(namedType)) {
        typeSet.add(namedType);
        if ((0, _definition.isUnionType)(namedType)) {
          for (const memberType of namedType.getTypes()) {
            collectReferencedTypes(memberType, typeSet);
          }
        } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
          for (const interfaceType of namedType.getInterfaces()) {
            collectReferencedTypes(interfaceType, typeSet);
          }
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
            for (const arg of field.args) {
              collectReferencedTypes(arg.type, typeSet);
            }
          }
        } else if ((0, _definition.isInputObjectType)(namedType)) {
          for (const field of Object.values(namedType.getFields())) {
            collectReferencedTypes(field.type, typeSet);
          }
        }
      }
      return typeSet;
    }
    __name(collectReferencedTypes, "collectReferencedTypes");
  }
});

// ../node_modules/graphql/type/validate.js
var require_validate = __commonJS({
  "../node_modules/graphql/type/validate.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSchema = assertValidSchema2;
    exports2.validateSchema = validateSchema2;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _typeComparators = require_typeComparators();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function validateSchema2(schema) {
      (0, _schema.assertSchema)(schema);
      if (schema.__validationErrors) {
        return schema.__validationErrors;
      }
      const context2 = new SchemaValidationContext(schema);
      validateRootTypes(context2);
      validateDirectives(context2);
      validateTypes(context2);
      const errors = context2.getErrors();
      schema.__validationErrors = errors;
      return errors;
    }
    __name(validateSchema2, "validateSchema");
    function assertValidSchema2(schema) {
      const errors = validateSchema2(schema);
      if (errors.length !== 0) {
        throw new Error(errors.map((error3) => error3.message).join("\n\n"));
      }
    }
    __name(assertValidSchema2, "assertValidSchema");
    var SchemaValidationContext = class {
      static {
        __name(this, "SchemaValidationContext");
      }
      constructor(schema) {
        this._errors = [];
        this.schema = schema;
      }
      reportError(message, nodes) {
        const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this._errors.push(
          new _GraphQLError.GraphQLError(message, {
            nodes: _nodes
          })
        );
      }
      getErrors() {
        return this._errors;
      }
    };
    function validateRootTypes(context2) {
      const schema = context2.schema;
      const queryType = schema.getQueryType();
      if (!queryType) {
        context2.reportError("Query root type must be provided.", schema.astNode);
      } else if (!(0, _definition.isObjectType)(queryType)) {
        var _getOperationTypeNode;
        context2.reportError(
          `Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`,
          (_getOperationTypeNode = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.QUERY
          )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
        );
      }
      const mutationType = schema.getMutationType();
      if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
        var _getOperationTypeNode2;
        context2.reportError(
          `Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`,
          (_getOperationTypeNode2 = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.MUTATION
          )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
        );
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
        var _getOperationTypeNode3;
        context2.reportError(
          `Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`,
          (_getOperationTypeNode3 = getOperationTypeNode(
            schema,
            _ast.OperationTypeNode.SUBSCRIPTION
          )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
        );
      }
    }
    __name(validateRootTypes, "validateRootTypes");
    function getOperationTypeNode(schema, operation) {
      var _flatMap$find;
      return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (schemaNode) => {
          var _schemaNode$operation;
          return (
            /* c8 ignore next */
            (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
          );
        }
      ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
    }
    __name(getOperationTypeNode, "getOperationTypeNode");
    function validateDirectives(context2) {
      for (const directive of context2.schema.getDirectives()) {
        if (!(0, _directives.isDirective)(directive)) {
          context2.reportError(
            `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,
            directive === null || directive === void 0 ? void 0 : directive.astNode
          );
          continue;
        }
        validateName(context2, directive);
        if (directive.locations.length === 0) {
          context2.reportError(
            `Directive @${directive.name} must include 1 or more locations.`,
            directive.astNode
          );
        }
        for (const arg of directive.args) {
          validateName(context2, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            context2.reportError(
              `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              arg.astNode
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode;
            context2.reportError(
              `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
              ]
            );
          }
        }
      }
    }
    __name(validateDirectives, "validateDirectives");
    function validateName(context2, node) {
      if (node.name.startsWith("__")) {
        context2.reportError(
          `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
          node.astNode
        );
      }
    }
    __name(validateName, "validateName");
    function validateTypes(context2) {
      const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context2);
      const typeMap = context2.schema.getTypeMap();
      for (const type2 of Object.values(typeMap)) {
        if (!(0, _definition.isNamedType)(type2)) {
          context2.reportError(
            `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type2)}.`,
            type2.astNode
          );
          continue;
        }
        if (!(0, _introspection.isIntrospectionType)(type2)) {
          validateName(context2, type2);
        }
        if ((0, _definition.isObjectType)(type2)) {
          validateFields(context2, type2);
          validateInterfaces(context2, type2);
        } else if ((0, _definition.isInterfaceType)(type2)) {
          validateFields(context2, type2);
          validateInterfaces(context2, type2);
        } else if ((0, _definition.isUnionType)(type2)) {
          validateUnionMembers(context2, type2);
        } else if ((0, _definition.isEnumType)(type2)) {
          validateEnumValues(context2, type2);
        } else if ((0, _definition.isInputObjectType)(type2)) {
          validateInputFields(context2, type2);
          validateInputObjectCircularRefs(type2);
        }
      }
    }
    __name(validateTypes, "validateTypes");
    function validateFields(context2, type2) {
      const fields = Object.values(type2.getFields());
      if (fields.length === 0) {
        context2.reportError(`Type ${type2.name} must define one or more fields.`, [
          type2.astNode,
          ...type2.extensionASTNodes
        ]);
      }
      for (const field of fields) {
        validateName(context2, field);
        if (!(0, _definition.isOutputType)(field.type)) {
          var _field$astNode;
          context2.reportError(
            `The type of ${type2.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
          );
        }
        for (const arg of field.args) {
          const argName = arg.name;
          validateName(context2, arg);
          if (!(0, _definition.isInputType)(arg.type)) {
            var _arg$astNode2;
            context2.reportError(
              `The type of ${type2.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
              (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
            );
          }
          if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
            var _arg$astNode3;
            context2.reportError(
              `Required argument ${type2.name}.${field.name}(${argName}:) cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode(arg.astNode),
                (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
              ]
            );
          }
        }
      }
    }
    __name(validateFields, "validateFields");
    function validateInterfaces(context2, type2) {
      const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
      for (const iface of type2.getInterfaces()) {
        if (!(0, _definition.isInterfaceType)(iface)) {
          context2.reportError(
            `Type ${(0, _inspect.inspect)(
              type2
            )} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`,
            getAllImplementsInterfaceNodes(type2, iface)
          );
          continue;
        }
        if (type2 === iface) {
          context2.reportError(
            `Type ${type2.name} cannot implement itself because it would create a circular reference.`,
            getAllImplementsInterfaceNodes(type2, iface)
          );
          continue;
        }
        if (ifaceTypeNames[iface.name]) {
          context2.reportError(
            `Type ${type2.name} can only implement ${iface.name} once.`,
            getAllImplementsInterfaceNodes(type2, iface)
          );
          continue;
        }
        ifaceTypeNames[iface.name] = true;
        validateTypeImplementsAncestors(context2, type2, iface);
        validateTypeImplementsInterface(context2, type2, iface);
      }
    }
    __name(validateInterfaces, "validateInterfaces");
    function validateTypeImplementsInterface(context2, type2, iface) {
      const typeFieldMap = type2.getFields();
      for (const ifaceField of Object.values(iface.getFields())) {
        const fieldName = ifaceField.name;
        const typeField = typeFieldMap[fieldName];
        if (!typeField) {
          context2.reportError(
            `Interface field ${iface.name}.${fieldName} expected but ${type2.name} does not provide it.`,
            [ifaceField.astNode, type2.astNode, ...type2.extensionASTNodes]
          );
          continue;
        }
        if (!(0, _typeComparators.isTypeSubTypeOf)(
          context2.schema,
          typeField.type,
          ifaceField.type
        )) {
          var _ifaceField$astNode, _typeField$astNode;
          context2.reportError(
            `Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type2.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`,
            [
              (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
              (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
            ]
          );
        }
        for (const ifaceArg of ifaceField.args) {
          const argName = ifaceArg.name;
          const typeArg = typeField.args.find((arg) => arg.name === argName);
          if (!typeArg) {
            context2.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type2.name}.${fieldName} does not provide it.`,
              [ifaceArg.astNode, typeField.astNode]
            );
            continue;
          }
          if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
            var _ifaceArg$astNode, _typeArg$astNode;
            context2.reportError(
              `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type2.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`,
              [
                (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
              ]
            );
          }
        }
        for (const typeArg of typeField.args) {
          const argName = typeArg.name;
          const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
          if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
            context2.reportError(
              `Object field ${type2.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
              [typeArg.astNode, ifaceField.astNode]
            );
          }
        }
      }
    }
    __name(validateTypeImplementsInterface, "validateTypeImplementsInterface");
    function validateTypeImplementsAncestors(context2, type2, iface) {
      const ifaceInterfaces = type2.getInterfaces();
      for (const transitive of iface.getInterfaces()) {
        if (!ifaceInterfaces.includes(transitive)) {
          context2.reportError(
            transitive === type2 ? `Type ${type2.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type2.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
            [
              ...getAllImplementsInterfaceNodes(iface, transitive),
              ...getAllImplementsInterfaceNodes(type2, iface)
            ]
          );
        }
      }
    }
    __name(validateTypeImplementsAncestors, "validateTypeImplementsAncestors");
    function validateUnionMembers(context2, union) {
      const memberTypes = union.getTypes();
      if (memberTypes.length === 0) {
        context2.reportError(
          `Union type ${union.name} must define one or more member types.`,
          [union.astNode, ...union.extensionASTNodes]
        );
      }
      const includedTypeNames = /* @__PURE__ */ Object.create(null);
      for (const memberType of memberTypes) {
        if (includedTypeNames[memberType.name]) {
          context2.reportError(
            `Union type ${union.name} can only include type ${memberType.name} once.`,
            getUnionMemberTypeNodes(union, memberType.name)
          );
          continue;
        }
        includedTypeNames[memberType.name] = true;
        if (!(0, _definition.isObjectType)(memberType)) {
          context2.reportError(
            `Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`,
            getUnionMemberTypeNodes(union, String(memberType))
          );
        }
      }
    }
    __name(validateUnionMembers, "validateUnionMembers");
    function validateEnumValues(context2, enumType) {
      const enumValues = enumType.getValues();
      if (enumValues.length === 0) {
        context2.reportError(
          `Enum type ${enumType.name} must define one or more values.`,
          [enumType.astNode, ...enumType.extensionASTNodes]
        );
      }
      for (const enumValue of enumValues) {
        validateName(context2, enumValue);
      }
    }
    __name(validateEnumValues, "validateEnumValues");
    function validateInputFields(context2, inputObj) {
      const fields = Object.values(inputObj.getFields());
      if (fields.length === 0) {
        context2.reportError(
          `Input Object type ${inputObj.name} must define one or more fields.`,
          [inputObj.astNode, ...inputObj.extensionASTNodes]
        );
      }
      for (const field of fields) {
        validateName(context2, field);
        if (!(0, _definition.isInputType)(field.type)) {
          var _field$astNode2;
          context2.reportError(
            `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`,
            (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
          );
        }
        if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
          var _field$astNode3;
          context2.reportError(
            `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(field.astNode),
              (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
            ]
          );
        }
        if (inputObj.isOneOf) {
          validateOneOfInputObjectField(inputObj, field, context2);
        }
      }
    }
    __name(validateInputFields, "validateInputFields");
    function validateOneOfInputObjectField(type2, field, context2) {
      if ((0, _definition.isNonNullType)(field.type)) {
        var _field$astNode4;
        context2.reportError(
          `OneOf input field ${type2.name}.${field.name} must be nullable.`,
          (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type
        );
      }
      if (field.defaultValue !== void 0) {
        context2.reportError(
          `OneOf input field ${type2.name}.${field.name} cannot have a default value.`,
          field.astNode
        );
      }
    }
    __name(validateOneOfInputObjectField, "validateOneOfInputObjectField");
    function createInputObjectCircularRefsValidator(context2) {
      const visitedTypes = /* @__PURE__ */ Object.create(null);
      const fieldPath = [];
      const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(inputObj) {
        if (visitedTypes[inputObj.name]) {
          return;
        }
        visitedTypes[inputObj.name] = true;
        fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
        const fields = Object.values(inputObj.getFields());
        for (const field of fields) {
          if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
            const fieldType = field.type.ofType;
            const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
            fieldPath.push(field);
            if (cycleIndex === void 0) {
              detectCycleRecursive(fieldType);
            } else {
              const cyclePath = fieldPath.slice(cycleIndex);
              const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
              context2.reportError(
                `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
                cyclePath.map((fieldObj) => fieldObj.astNode)
              );
            }
            fieldPath.pop();
          }
        }
        fieldPathIndexByTypeName[inputObj.name] = void 0;
      }
      __name(detectCycleRecursive, "detectCycleRecursive");
    }
    __name(createInputObjectCircularRefsValidator, "createInputObjectCircularRefsValidator");
    function getAllImplementsInterfaceNodes(type2, iface) {
      const { astNode, extensionASTNodes } = type2;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((typeNode) => {
        var _typeNode$interfaces;
        return (
          /* c8 ignore next */
          (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
        );
      }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
    }
    __name(getAllImplementsInterfaceNodes, "getAllImplementsInterfaceNodes");
    function getUnionMemberTypeNodes(union, typeName) {
      const { astNode, extensionASTNodes } = union;
      const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
      return nodes.flatMap((unionNode) => {
        var _unionNode$types;
        return (
          /* c8 ignore next */
          (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
        );
      }).filter((typeNode) => typeNode.name.value === typeName);
    }
    __name(getUnionMemberTypeNodes, "getUnionMemberTypeNodes");
    function getDeprecatedDirectiveNode(definitionNode) {
      var _definitionNode$direc;
      return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
        (node) => node.name.value === _directives.GraphQLDeprecatedDirective.name
      );
    }
    __name(getDeprecatedDirectiveNode, "getDeprecatedDirectiveNode");
  }
});

// ../node_modules/graphql/utilities/typeFromAST.js
var require_typeFromAST = __commonJS({
  "../node_modules/graphql/utilities/typeFromAST.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.typeFromAST = typeFromAST;
    var _kinds = require_kinds();
    var _definition = require_definition();
    function typeFromAST(schema, typeNode) {
      switch (typeNode.kind) {
        case _kinds.Kind.LIST_TYPE: {
          const innerType = typeFromAST(schema, typeNode.type);
          return innerType && new _definition.GraphQLList(innerType);
        }
        case _kinds.Kind.NON_NULL_TYPE: {
          const innerType = typeFromAST(schema, typeNode.type);
          return innerType && new _definition.GraphQLNonNull(innerType);
        }
        case _kinds.Kind.NAMED_TYPE:
          return schema.getType(typeNode.name.value);
      }
    }
    __name(typeFromAST, "typeFromAST");
  }
});

// ../node_modules/graphql/utilities/TypeInfo.js
var require_TypeInfo = __commonJS({
  "../node_modules/graphql/utilities/TypeInfo.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TypeInfo = void 0;
    exports2.visitWithTypeInfo = visitWithTypeInfo;
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _typeFromAST = require_typeFromAST();
    var TypeInfo = class {
      static {
        __name(this, "TypeInfo");
      }
      constructor(schema, initialType, getFieldDefFn) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if ((0, _definition.isInputType)(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if ((0, _definition.isCompositeType)(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if ((0, _definition.isOutputType)(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(node) {
        const schema = this._schema;
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET: {
            const namedType = (0, _definition.getNamedType)(this.getType());
            this._parentTypeStack.push(
              (0, _definition.isCompositeType)(namedType) ? namedType : void 0
            );
            break;
          }
          case _kinds.Kind.FIELD: {
            const parentType = this.getParentType();
            let fieldDef;
            let fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(
              (0, _definition.isOutputType)(fieldType) ? fieldType : void 0
            );
            break;
          }
          case _kinds.Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case _kinds.Kind.OPERATION_DEFINITION: {
            const rootType = schema.getRootType(node.operation);
            this._typeStack.push(
              (0, _definition.isObjectType)(rootType) ? rootType : void 0
            );
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION: {
            const typeConditionAST = node.typeCondition;
            const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
            this._typeStack.push(
              (0, _definition.isOutputType)(outputType) ? outputType : void 0
            );
            break;
          }
          case _kinds.Kind.VARIABLE_DEFINITION: {
            const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputType) ? inputType : void 0
            );
            break;
          }
          case _kinds.Kind.ARGUMENT: {
            var _this$getDirective;
            let argDef;
            let argType;
            const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = fieldOrDirective.args.find(
                (arg) => arg.name === node.name.value
              );
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(argType) ? argType : void 0
            );
            break;
          }
          case _kinds.Kind.LIST: {
            const listType = (0, _definition.getNullableType)(this.getInputType());
            const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(
              (0, _definition.isInputType)(itemType) ? itemType : void 0
            );
            break;
          }
          case _kinds.Kind.OBJECT_FIELD: {
            const objectType = (0, _definition.getNamedType)(this.getInputType());
            let inputFieldType;
            let inputField;
            if ((0, _definition.isInputObjectType)(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(
              inputField ? inputField.defaultValue : void 0
            );
            this._inputTypeStack.push(
              (0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0
            );
            break;
          }
          case _kinds.Kind.ENUM: {
            const enumType = (0, _definition.getNamedType)(this.getInputType());
            let enumValue;
            if ((0, _definition.isEnumType)(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
          default:
        }
      }
      leave(node) {
        switch (node.kind) {
          case _kinds.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case _kinds.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case _kinds.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case _kinds.Kind.OPERATION_DEFINITION:
          case _kinds.Kind.INLINE_FRAGMENT:
          case _kinds.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case _kinds.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.LIST:
          case _kinds.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case _kinds.Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    };
    exports2.TypeInfo = TypeInfo;
    function getFieldDef(schema, parentType, fieldNode) {
      const name = fieldNode.name.value;
      if (name === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      }
      if (name === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      }
      if (name === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
        return _introspection.TypeNameMetaFieldDef;
      }
      if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
        return parentType.getFields()[name];
      }
    }
    __name(getFieldDef, "getFieldDef");
    function visitWithTypeInfo(typeInfo, visitor) {
      return {
        enter(...args) {
          const node = args[0];
          typeInfo.enter(node);
          const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
          if (fn) {
            const result = fn.apply(visitor, args);
            if (result !== void 0) {
              typeInfo.leave(node);
              if ((0, _ast.isNode)(result)) {
                typeInfo.enter(result);
              }
            }
            return result;
          }
        },
        leave(...args) {
          const node = args[0];
          const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
          let result;
          if (fn) {
            result = fn.apply(visitor, args);
          }
          typeInfo.leave(node);
          return result;
        }
      };
    }
    __name(visitWithTypeInfo, "visitWithTypeInfo");
  }
});

// ../node_modules/graphql/language/predicates.js
var require_predicates = __commonJS({
  "../node_modules/graphql/language/predicates.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isConstValueNode = isConstValueNode;
    exports2.isDefinitionNode = isDefinitionNode2;
    exports2.isExecutableDefinitionNode = isExecutableDefinitionNode;
    exports2.isSelectionNode = isSelectionNode;
    exports2.isTypeDefinitionNode = isTypeDefinitionNode;
    exports2.isTypeExtensionNode = isTypeExtensionNode;
    exports2.isTypeNode = isTypeNode;
    exports2.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
    exports2.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    exports2.isValueNode = isValueNode;
    var _kinds = require_kinds();
    function isDefinitionNode2(node) {
      return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
    }
    __name(isDefinitionNode2, "isDefinitionNode");
    function isExecutableDefinitionNode(node) {
      return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
    }
    __name(isExecutableDefinitionNode, "isExecutableDefinitionNode");
    function isSelectionNode(node) {
      return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
    }
    __name(isSelectionNode, "isSelectionNode");
    function isValueNode(node) {
      return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
    }
    __name(isValueNode, "isValueNode");
    function isConstValueNode(node) {
      return isValueNode(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
    }
    __name(isConstValueNode, "isConstValueNode");
    function isTypeNode(node) {
      return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
    }
    __name(isTypeNode, "isTypeNode");
    function isTypeSystemDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
    }
    __name(isTypeSystemDefinitionNode, "isTypeSystemDefinitionNode");
    function isTypeDefinitionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
    }
    __name(isTypeDefinitionNode, "isTypeDefinitionNode");
    function isTypeSystemExtensionNode(node) {
      return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
    }
    __name(isTypeSystemExtensionNode, "isTypeSystemExtensionNode");
    function isTypeExtensionNode(node) {
      return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    __name(isTypeExtensionNode, "isTypeExtensionNode");
  }
});

// ../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
var require_ExecutableDefinitionsRule = __commonJS({
  "../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    function ExecutableDefinitionsRule(context2) {
      return {
        Document(node) {
          for (const definition of node.definitions) {
            if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
              const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `The ${defName} definition is not executable.`,
                  {
                    nodes: definition
                  }
                )
              );
            }
          }
          return false;
        }
      };
    }
    __name(ExecutableDefinitionsRule, "ExecutableDefinitionsRule");
  }
});

// ../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
var require_FieldsOnCorrectTypeRule = __commonJS({
  "../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _naturalCompare = require_naturalCompare();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function FieldsOnCorrectTypeRule(context2) {
      return {
        Field(node) {
          const type2 = context2.getParentType();
          if (type2) {
            const fieldDef = context2.getFieldDef();
            if (!fieldDef) {
              const schema = context2.getSchema();
              const fieldName = node.name.value;
              let suggestion = (0, _didYouMean.didYouMean)(
                "to use an inline fragment on",
                getSuggestedTypeNames(schema, type2, fieldName)
              );
              if (suggestion === "") {
                suggestion = (0, _didYouMean.didYouMean)(
                  getSuggestedFieldNames(type2, fieldName)
                );
              }
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(FieldsOnCorrectTypeRule, "FieldsOnCorrectTypeRule");
    function getSuggestedTypeNames(schema, type2, fieldName) {
      if (!(0, _definition.isAbstractType)(type2)) {
        return [];
      }
      const suggestedTypes = /* @__PURE__ */ new Set();
      const usageCount = /* @__PURE__ */ Object.create(null);
      for (const possibleType of schema.getPossibleTypes(type2)) {
        if (!possibleType.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleType);
        usageCount[possibleType.name] = 1;
        for (const possibleInterface of possibleType.getInterfaces()) {
          var _usageCount$possibleI;
          if (!possibleInterface.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleInterface);
          usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
        }
      }
      return [...suggestedTypes].sort((typeA, typeB) => {
        const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
        if (usageCountDiff !== 0) {
          return usageCountDiff;
        }
        if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
          return -1;
        }
        if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
          return 1;
        }
        return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
      }).map((x) => x.name);
    }
    __name(getSuggestedTypeNames, "getSuggestedTypeNames");
    function getSuggestedFieldNames(type2, fieldName) {
      if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2)) {
        const possibleFieldNames = Object.keys(type2.getFields());
        return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
      }
      return [];
    }
    __name(getSuggestedFieldNames, "getSuggestedFieldNames");
  }
});

// ../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
var require_FragmentsOnCompositeTypesRule = __commonJS({
  "../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function FragmentsOnCompositeTypesRule(context2) {
      return {
        InlineFragment(node) {
          const typeCondition = node.typeCondition;
          if (typeCondition) {
            const type2 = (0, _typeFromAST.typeFromAST)(
              context2.getSchema(),
              typeCondition
            );
            if (type2 && !(0, _definition.isCompositeType)(type2)) {
              const typeStr = (0, _printer.print)(typeCondition);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment cannot condition on non composite type "${typeStr}".`,
                  {
                    nodes: typeCondition
                  }
                )
              );
            }
          }
        },
        FragmentDefinition(node) {
          const type2 = (0, _typeFromAST.typeFromAST)(
            context2.getSchema(),
            node.typeCondition
          );
          if (type2 && !(0, _definition.isCompositeType)(type2)) {
            const typeStr = (0, _printer.print)(node.typeCondition);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
                {
                  nodes: node.typeCondition
                }
              )
            );
          }
        }
      };
    }
    __name(FragmentsOnCompositeTypesRule, "FragmentsOnCompositeTypesRule");
  }
});

// ../node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
var require_KnownArgumentNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    exports2.KnownArgumentNamesRule = KnownArgumentNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownArgumentNamesRule(context2) {
      return {
        // eslint-disable-next-line new-cap
        ...KnownArgumentNamesOnDirectivesRule(context2),
        Argument(argNode) {
          const argDef = context2.getArgument();
          const fieldDef = context2.getFieldDef();
          const parentType = context2.getParentType();
          if (!argDef && fieldDef && parentType) {
            const argName = argNode.name.value;
            const knownArgsNames = fieldDef.args.map((arg) => arg.name);
            const suggestions = (0, _suggestionList.suggestionList)(
              argName,
              knownArgsNames
            );
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      };
    }
    __name(KnownArgumentNamesRule, "KnownArgumentNamesRule");
    function KnownArgumentNamesOnDirectivesRule(context2) {
      const directiveArgs = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
        }
      }
      return {
        Directive(directiveNode) {
          const directiveName = directiveNode.name.value;
          const knownArgs = directiveArgs[directiveName];
          if (directiveNode.arguments && knownArgs) {
            for (const argNode of directiveNode.arguments) {
              const argName = argNode.name.value;
              if (!knownArgs.includes(argName)) {
                const suggestions = (0, _suggestionList.suggestionList)(
                  argName,
                  knownArgs
                );
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions),
                    {
                      nodes: argNode
                    }
                  )
                );
              }
            }
          }
          return false;
        }
      };
    }
    __name(KnownArgumentNamesOnDirectivesRule, "KnownArgumentNamesOnDirectivesRule");
  }
});

// ../node_modules/graphql/validation/rules/KnownDirectivesRule.js
var require_KnownDirectivesRule = __commonJS({
  "../node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownDirectivesRule = KnownDirectivesRule;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _ast = require_ast();
    var _directiveLocation = require_directiveLocation();
    var _kinds = require_kinds();
    var _directives = require_directives();
    function KnownDirectivesRule(context2) {
      const locationsMap = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        locationsMap[directive.name] = directive.locations;
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          locationsMap[def.name.value] = def.locations.map((name) => name.value);
        }
      }
      return {
        Directive(node, _key, _parent, _path, ancestors) {
          const name = node.name.value;
          const locations = locationsMap[name];
          if (!locations) {
            context2.reportError(
              new _GraphQLError.GraphQLError(`Unknown directive "@${name}".`, {
                nodes: node
              })
            );
            return;
          }
          const candidateLocation = getDirectiveLocationForASTPath(ancestors);
          if (candidateLocation && !locations.includes(candidateLocation)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${name}" may not be used on ${candidateLocation}.`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(KnownDirectivesRule, "KnownDirectivesRule");
    function getDirectiveLocationForASTPath(ancestors) {
      const appliedTo = ancestors[ancestors.length - 1];
      "kind" in appliedTo || (0, _invariant.invariant)(false);
      switch (appliedTo.kind) {
        case _kinds.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(appliedTo.operation);
        case _kinds.Kind.FIELD:
          return _directiveLocation.DirectiveLocation.FIELD;
        case _kinds.Kind.FRAGMENT_SPREAD:
          return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
        case _kinds.Kind.INLINE_FRAGMENT:
          return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
        case _kinds.Kind.FRAGMENT_DEFINITION:
          return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
        case _kinds.Kind.VARIABLE_DEFINITION:
          return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
        case _kinds.Kind.SCHEMA_DEFINITION:
        case _kinds.Kind.SCHEMA_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCHEMA;
        case _kinds.Kind.SCALAR_TYPE_DEFINITION:
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.SCALAR;
        case _kinds.Kind.OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.OBJECT;
        case _kinds.Kind.FIELD_DEFINITION:
          return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
        case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INTERFACE;
        case _kinds.Kind.UNION_TYPE_DEFINITION:
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.UNION;
        case _kinds.Kind.ENUM_TYPE_DEFINITION:
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.ENUM;
        case _kinds.Kind.ENUM_VALUE_DEFINITION:
          return _directiveLocation.DirectiveLocation.ENUM_VALUE;
        case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
        case _kinds.Kind.INPUT_VALUE_DEFINITION: {
          const parentNode = ancestors[ancestors.length - 3];
          "kind" in parentNode || (0, _invariant.invariant)(false);
          return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
        }
        // Not reachable, all possible types have been considered.
        /* c8 ignore next */
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind)
          );
      }
    }
    __name(getDirectiveLocationForASTPath, "getDirectiveLocationForASTPath");
    function getDirectiveLocationForOperation(operation) {
      switch (operation) {
        case _ast.OperationTypeNode.QUERY:
          return _directiveLocation.DirectiveLocation.QUERY;
        case _ast.OperationTypeNode.MUTATION:
          return _directiveLocation.DirectiveLocation.MUTATION;
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
      }
    }
    __name(getDirectiveLocationForOperation, "getDirectiveLocationForOperation");
  }
});

// ../node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
var require_KnownFragmentNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function KnownFragmentNamesRule(context2) {
      return {
        FragmentSpread(node) {
          const fragmentName = node.name.value;
          const fragment = context2.getFragment(fragmentName);
          if (!fragment) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown fragment "${fragmentName}".`,
                {
                  nodes: node.name
                }
              )
            );
          }
        }
      };
    }
    __name(KnownFragmentNamesRule, "KnownFragmentNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/KnownTypeNamesRule.js
var require_KnownTypeNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.KnownTypeNamesRule = KnownTypeNamesRule;
    var _didYouMean = require_didYouMean();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _predicates = require_predicates();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    function KnownTypeNamesRule(context2) {
      const schema = context2.getSchema();
      const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context2.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = true;
        }
      }
      const typeNames = [
        ...Object.keys(existingTypesMap),
        ...Object.keys(definedTypes)
      ];
      return {
        NamedType(node, _1, parent, _2, ancestors) {
          const typeName = node.name.value;
          if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
            var _ancestors$;
            const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
            const isSDL = definitionNode != null && isSDLNode(definitionNode);
            if (isSDL && standardTypeNames.includes(typeName)) {
              return;
            }
            const suggestedTypes = (0, _suggestionList.suggestionList)(
              typeName,
              isSDL ? standardTypeNames.concat(typeNames) : typeNames
            );
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes),
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(KnownTypeNamesRule, "KnownTypeNamesRule");
    var standardTypeNames = [
      ..._scalars.specifiedScalarTypes,
      ..._introspection.introspectionTypes
    ].map((type2) => type2.name);
    function isSDLNode(value) {
      return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
    }
    __name(isSDLNode, "isSDLNode");
  }
});

// ../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
var require_LoneAnonymousOperationRule = __commonJS({
  "../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    function LoneAnonymousOperationRule(context2) {
      let operationCount = 0;
      return {
        Document(node) {
          operationCount = node.definitions.filter(
            (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION
          ).length;
        },
        OperationDefinition(node) {
          if (!node.name && operationCount > 1) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                "This anonymous operation must be the only defined operation.",
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(LoneAnonymousOperationRule, "LoneAnonymousOperationRule");
  }
});

// ../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
var require_LoneSchemaDefinitionRule = __commonJS({
  "../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var _GraphQLError = require_GraphQLError();
    function LoneSchemaDefinitionRule(context2) {
      var _ref, _ref2, _oldSchema$astNode;
      const oldSchema = context2.getSchema();
      const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
      let schemaDefinitionsCount = 0;
      return {
        SchemaDefinition(node) {
          if (alreadyDefined) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                "Cannot define a new schema within a schema extension.",
                {
                  nodes: node
                }
              )
            );
            return;
          }
          if (schemaDefinitionsCount > 0) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                "Must provide only one schema definition.",
                {
                  nodes: node
                }
              )
            );
          }
          ++schemaDefinitionsCount;
        }
      };
    }
    __name(LoneSchemaDefinitionRule, "LoneSchemaDefinitionRule");
  }
});

// ../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js
var require_MaxIntrospectionDepthRule = __commonJS({
  "../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MaxIntrospectionDepthRule = MaxIntrospectionDepthRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var MAX_LISTS_DEPTH = 3;
    function MaxIntrospectionDepthRule(context2) {
      function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
        if (node.kind === _kinds.Kind.FRAGMENT_SPREAD) {
          const fragmentName = node.name.value;
          if (visitedFragments[fragmentName] === true) {
            return false;
          }
          const fragment = context2.getFragment(fragmentName);
          if (!fragment) {
            return false;
          }
          try {
            visitedFragments[fragmentName] = true;
            return checkDepth(fragment, visitedFragments, depth);
          } finally {
            visitedFragments[fragmentName] = void 0;
          }
        }
        if (node.kind === _kinds.Kind.FIELD && // check all introspection lists
        (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
          depth++;
          if (depth >= MAX_LISTS_DEPTH) {
            return true;
          }
        }
        if ("selectionSet" in node && node.selectionSet) {
          for (const child of node.selectionSet.selections) {
            if (checkDepth(child, visitedFragments, depth)) {
              return true;
            }
          }
        }
        return false;
      }
      __name(checkDepth, "checkDepth");
      return {
        Field(node) {
          if (node.name.value === "__schema" || node.name.value === "__type") {
            if (checkDepth(node)) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  "Maximum introspection depth exceeded",
                  {
                    nodes: [node]
                  }
                )
              );
              return false;
            }
          }
        }
      };
    }
    __name(MaxIntrospectionDepthRule, "MaxIntrospectionDepthRule");
  }
});

// ../node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
var require_NoFragmentCyclesRule = __commonJS({
  "../node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var _GraphQLError = require_GraphQLError();
    function NoFragmentCyclesRule(context2) {
      const visitedFrags = /* @__PURE__ */ Object.create(null);
      const spreadPath = [];
      const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: /* @__PURE__ */ __name(() => false, "OperationDefinition"),
        FragmentDefinition(node) {
          detectCycleRecursive(node);
          return false;
        }
      };
      function detectCycleRecursive(fragment) {
        if (visitedFrags[fragment.name.value]) {
          return;
        }
        const fragmentName = fragment.name.value;
        visitedFrags[fragmentName] = true;
        const spreadNodes = context2.getFragmentSpreads(fragment.selectionSet);
        if (spreadNodes.length === 0) {
          return;
        }
        spreadPathIndexByName[fragmentName] = spreadPath.length;
        for (const spreadNode of spreadNodes) {
          const spreadName = spreadNode.name.value;
          const cycleIndex = spreadPathIndexByName[spreadName];
          spreadPath.push(spreadNode);
          if (cycleIndex === void 0) {
            const spreadFragment = context2.getFragment(spreadName);
            if (spreadFragment) {
              detectCycleRecursive(spreadFragment);
            }
          } else {
            const cyclePath = spreadPath.slice(cycleIndex);
            const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
                {
                  nodes: cyclePath
                }
              )
            );
          }
          spreadPath.pop();
        }
        spreadPathIndexByName[fragmentName] = void 0;
      }
      __name(detectCycleRecursive, "detectCycleRecursive");
    }
    __name(NoFragmentCyclesRule, "NoFragmentCyclesRule");
  }
});

// ../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
var require_NoUndefinedVariablesRule = __commonJS({
  "../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUndefinedVariablesRule(context2) {
      let variableNameDefined = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            variableNameDefined = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context2.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              const varName = node.name.value;
              if (variableNameDefined[varName] !== true) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                    {
                      nodes: [node, operation]
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(node) {
          variableNameDefined[node.variable.name.value] = true;
        }
      };
    }
    __name(NoUndefinedVariablesRule, "NoUndefinedVariablesRule");
  }
});

// ../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
var require_NoUnusedFragmentsRule = __commonJS({
  "../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedFragmentsRule(context2) {
      const operationDefs = [];
      const fragmentDefs = [];
      return {
        OperationDefinition(node) {
          operationDefs.push(node);
          return false;
        },
        FragmentDefinition(node) {
          fragmentDefs.push(node);
          return false;
        },
        Document: {
          leave() {
            const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
            for (const operation of operationDefs) {
              for (const fragment of context2.getRecursivelyReferencedFragments(
                operation
              )) {
                fragmentNameUsed[fragment.name.value] = true;
              }
            }
            for (const fragmentDef of fragmentDefs) {
              const fragName = fragmentDef.name.value;
              if (fragmentNameUsed[fragName] !== true) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Fragment "${fragName}" is never used.`,
                    {
                      nodes: fragmentDef
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
    __name(NoUnusedFragmentsRule, "NoUnusedFragmentsRule");
  }
});

// ../node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
var require_NoUnusedVariablesRule = __commonJS({
  "../node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var _GraphQLError = require_GraphQLError();
    function NoUnusedVariablesRule(context2) {
      let variableDefs = [];
      return {
        OperationDefinition: {
          enter() {
            variableDefs = [];
          },
          leave(operation) {
            const variableNameUsed = /* @__PURE__ */ Object.create(null);
            const usages = context2.getRecursiveVariableUsages(operation);
            for (const { node } of usages) {
              variableNameUsed[node.name.value] = true;
            }
            for (const variableDef of variableDefs) {
              const variableName = variableDef.variable.name.value;
              if (variableNameUsed[variableName] !== true) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                    {
                      nodes: variableDef
                    }
                  )
                );
              }
            }
          }
        },
        VariableDefinition(def) {
          variableDefs.push(def);
        }
      };
    }
    __name(NoUnusedVariablesRule, "NoUnusedVariablesRule");
  }
});

// ../node_modules/graphql/utilities/sortValueNode.js
var require_sortValueNode = __commonJS({
  "../node_modules/graphql/utilities/sortValueNode.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sortValueNode = sortValueNode;
    var _naturalCompare = require_naturalCompare();
    var _kinds = require_kinds();
    function sortValueNode(valueNode) {
      switch (valueNode.kind) {
        case _kinds.Kind.OBJECT:
          return { ...valueNode, fields: sortFields(valueNode.fields) };
        case _kinds.Kind.LIST:
          return { ...valueNode, values: valueNode.values.map(sortValueNode) };
        case _kinds.Kind.INT:
        case _kinds.Kind.FLOAT:
        case _kinds.Kind.STRING:
        case _kinds.Kind.BOOLEAN:
        case _kinds.Kind.NULL:
        case _kinds.Kind.ENUM:
        case _kinds.Kind.VARIABLE:
          return valueNode;
      }
    }
    __name(sortValueNode, "sortValueNode");
    function sortFields(fields) {
      return fields.map((fieldNode) => ({
        ...fieldNode,
        value: sortValueNode(fieldNode.value)
      })).sort(
        (fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value)
      );
    }
    __name(sortFields, "sortFields");
  }
});

// ../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
var require_OverlappingFieldsCanBeMergedRule = __commonJS({
  "../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _sortValueNode = require_sortValueNode();
    var _typeFromAST = require_typeFromAST();
    function reasonMessage(reason) {
      if (Array.isArray(reason)) {
        return reason.map(
          ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
        ).join(" and ");
      }
      return reason;
    }
    __name(reasonMessage, "reasonMessage");
    function OverlappingFieldsCanBeMergedRule(context2) {
      const comparedFieldsAndFragmentPairs = new OrderedPairSet();
      const comparedFragmentPairs = new PairSet();
      const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
      return {
        SelectionSet(selectionSet) {
          const conflicts = findConflictsWithinSelectionSet(
            context2,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            context2.getParentType(),
            selectionSet
          );
          for (const [[responseName, reason], fields1, fields2] of conflicts) {
            const reasonMsg = reasonMessage(reason);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
                {
                  nodes: fields1.concat(fields2)
                }
              )
            );
          }
        }
      };
    }
    __name(OverlappingFieldsCanBeMergedRule, "OverlappingFieldsCanBeMergedRule");
    function findConflictsWithinSelectionSet(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet) {
      const conflicts = [];
      const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        parentType,
        selectionSet
      );
      collectConflictsWithin(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        fieldMap
      );
      if (fragmentNames.length !== 0) {
        for (let i = 0; i < fragmentNames.length; i++) {
          collectConflictsBetweenFieldsAndFragment(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            fieldMap,
            fragmentNames[i]
          );
          for (let j = i + 1; j < fragmentNames.length; j++) {
            collectConflictsBetweenFragments(
              context2,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFieldsAndFragmentPairs,
              comparedFragmentPairs,
              false,
              fragmentNames[i],
              fragmentNames[j]
            );
          }
        }
      }
      return conflicts;
    }
    __name(findConflictsWithinSelectionSet, "findConflictsWithinSelectionSet");
    function collectConflictsBetweenFieldsAndFragment(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
      if (comparedFieldsAndFragmentPairs.has(
        fieldMap,
        fragmentName,
        areMutuallyExclusive
      )) {
        return;
      }
      comparedFieldsAndFragmentPairs.add(
        fieldMap,
        fragmentName,
        areMutuallyExclusive
      );
      const fragment = context2.getFragment(fragmentName);
      if (!fragment) {
        return;
      }
      const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragment
      );
      if (fieldMap === fieldMap2) {
        return;
      }
      collectConflictsBetween(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap,
        fieldMap2
      );
      for (const referencedFragmentName of referencedFragmentNames) {
        collectConflictsBetweenFieldsAndFragment(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap,
          referencedFragmentName
        );
      }
    }
    __name(collectConflictsBetweenFieldsAndFragment, "collectConflictsBetweenFieldsAndFragment");
    function collectConflictsBetweenFragments(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
      if (fragmentName1 === fragmentName2) {
        return;
      }
      if (comparedFragmentPairs.has(
        fragmentName1,
        fragmentName2,
        areMutuallyExclusive
      )) {
        return;
      }
      comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
      const fragment1 = context2.getFragment(fragmentName1);
      const fragment2 = context2.getFragment(fragmentName2);
      if (!fragment1 || !fragment2) {
        return;
      }
      const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragment1
      );
      const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragment2
      );
      collectConflictsBetween(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const referencedFragmentName2 of referencedFragmentNames2) {
        collectConflictsBetweenFragments(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fragmentName1,
          referencedFragmentName2
        );
      }
      for (const referencedFragmentName1 of referencedFragmentNames1) {
        collectConflictsBetweenFragments(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          referencedFragmentName1,
          fragmentName2
        );
      }
    }
    __name(collectConflictsBetweenFragments, "collectConflictsBetweenFragments");
    function findConflictsBetweenSubSelectionSets(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
      const conflicts = [];
      const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        parentType1,
        selectionSet1
      );
      const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        parentType2,
        selectionSet2
      );
      collectConflictsBetween(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fieldMap2
      );
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFieldsAndFragment(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fragmentName2
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        collectConflictsBetweenFieldsAndFragment(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap2,
          fragmentName1
        );
      }
      for (const fragmentName1 of fragmentNames1) {
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFragments(
            context2,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fragmentName1,
            fragmentName2
          );
        }
      }
      return conflicts;
    }
    __name(findConflictsBetweenSubSelectionSets, "findConflictsBetweenSubSelectionSets");
    function collectConflictsWithin(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
      for (const [responseName, fields] of Object.entries(fieldMap)) {
        if (fields.length > 1) {
          for (let i = 0; i < fields.length; i++) {
            for (let j = i + 1; j < fields.length; j++) {
              const conflict = findConflict(
                context2,
                cachedFieldsAndFragmentNames,
                comparedFieldsAndFragmentPairs,
                comparedFragmentPairs,
                false,
                // within one collection is never mutually exclusive
                responseName,
                fields[i],
                fields[j]
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    __name(collectConflictsWithin, "collectConflictsWithin");
    function collectConflictsBetween(context2, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
      for (const [responseName, fields1] of Object.entries(fieldMap1)) {
        const fields2 = fieldMap2[responseName];
        if (fields2) {
          for (const field1 of fields1) {
            for (const field2 of fields2) {
              const conflict = findConflict(
                context2,
                cachedFieldsAndFragmentNames,
                comparedFieldsAndFragmentPairs,
                comparedFragmentPairs,
                parentFieldsAreMutuallyExclusive,
                responseName,
                field1,
                field2
              );
              if (conflict) {
                conflicts.push(conflict);
              }
            }
          }
        }
      }
    }
    __name(collectConflictsBetween, "collectConflictsBetween");
    function findConflict(context2, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
      const [parentType1, node1, def1] = field1;
      const [parentType2, node2, def2] = field2;
      const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
      if (!areMutuallyExclusive) {
        const name1 = node1.name.value;
        const name2 = node2.name.value;
        if (name1 !== name2) {
          return [
            [responseName, `"${name1}" and "${name2}" are different fields`],
            [node1],
            [node2]
          ];
        }
        if (!sameArguments(node1, node2)) {
          return [
            [responseName, "they have differing arguments"],
            [node1],
            [node2]
          ];
        }
      }
      const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
      const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
      if (type1 && type2 && doTypesConflict(type1, type2)) {
        return [
          [
            responseName,
            `they return conflicting types "${(0, _inspect.inspect)(
              type1
            )}" and "${(0, _inspect.inspect)(type2)}"`
          ],
          [node1],
          [node2]
        ];
      }
      const selectionSet1 = node1.selectionSet;
      const selectionSet2 = node2.selectionSet;
      if (selectionSet1 && selectionSet2) {
        const conflicts = findConflictsBetweenSubSelectionSets(
          context2,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          areMutuallyExclusive,
          (0, _definition.getNamedType)(type1),
          selectionSet1,
          (0, _definition.getNamedType)(type2),
          selectionSet2
        );
        return subfieldConflicts(conflicts, responseName, node1, node2);
      }
    }
    __name(findConflict, "findConflict");
    function sameArguments(node1, node2) {
      const args1 = node1.arguments;
      const args2 = node2.arguments;
      if (args1 === void 0 || args1.length === 0) {
        return args2 === void 0 || args2.length === 0;
      }
      if (args2 === void 0 || args2.length === 0) {
        return false;
      }
      if (args1.length !== args2.length) {
        return false;
      }
      const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
      return args1.every((arg1) => {
        const value1 = arg1.value;
        const value2 = values2.get(arg1.name.value);
        if (value2 === void 0) {
          return false;
        }
        return stringifyValue(value1) === stringifyValue(value2);
      });
    }
    __name(sameArguments, "sameArguments");
    function stringifyValue(value) {
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(value));
    }
    __name(stringifyValue, "stringifyValue");
    function doTypesConflict(type1, type2) {
      if ((0, _definition.isListType)(type1)) {
        return (0, _definition.isListType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isListType)(type2)) {
        return true;
      }
      if ((0, _definition.isNonNullType)(type1)) {
        return (0, _definition.isNonNullType)(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        return true;
      }
      if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
        return type1 !== type2;
      }
      return false;
    }
    __name(doTypesConflict, "doTypesConflict");
    function getFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, parentType, selectionSet) {
      const cached = cachedFieldsAndFragmentNames.get(selectionSet);
      if (cached) {
        return cached;
      }
      const nodeAndDefs = /* @__PURE__ */ Object.create(null);
      const fragmentNames = /* @__PURE__ */ Object.create(null);
      _collectFieldsAndFragmentNames(
        context2,
        parentType,
        selectionSet,
        nodeAndDefs,
        fragmentNames
      );
      const result = [nodeAndDefs, Object.keys(fragmentNames)];
      cachedFieldsAndFragmentNames.set(selectionSet, result);
      return result;
    }
    __name(getFieldsAndFragmentNames, "getFieldsAndFragmentNames");
    function getReferencedFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, fragment) {
      const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
      if (cached) {
        return cached;
      }
      const fragmentType = (0, _typeFromAST.typeFromAST)(
        context2.getSchema(),
        fragment.typeCondition
      );
      return getFieldsAndFragmentNames(
        context2,
        cachedFieldsAndFragmentNames,
        fragmentType,
        fragment.selectionSet
      );
    }
    __name(getReferencedFieldsAndFragmentNames, "getReferencedFieldsAndFragmentNames");
    function _collectFieldsAndFragmentNames(context2, parentType, selectionSet, nodeAndDefs, fragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            const fieldName = selection.name.value;
            let fieldDef;
            if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
              fieldDef = parentType.getFields()[fieldName];
            }
            const responseName = selection.alias ? selection.alias.value : fieldName;
            if (!nodeAndDefs[responseName]) {
              nodeAndDefs[responseName] = [];
            }
            nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD:
            fragmentNames[selection.name.value] = true;
            break;
          case _kinds.Kind.INLINE_FRAGMENT: {
            const typeCondition = selection.typeCondition;
            const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context2.getSchema(), typeCondition) : parentType;
            _collectFieldsAndFragmentNames(
              context2,
              inlineFragmentType,
              selection.selectionSet,
              nodeAndDefs,
              fragmentNames
            );
            break;
          }
        }
      }
    }
    __name(_collectFieldsAndFragmentNames, "_collectFieldsAndFragmentNames");
    function subfieldConflicts(conflicts, responseName, node1, node2) {
      if (conflicts.length > 0) {
        return [
          [responseName, conflicts.map(([reason]) => reason)],
          [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
          [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
        ];
      }
    }
    __name(subfieldConflicts, "subfieldConflicts");
    var OrderedPairSet = class {
      static {
        __name(this, "OrderedPairSet");
      }
      constructor() {
        this._data = /* @__PURE__ */ new Map();
      }
      has(a, b, weaklyPresent) {
        var _this$_data$get;
        const result = (_this$_data$get = this._data.get(a)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
        if (result === void 0) {
          return false;
        }
        return weaklyPresent ? true : weaklyPresent === result;
      }
      add(a, b, weaklyPresent) {
        const map = this._data.get(a);
        if (map === void 0) {
          this._data.set(a, /* @__PURE__ */ new Map([[b, weaklyPresent]]));
        } else {
          map.set(b, weaklyPresent);
        }
      }
    };
    var PairSet = class {
      static {
        __name(this, "PairSet");
      }
      constructor() {
        this._orderedPairSet = new OrderedPairSet();
      }
      has(a, b, weaklyPresent) {
        return a < b ? this._orderedPairSet.has(a, b, weaklyPresent) : this._orderedPairSet.has(b, a, weaklyPresent);
      }
      add(a, b, weaklyPresent) {
        if (a < b) {
          this._orderedPairSet.add(a, b, weaklyPresent);
        } else {
          this._orderedPairSet.add(b, a, weaklyPresent);
        }
      }
    };
  }
});

// ../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
var require_PossibleFragmentSpreadsRule = __commonJS({
  "../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function PossibleFragmentSpreadsRule(context2) {
      return {
        InlineFragment(node) {
          const fragType = context2.getType();
          const parentType = context2.getParentType();
          if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(
            context2.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        FragmentSpread(node) {
          const fragName = node.name.value;
          const fragType = getFragmentType(context2, fragName);
          const parentType = context2.getParentType();
          if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(
            context2.getSchema(),
            fragType,
            parentType
          )) {
            const parentTypeStr = (0, _inspect.inspect)(parentType);
            const fragTypeStr = (0, _inspect.inspect)(fragType);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(PossibleFragmentSpreadsRule, "PossibleFragmentSpreadsRule");
    function getFragmentType(context2, name) {
      const frag = context2.getFragment(name);
      if (frag) {
        const type2 = (0, _typeFromAST.typeFromAST)(
          context2.getSchema(),
          frag.typeCondition
        );
        if ((0, _definition.isCompositeType)(type2)) {
          return type2;
        }
      }
    }
    __name(getFragmentType, "getFragmentType");
  }
});

// ../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
var require_PossibleTypeExtensionsRule = __commonJS({
  "../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    function PossibleTypeExtensionsRule(context2) {
      const schema = context2.getSchema();
      const definedTypes = /* @__PURE__ */ Object.create(null);
      for (const def of context2.getDocument().definitions) {
        if ((0, _predicates.isTypeDefinitionNode)(def)) {
          definedTypes[def.name.value] = def;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension
      };
      function checkExtension(node) {
        const typeName = node.name.value;
        const defNode = definedTypes[typeName];
        const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
        let expectedKind;
        if (defNode) {
          expectedKind = defKindToExtKind[defNode.kind];
        } else if (existingType) {
          expectedKind = typeToExtKind(existingType);
        }
        if (expectedKind) {
          if (expectedKind !== node.kind) {
            const kindStr = extensionKindToTypeName(node.kind);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot extend non-${kindStr} type "${typeName}".`,
                {
                  nodes: defNode ? [defNode, node] : node
                }
              )
            );
          }
        } else {
          const allTypeNames = Object.keys({
            ...definedTypes,
            ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
          });
          const suggestedTypes = (0, _suggestionList.suggestionList)(
            typeName,
            allTypeNames
          );
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes),
              {
                nodes: node.name
              }
            )
          );
        }
      }
      __name(checkExtension, "checkExtension");
    }
    __name(PossibleTypeExtensionsRule, "PossibleTypeExtensionsRule");
    var defKindToExtKind = {
      [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
      [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
      [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
      [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
      [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
      [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
    };
    function typeToExtKind(type2) {
      if ((0, _definition.isScalarType)(type2)) {
        return _kinds.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, _definition.isObjectType)(type2)) {
        return _kinds.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, _definition.isUnionType)(type2)) {
        return _kinds.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, _definition.isEnumType)(type2)) {
        return _kinds.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(typeToExtKind, "typeToExtKind");
    function extensionKindToTypeName(kind) {
      switch (kind) {
        case _kinds.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case _kinds.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case _kinds.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case _kinds.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
        // Not reachable. All possible types have been considered
        /* c8 ignore next */
        default:
          (0, _invariant.invariant)(
            false,
            "Unexpected kind: " + (0, _inspect.inspect)(kind)
          );
      }
    }
    __name(extensionKindToTypeName, "extensionKindToTypeName");
  }
});

// ../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
var require_ProvidedRequiredArgumentsRule = __commonJS({
  "../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    exports2.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    function ProvidedRequiredArgumentsRule(context2) {
      return {
        // eslint-disable-next-line new-cap
        ...ProvidedRequiredArgumentsOnDirectivesRule(context2),
        Field: {
          // Validate on leave to allow for deeper errors to appear first.
          leave(fieldNode) {
            var _fieldNode$arguments;
            const fieldDef = context2.getFieldDef();
            if (!fieldDef) {
              return false;
            }
            const providedArgs = new Set(
              // FIXME: https://github.com/graphql/graphql-js/issues/2203
              /* c8 ignore next */
              (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
            );
            for (const argDef of fieldDef.args) {
              if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                const argTypeStr = (0, _inspect.inspect)(argDef.type);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                    {
                      nodes: fieldNode
                    }
                  )
                );
              }
            }
          }
        }
      };
    }
    __name(ProvidedRequiredArgumentsRule, "ProvidedRequiredArgumentsRule");
    function ProvidedRequiredArgumentsOnDirectivesRule(context2) {
      var _schema$getDirectives;
      const requiredArgsMap = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(
          directive.args.filter(_definition.isRequiredArgument),
          (arg) => arg.name
        );
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          var _def$arguments;
          const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
          requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(
            argNodes.filter(isRequiredArgumentNode),
            (arg) => arg.name.value
          );
        }
      }
      return {
        Directive: {
          // Validate on leave to allow for deeper errors to appear first.
          leave(directiveNode) {
            const directiveName = directiveNode.name.value;
            const requiredArgs = requiredArgsMap[directiveName];
            if (requiredArgs) {
              var _directiveNode$argume;
              const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
              const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
              for (const [argName, argDef] of Object.entries(requiredArgs)) {
                if (!argNodeMap.has(argName)) {
                  const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                      {
                        nodes: directiveNode
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
    __name(ProvidedRequiredArgumentsOnDirectivesRule, "ProvidedRequiredArgumentsOnDirectivesRule");
    function isRequiredArgumentNode(arg) {
      return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
    }
    __name(isRequiredArgumentNode, "isRequiredArgumentNode");
  }
});

// ../node_modules/graphql/validation/rules/ScalarLeafsRule.js
var require_ScalarLeafsRule = __commonJS({
  "../node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ScalarLeafsRule = ScalarLeafsRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function ScalarLeafsRule(context2) {
      return {
        Field(node) {
          const type2 = context2.getType();
          const selectionSet = node.selectionSet;
          if (type2) {
            if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type2))) {
              if (selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type2);
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                    {
                      nodes: selectionSet
                    }
                  )
                );
              }
            } else if (!selectionSet) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type2);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                  {
                    nodes: node
                  }
                )
              );
            } else if (selectionSet.selections.length === 0) {
              const fieldName = node.name.value;
              const typeStr = (0, _inspect.inspect)(type2);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(ScalarLeafsRule, "ScalarLeafsRule");
  }
});

// ../node_modules/graphql/jsutils/printPathArray.js
var require_printPathArray = __commonJS({
  "../node_modules/graphql/jsutils/printPathArray.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printPathArray = printPathArray;
    function printPathArray(path) {
      return path.map(
        (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
      ).join("");
    }
    __name(printPathArray, "printPathArray");
  }
});

// ../node_modules/graphql/jsutils/Path.js
var require_Path = __commonJS({
  "../node_modules/graphql/jsutils/Path.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addPath = addPath;
    exports2.pathToArray = pathToArray;
    function addPath(prev, key, typename) {
      return {
        prev,
        key,
        typename
      };
    }
    __name(addPath, "addPath");
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    __name(pathToArray, "pathToArray");
  }
});

// ../node_modules/graphql/utilities/coerceInputValue.js
var require_coerceInputValue = __commonJS({
  "../node_modules/graphql/utilities/coerceInputValue.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.coerceInputValue = coerceInputValue;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _Path = require_Path();
    var _printPathArray = require_printPathArray();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function coerceInputValue(inputValue, type2, onError = defaultOnError) {
      return coerceInputValueImpl(inputValue, type2, onError, void 0);
    }
    __name(coerceInputValue, "coerceInputValue");
    function defaultOnError(path, invalidValue, error3) {
      let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
      if (path.length > 0) {
        errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
      }
      error3.message = errorPrefix + ": " + error3.message;
      throw error3;
    }
    __name(defaultOnError, "defaultOnError");
    function coerceInputValueImpl(inputValue, type2, onError, path) {
      if ((0, _definition.isNonNullType)(type2)) {
        if (inputValue != null) {
          return coerceInputValueImpl(inputValue, type2.ofType, onError, path);
        }
        onError(
          (0, _Path.pathToArray)(path),
          inputValue,
          new _GraphQLError.GraphQLError(
            `Expected non-nullable type "${(0, _inspect.inspect)(
              type2
            )}" not to be null.`
          )
        );
        return;
      }
      if (inputValue == null) {
        return null;
      }
      if ((0, _definition.isListType)(type2)) {
        const itemType = type2.ofType;
        if ((0, _isIterableObject.isIterableObject)(inputValue)) {
          return Array.from(inputValue, (itemValue, index) => {
            const itemPath = (0, _Path.addPath)(path, index, void 0);
            return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
          });
        }
        return [coerceInputValueImpl(inputValue, itemType, onError, path)];
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        if (!(0, _isObjectLike.isObjectLike)(inputValue) || Array.isArray(inputValue)) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(
              `Expected type "${type2.name}" to be an object.`
            )
          );
          return;
        }
        const coercedValue = {};
        const fieldDefs = type2.getFields();
        for (const field of Object.values(fieldDefs)) {
          const fieldValue = inputValue[field.name];
          if (fieldValue === void 0) {
            if (field.defaultValue !== void 0) {
              coercedValue[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              const typeStr = (0, _inspect.inspect)(field.type);
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Field "${field.name}" of required type "${typeStr}" was not provided.`
                )
              );
            }
            continue;
          }
          coercedValue[field.name] = coerceInputValueImpl(
            fieldValue,
            field.type,
            onError,
            (0, _Path.addPath)(path, field.name, type2.name)
          );
        }
        for (const fieldName of Object.keys(inputValue)) {
          if (!fieldDefs[fieldName]) {
            const suggestions = (0, _suggestionList.suggestionList)(
              fieldName,
              Object.keys(type2.getFields())
            );
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Field "${fieldName}" is not defined by type "${type2.name}".` + (0, _didYouMean.didYouMean)(suggestions)
              )
            );
          }
        }
        if (type2.isOneOf) {
          const keys = Object.keys(coercedValue);
          if (keys.length !== 1) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Exactly one key must be specified for OneOf type "${type2.name}".`
              )
            );
          }
          const key = keys[0];
          const value = coercedValue[key];
          if (value === null) {
            onError(
              (0, _Path.pathToArray)(path).concat(key),
              value,
              new _GraphQLError.GraphQLError(`Field "${key}" must be non-null.`)
            );
          }
        }
        return coercedValue;
      }
      if ((0, _definition.isLeafType)(type2)) {
        let parseResult;
        try {
          parseResult = type2.parseValue(inputValue);
        } catch (error3) {
          if (error3 instanceof _GraphQLError.GraphQLError) {
            onError((0, _Path.pathToArray)(path), inputValue, error3);
          } else {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Expected type "${type2.name}". ` + error3.message,
                {
                  originalError: error3
                }
              )
            );
          }
          return;
        }
        if (parseResult === void 0) {
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(`Expected type "${type2.name}".`)
          );
        }
        return parseResult;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(coerceInputValueImpl, "coerceInputValueImpl");
  }
});

// ../node_modules/graphql/utilities/valueFromAST.js
var require_valueFromAST = __commonJS({
  "../node_modules/graphql/utilities/valueFromAST.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.valueFromAST = valueFromAST;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _kinds = require_kinds();
    var _definition = require_definition();
    function valueFromAST(valueNode, type2, variables) {
      if (!valueNode) {
        return;
      }
      if (valueNode.kind === _kinds.Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variables == null || variables[variableName] === void 0) {
          return;
        }
        const variableValue = variables[variableName];
        if (variableValue === null && (0, _definition.isNonNullType)(type2)) {
          return;
        }
        return variableValue;
      }
      if ((0, _definition.isNonNullType)(type2)) {
        if (valueNode.kind === _kinds.Kind.NULL) {
          return;
        }
        return valueFromAST(valueNode, type2.ofType, variables);
      }
      if (valueNode.kind === _kinds.Kind.NULL) {
        return null;
      }
      if ((0, _definition.isListType)(type2)) {
        const itemType = type2.ofType;
        if (valueNode.kind === _kinds.Kind.LIST) {
          const coercedValues = [];
          for (const itemNode of valueNode.values) {
            if (isMissingVariable(itemNode, variables)) {
              if ((0, _definition.isNonNullType)(itemType)) {
                return;
              }
              coercedValues.push(null);
            } else {
              const itemValue = valueFromAST(itemNode, itemType, variables);
              if (itemValue === void 0) {
                return;
              }
              coercedValues.push(itemValue);
            }
          }
          return coercedValues;
        }
        const coercedValue = valueFromAST(valueNode, itemType, variables);
        if (coercedValue === void 0) {
          return;
        }
        return [coercedValue];
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        if (valueNode.kind !== _kinds.Kind.OBJECT) {
          return;
        }
        const coercedObj = /* @__PURE__ */ Object.create(null);
        const fieldNodes = (0, _keyMap.keyMap)(
          valueNode.fields,
          (field) => field.name.value
        );
        for (const field of Object.values(type2.getFields())) {
          const fieldNode = fieldNodes[field.name];
          if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
            if (field.defaultValue !== void 0) {
              coercedObj[field.name] = field.defaultValue;
            } else if ((0, _definition.isNonNullType)(field.type)) {
              return;
            }
            continue;
          }
          const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
          if (fieldValue === void 0) {
            return;
          }
          coercedObj[field.name] = fieldValue;
        }
        if (type2.isOneOf) {
          const keys = Object.keys(coercedObj);
          if (keys.length !== 1) {
            return;
          }
          if (coercedObj[keys[0]] === null) {
            return;
          }
        }
        return coercedObj;
      }
      if ((0, _definition.isLeafType)(type2)) {
        let result;
        try {
          result = type2.parseLiteral(valueNode, variables);
        } catch (_error) {
          return;
        }
        if (result === void 0) {
          return;
        }
        return result;
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected input type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(valueFromAST, "valueFromAST");
    function isMissingVariable(valueNode, variables) {
      return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
    }
    __name(isMissingVariable, "isMissingVariable");
  }
});

// ../node_modules/graphql/execution/values.js
var require_values = __commonJS({
  "../node_modules/graphql/execution/values.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getArgumentValues = getArgumentValues;
    exports2.getDirectiveValues = getDirectiveValues;
    exports2.getVariableValues = getVariableValues;
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _printPathArray = require_printPathArray();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _coerceInputValue = require_coerceInputValue();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    function getVariableValues(schema, varDefNodes, inputs, options) {
      const errors = [];
      const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
      try {
        const coerced = coerceVariableValues(
          schema,
          varDefNodes,
          inputs,
          (error3) => {
            if (maxErrors != null && errors.length >= maxErrors) {
              throw new _GraphQLError.GraphQLError(
                "Too many errors processing variables, error limit reached. Execution aborted."
              );
            }
            errors.push(error3);
          }
        );
        if (errors.length === 0) {
          return {
            coerced
          };
        }
      } catch (error3) {
        errors.push(error3);
      }
      return {
        errors
      };
    }
    __name(getVariableValues, "getVariableValues");
    function coerceVariableValues(schema, varDefNodes, inputs, onError) {
      const coercedValues = {};
      for (const varDefNode of varDefNodes) {
        const varName = varDefNode.variable.name.value;
        const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
        if (!(0, _definition.isInputType)(varType)) {
          const varTypeStr = (0, _printer.print)(varDefNode.type);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
              {
                nodes: varDefNode.type
              }
            )
          );
          continue;
        }
        if (!hasOwnProperty(inputs, varName)) {
          if (varDefNode.defaultValue) {
            coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
              varDefNode.defaultValue,
              varType
            );
          } else if ((0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
                {
                  nodes: varDefNode
                }
              )
            );
          }
          continue;
        }
        const value = inputs[varName];
        if (value === null && (0, _definition.isNonNullType)(varType)) {
          const varTypeStr = (0, _inspect.inspect)(varType);
          onError(
            new _GraphQLError.GraphQLError(
              `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
              {
                nodes: varDefNode
              }
            )
          );
          continue;
        }
        coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(
          value,
          varType,
          (path, invalidValue, error3) => {
            let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
            if (path.length > 0) {
              prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(
                path
              )}"`;
            }
            onError(
              new _GraphQLError.GraphQLError(prefix + "; " + error3.message, {
                nodes: varDefNode,
                originalError: error3
              })
            );
          }
        );
      }
      return coercedValues;
    }
    __name(coerceVariableValues, "coerceVariableValues");
    function getArgumentValues(def, node, variableValues) {
      var _node$arguments;
      const coercedValues = {};
      const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
      const argNodeMap = (0, _keyMap.keyMap)(
        argumentNodes,
        (arg) => arg.name.value
      );
      for (const argDef of def.args) {
        const name = argDef.name;
        const argType = argDef.type;
        const argumentNode = argNodeMap[name];
        if (!argumentNode) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name] = argDef.defaultValue;
          } else if ((0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name}" of required type "${(0, _inspect.inspect)(
                argType
              )}" was not provided.`,
              {
                nodes: node
              }
            );
          }
          continue;
        }
        const valueNode = argumentNode.value;
        let isNull2 = valueNode.kind === _kinds.Kind.NULL;
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(
                `Argument "${name}" of required type "${(0, _inspect.inspect)(
                  argType
                )}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
                {
                  nodes: valueNode
                }
              );
            }
            continue;
          }
          isNull2 = variableValues[variableName] == null;
        }
        if (isNull2 && (0, _definition.isNonNullType)(argType)) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" of non-null type "${(0, _inspect.inspect)(
              argType
            )}" must not be null.`,
            {
              nodes: valueNode
            }
          );
        }
        const coercedValue = (0, _valueFromAST.valueFromAST)(
          valueNode,
          argType,
          variableValues
        );
        if (coercedValue === void 0) {
          throw new _GraphQLError.GraphQLError(
            `Argument "${name}" has invalid value ${(0, _printer.print)(
              valueNode
            )}.`,
            {
              nodes: valueNode
            }
          );
        }
        coercedValues[name] = coercedValue;
      }
      return coercedValues;
    }
    __name(getArgumentValues, "getArgumentValues");
    function getDirectiveValues(directiveDef, node, variableValues) {
      var _node$directives;
      const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
        (directive) => directive.name.value === directiveDef.name
      );
      if (directiveNode) {
        return getArgumentValues(directiveDef, directiveNode, variableValues);
      }
    }
    __name(getDirectiveValues, "getDirectiveValues");
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    __name(hasOwnProperty, "hasOwnProperty");
  }
});

// ../node_modules/graphql/execution/collectFields.js
var require_collectFields = __commonJS({
  "../node_modules/graphql/execution/collectFields.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.collectFields = collectFields;
    exports2.collectSubfields = collectSubfields;
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _directives = require_directives();
    var _typeFromAST = require_typeFromAST();
    var _values = require_values();
    function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
      const fields = /* @__PURE__ */ new Map();
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        runtimeType,
        selectionSet,
        fields,
        /* @__PURE__ */ new Set()
      );
      return fields;
    }
    __name(collectFields, "collectFields");
    function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
      const subFieldNodes = /* @__PURE__ */ new Map();
      const visitedFragmentNames = /* @__PURE__ */ new Set();
      for (const node of fieldNodes) {
        if (node.selectionSet) {
          collectFieldsImpl(
            schema,
            fragments,
            variableValues,
            returnType,
            node.selectionSet,
            subFieldNodes,
            visitedFragmentNames
          );
        }
      }
      return subFieldNodes;
    }
    __name(collectSubfields, "collectSubfields");
    function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
      for (const selection of selectionSet.selections) {
        switch (selection.kind) {
          case _kinds.Kind.FIELD: {
            if (!shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            const name = getFieldEntryKey(selection);
            const fieldList = fields.get(name);
            if (fieldList !== void 0) {
              fieldList.push(selection);
            } else {
              fields.set(name, [selection]);
            }
            break;
          }
          case _kinds.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
              continue;
            }
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              runtimeType,
              selection.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
          case _kinds.Kind.FRAGMENT_SPREAD: {
            const fragName = selection.name.value;
            if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
              continue;
            }
            visitedFragmentNames.add(fragName);
            const fragment = fragments[fragName];
            if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
              continue;
            }
            collectFieldsImpl(
              schema,
              fragments,
              variableValues,
              runtimeType,
              fragment.selectionSet,
              fields,
              visitedFragmentNames
            );
            break;
          }
        }
      }
    }
    __name(collectFieldsImpl, "collectFieldsImpl");
    function shouldIncludeNode(variableValues, node) {
      const skip = (0, _values.getDirectiveValues)(
        _directives.GraphQLSkipDirective,
        node,
        variableValues
      );
      if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
        return false;
      }
      const include = (0, _values.getDirectiveValues)(
        _directives.GraphQLIncludeDirective,
        node,
        variableValues
      );
      if ((include === null || include === void 0 ? void 0 : include.if) === false) {
        return false;
      }
      return true;
    }
    __name(shouldIncludeNode, "shouldIncludeNode");
    function doesFragmentConditionMatch(schema, fragment, type2) {
      const typeConditionNode = fragment.typeCondition;
      if (!typeConditionNode) {
        return true;
      }
      const conditionalType = (0, _typeFromAST.typeFromAST)(
        schema,
        typeConditionNode
      );
      if (conditionalType === type2) {
        return true;
      }
      if ((0, _definition.isAbstractType)(conditionalType)) {
        return schema.isSubType(conditionalType, type2);
      }
      return false;
    }
    __name(doesFragmentConditionMatch, "doesFragmentConditionMatch");
    function getFieldEntryKey(node) {
      return node.alias ? node.alias.value : node.name.value;
    }
    __name(getFieldEntryKey, "getFieldEntryKey");
  }
});

// ../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
var require_SingleFieldSubscriptionsRule = __commonJS({
  "../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _collectFields = require_collectFields();
    function SingleFieldSubscriptionsRule(context2) {
      return {
        OperationDefinition(node) {
          if (node.operation === "subscription") {
            const schema = context2.getSchema();
            const subscriptionType = schema.getSubscriptionType();
            if (subscriptionType) {
              const operationName = node.name ? node.name.value : null;
              const variableValues = /* @__PURE__ */ Object.create(null);
              const document = context2.getDocument();
              const fragments = /* @__PURE__ */ Object.create(null);
              for (const definition of document.definitions) {
                if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                  fragments[definition.name.value] = definition;
                }
              }
              const fields = (0, _collectFields.collectFields)(
                schema,
                fragments,
                variableValues,
                subscriptionType,
                node.selectionSet
              );
              if (fields.size > 1) {
                const fieldSelectionLists = [...fields.values()];
                const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                const extraFieldSelections = extraFieldSelectionLists.flat();
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                    {
                      nodes: extraFieldSelections
                    }
                  )
                );
              }
              for (const fieldNodes of fields.values()) {
                const field = fieldNodes[0];
                const fieldName = field.name.value;
                if (fieldName.startsWith("__")) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                      {
                        nodes: fieldNodes
                      }
                    )
                  );
                }
              }
            }
          }
        }
      };
    }
    __name(SingleFieldSubscriptionsRule, "SingleFieldSubscriptionsRule");
  }
});

// ../node_modules/graphql/jsutils/groupBy.js
var require_groupBy = __commonJS({
  "../node_modules/graphql/jsutils/groupBy.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.groupBy = groupBy;
    function groupBy(list, keyFn) {
      const result = /* @__PURE__ */ new Map();
      for (const item of list) {
        const key = keyFn(item);
        const group3 = result.get(key);
        if (group3 === void 0) {
          result.set(key, [item]);
        } else {
          group3.push(item);
        }
      }
      return result;
    }
    __name(groupBy, "groupBy");
  }
});

// ../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
var require_UniqueArgumentDefinitionNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentDefinitionNamesRule(context2) {
      return {
        DirectiveDefinition(directiveNode) {
          var _directiveNode$argume;
          const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
        },
        InterfaceTypeDefinition: checkArgUniquenessPerField,
        InterfaceTypeExtension: checkArgUniquenessPerField,
        ObjectTypeDefinition: checkArgUniquenessPerField,
        ObjectTypeExtension: checkArgUniquenessPerField
      };
      function checkArgUniquenessPerField(typeNode) {
        var _typeNode$fields;
        const typeName = typeNode.name.value;
        const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
        for (const fieldDef of fieldNodes) {
          var _fieldDef$arguments;
          const fieldName = fieldDef.name.value;
          const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
          checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
        }
        return false;
      }
      __name(checkArgUniquenessPerField, "checkArgUniquenessPerField");
      function checkArgUniqueness(parentName, argumentNodes) {
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Argument "${parentName}(${argName}:)" can only be defined once.`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
        return false;
      }
      __name(checkArgUniqueness, "checkArgUniqueness");
    }
    __name(UniqueArgumentDefinitionNamesRule, "UniqueArgumentDefinitionNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
var require_UniqueArgumentNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueArgumentNamesRule(context2) {
      return {
        Field: checkArgUniqueness,
        Directive: checkArgUniqueness
      };
      function checkArgUniqueness(parentNode) {
        var _parentNode$arguments;
        const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
        const seenArgs = (0, _groupBy.groupBy)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const [argName, argNodes] of seenArgs) {
          if (argNodes.length > 1) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one argument named "${argName}".`,
                {
                  nodes: argNodes.map((node) => node.name)
                }
              )
            );
          }
        }
      }
      __name(checkArgUniqueness, "checkArgUniqueness");
    }
    __name(UniqueArgumentNamesRule, "UniqueArgumentNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
var require_UniqueDirectiveNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueDirectiveNamesRule(context2) {
      const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      return {
        DirectiveDefinition(node) {
          const directiveName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
                {
                  nodes: node.name
                }
              )
            );
            return;
          }
          if (knownDirectiveNames[directiveName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one directive named "@${directiveName}".`,
                {
                  nodes: [knownDirectiveNames[directiveName], node.name]
                }
              )
            );
          } else {
            knownDirectiveNames[directiveName] = node.name;
          }
          return false;
        }
      };
    }
    __name(UniqueDirectiveNamesRule, "UniqueDirectiveNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
var require_UniqueDirectivesPerLocationRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _directives = require_directives();
    function UniqueDirectivesPerLocationRule(context2) {
      const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
      for (const directive of definedDirectives) {
        uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
      }
      const astDefinitions = context2.getDocument().definitions;
      for (const def of astDefinitions) {
        if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          uniqueDirectiveMap[def.name.value] = !def.repeatable;
        }
      }
      const schemaDirectives = /* @__PURE__ */ Object.create(null);
      const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
      return {
        // Many different AST nodes may contain directives. Rather than listing
        // them all, just listen for entering any node, and check to see if it
        // defines any directives.
        enter(node) {
          if (!("directives" in node) || !node.directives) {
            return;
          }
          let seenDirectives;
          if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
            seenDirectives = schemaDirectives;
          } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
            const typeName = node.name.value;
            seenDirectives = typeDirectivesMap[typeName];
            if (seenDirectives === void 0) {
              typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
            }
          } else {
            seenDirectives = /* @__PURE__ */ Object.create(null);
          }
          for (const directive of node.directives) {
            const directiveName = directive.name.value;
            if (uniqueDirectiveMap[directiveName]) {
              if (seenDirectives[directiveName]) {
                context2.reportError(
                  new _GraphQLError.GraphQLError(
                    `The directive "@${directiveName}" can only be used once at this location.`,
                    {
                      nodes: [seenDirectives[directiveName], directive]
                    }
                  )
                );
              } else {
                seenDirectives[directiveName] = directive;
              }
            }
          }
        }
      };
    }
    __name(UniqueDirectivesPerLocationRule, "UniqueDirectivesPerLocationRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
var require_UniqueEnumValueNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueEnumValueNamesRule(context2) {
      const schema = context2.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownValueNames = /* @__PURE__ */ Object.create(null);
      return {
        EnumTypeDefinition: checkValueUniqueness,
        EnumTypeExtension: checkValueUniqueness
      };
      function checkValueUniqueness(node) {
        var _node$values;
        const typeName = node.name.value;
        if (!knownValueNames[typeName]) {
          knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
        const valueNames = knownValueNames[typeName];
        for (const valueDef of valueNodes) {
          const valueName = valueDef.name.value;
          const existingType = existingTypeMap[typeName];
          if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: valueDef.name
                }
              )
            );
          } else if (valueNames[valueName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Enum value "${typeName}.${valueName}" can only be defined once.`,
                {
                  nodes: [valueNames[valueName], valueDef.name]
                }
              )
            );
          } else {
            valueNames[valueName] = valueDef.name;
          }
        }
        return false;
      }
      __name(checkValueUniqueness, "checkValueUniqueness");
    }
    __name(UniqueEnumValueNamesRule, "UniqueEnumValueNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
var require_UniqueFieldDefinitionNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function UniqueFieldDefinitionNamesRule(context2) {
      const schema = context2.getSchema();
      const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
      const knownFieldNames = /* @__PURE__ */ Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness
      };
      function checkFieldUniqueness(node) {
        var _node$fields;
        const typeName = node.name.value;
        if (!knownFieldNames[typeName]) {
          knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
        }
        const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
        const fieldNames = knownFieldNames[typeName];
        for (const fieldDef of fieldNodes) {
          const fieldName = fieldDef.name.value;
          if (hasField(existingTypeMap[typeName], fieldName)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
                {
                  nodes: fieldDef.name
                }
              )
            );
          } else if (fieldNames[fieldName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${typeName}.${fieldName}" can only be defined once.`,
                {
                  nodes: [fieldNames[fieldName], fieldDef.name]
                }
              )
            );
          } else {
            fieldNames[fieldName] = fieldDef.name;
          }
        }
        return false;
      }
      __name(checkFieldUniqueness, "checkFieldUniqueness");
    }
    __name(UniqueFieldDefinitionNamesRule, "UniqueFieldDefinitionNamesRule");
    function hasField(type2, fieldName) {
      if ((0, _definition.isObjectType)(type2) || (0, _definition.isInterfaceType)(type2) || (0, _definition.isInputObjectType)(type2)) {
        return type2.getFields()[fieldName] != null;
      }
      return false;
    }
    __name(hasField, "hasField");
  }
});

// ../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
var require_UniqueFragmentNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueFragmentNamesRule(context2) {
      const knownFragmentNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: /* @__PURE__ */ __name(() => false, "OperationDefinition"),
        FragmentDefinition(node) {
          const fragmentName = node.name.value;
          if (knownFragmentNames[fragmentName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one fragment named "${fragmentName}".`,
                {
                  nodes: [knownFragmentNames[fragmentName], node.name]
                }
              )
            );
          } else {
            knownFragmentNames[fragmentName] = node.name;
          }
          return false;
        }
      };
    }
    __name(UniqueFragmentNamesRule, "UniqueFragmentNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
var require_UniqueInputFieldNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    function UniqueInputFieldNamesRule(context2) {
      const knownNameStack = [];
      let knownNames = /* @__PURE__ */ Object.create(null);
      return {
        ObjectValue: {
          enter() {
            knownNameStack.push(knownNames);
            knownNames = /* @__PURE__ */ Object.create(null);
          },
          leave() {
            const prevKnownNames = knownNameStack.pop();
            prevKnownNames || (0, _invariant.invariant)(false);
            knownNames = prevKnownNames;
          }
        },
        ObjectField(node) {
          const fieldName = node.name.value;
          if (knownNames[fieldName]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one input field named "${fieldName}".`,
                {
                  nodes: [knownNames[fieldName], node.name]
                }
              )
            );
          } else {
            knownNames[fieldName] = node.name;
          }
        }
      };
    }
    __name(UniqueInputFieldNamesRule, "UniqueInputFieldNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
var require_UniqueOperationNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationNamesRule(context2) {
      const knownOperationNames = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition(node) {
          const operationName = node.name;
          if (operationName) {
            if (knownOperationNames[operationName.value]) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one operation named "${operationName.value}".`,
                  {
                    nodes: [
                      knownOperationNames[operationName.value],
                      operationName
                    ]
                  }
                )
              );
            } else {
              knownOperationNames[operationName.value] = operationName;
            }
          }
          return false;
        },
        FragmentDefinition: /* @__PURE__ */ __name(() => false, "FragmentDefinition")
      };
    }
    __name(UniqueOperationNamesRule, "UniqueOperationNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
var require_UniqueOperationTypesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueOperationTypesRule(context2) {
      const schema = context2.getSchema();
      const definedOperationTypes = /* @__PURE__ */ Object.create(null);
      const existingOperationTypes = schema ? {
        query: schema.getQueryType(),
        mutation: schema.getMutationType(),
        subscription: schema.getSubscriptionType()
      } : {};
      return {
        SchemaDefinition: checkOperationTypes,
        SchemaExtension: checkOperationTypes
      };
      function checkOperationTypes(node) {
        var _node$operationTypes;
        const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
        for (const operationType of operationTypesNodes) {
          const operation = operationType.operation;
          const alreadyDefinedOperationType = definedOperationTypes[operation];
          if (existingOperationTypes[operation]) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Type for ${operation} already defined in the schema. It cannot be redefined.`,
                {
                  nodes: operationType
                }
              )
            );
          } else if (alreadyDefinedOperationType) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one ${operation} type in schema.`,
                {
                  nodes: [alreadyDefinedOperationType, operationType]
                }
              )
            );
          } else {
            definedOperationTypes[operation] = operationType;
          }
        }
        return false;
      }
      __name(checkOperationTypes, "checkOperationTypes");
    }
    __name(UniqueOperationTypesRule, "UniqueOperationTypesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
var require_UniqueTypeNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var _GraphQLError = require_GraphQLError();
    function UniqueTypeNamesRule(context2) {
      const knownTypeNames = /* @__PURE__ */ Object.create(null);
      const schema = context2.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName
      };
      function checkTypeName(node) {
        const typeName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
              {
                nodes: node.name
              }
            )
          );
          return;
        }
        if (knownTypeNames[typeName]) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `There can be only one type named "${typeName}".`,
              {
                nodes: [knownTypeNames[typeName], node.name]
              }
            )
          );
        } else {
          knownTypeNames[typeName] = node.name;
        }
        return false;
      }
      __name(checkTypeName, "checkTypeName");
    }
    __name(UniqueTypeNamesRule, "UniqueTypeNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
var require_UniqueVariableNamesRule = __commonJS({
  "../node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var _groupBy = require_groupBy();
    var _GraphQLError = require_GraphQLError();
    function UniqueVariableNamesRule(context2) {
      return {
        OperationDefinition(operationNode) {
          var _operationNode$variab;
          const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
          const seenVariableDefinitions = (0, _groupBy.groupBy)(
            variableDefinitions,
            (node) => node.variable.name.value
          );
          for (const [variableName, variableNodes] of seenVariableDefinitions) {
            if (variableNodes.length > 1) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one variable named "$${variableName}".`,
                  {
                    nodes: variableNodes.map((node) => node.variable.name)
                  }
                )
              );
            }
          }
        }
      };
    }
    __name(UniqueVariableNamesRule, "UniqueVariableNamesRule");
  }
});

// ../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
var require_ValuesOfCorrectTypeRule = __commonJS({
  "../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var _didYouMean = require_didYouMean();
    var _inspect = require_inspect();
    var _keyMap = require_keyMap();
    var _suggestionList = require_suggestionList();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    function ValuesOfCorrectTypeRule(context2) {
      let variableDefinitions = {};
      return {
        OperationDefinition: {
          enter() {
            variableDefinitions = {};
          }
        },
        VariableDefinition(definition) {
          variableDefinitions[definition.variable.name.value] = definition;
        },
        ListValue(node) {
          const type2 = (0, _definition.getNullableType)(
            context2.getParentInputType()
          );
          if (!(0, _definition.isListType)(type2)) {
            isValidValueNode(context2, node);
            return false;
          }
        },
        ObjectValue(node) {
          const type2 = (0, _definition.getNamedType)(context2.getInputType());
          if (!(0, _definition.isInputObjectType)(type2)) {
            isValidValueNode(context2, node);
            return false;
          }
          const fieldNodeMap = (0, _keyMap.keyMap)(
            node.fields,
            (field) => field.name.value
          );
          for (const fieldDef of Object.values(type2.getFields())) {
            const fieldNode = fieldNodeMap[fieldDef.name];
            if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
              const typeStr = (0, _inspect.inspect)(fieldDef.type);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
          if (type2.isOneOf) {
            validateOneOfInputObject(
              context2,
              node,
              type2,
              fieldNodeMap,
              variableDefinitions
            );
          }
        },
        ObjectField(node) {
          const parentType = (0, _definition.getNamedType)(
            context2.getParentInputType()
          );
          const fieldType = context2.getInputType();
          if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
            const suggestions = (0, _suggestionList.suggestionList)(
              node.name.value,
              Object.keys(parentType.getFields())
            );
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                {
                  nodes: node
                }
              )
            );
          }
        },
        NullValue(node) {
          const type2 = context2.getInputType();
          if ((0, _definition.isNonNullType)(type2)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${(0, _inspect.inspect)(
                  type2
                )}", found ${(0, _printer.print)(node)}.`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        EnumValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "EnumValue"),
        IntValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "IntValue"),
        FloatValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "FloatValue"),
        StringValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "StringValue"),
        BooleanValue: /* @__PURE__ */ __name((node) => isValidValueNode(context2, node), "BooleanValue")
      };
    }
    __name(ValuesOfCorrectTypeRule, "ValuesOfCorrectTypeRule");
    function isValidValueNode(context2, node) {
      const locationType = context2.getInputType();
      if (!locationType) {
        return;
      }
      const type2 = (0, _definition.getNamedType)(locationType);
      if (!(0, _definition.isLeafType)(type2)) {
        const typeStr = (0, _inspect.inspect)(locationType);
        context2.reportError(
          new _GraphQLError.GraphQLError(
            `Expected value of type "${typeStr}", found ${(0, _printer.print)(
              node
            )}.`,
            {
              nodes: node
            }
          )
        );
        return;
      }
      try {
        const parseResult = type2.parseLiteral(
          node,
          void 0
          /* variables */
        );
        if (parseResult === void 0) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}.`,
              {
                nodes: node
              }
            )
          );
        }
      } catch (error3) {
        const typeStr = (0, _inspect.inspect)(locationType);
        if (error3 instanceof _GraphQLError.GraphQLError) {
          context2.reportError(error3);
        } else {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}; ` + error3.message,
              {
                nodes: node,
                originalError: error3
              }
            )
          );
        }
      }
    }
    __name(isValidValueNode, "isValidValueNode");
    function validateOneOfInputObject(context2, node, type2, fieldNodeMap, variableDefinitions) {
      var _fieldNodeMap$keys$;
      const keys = Object.keys(fieldNodeMap);
      const isNotExactlyOneField = keys.length !== 1;
      if (isNotExactlyOneField) {
        context2.reportError(
          new _GraphQLError.GraphQLError(
            `OneOf Input Object "${type2.name}" must specify exactly one key.`,
            {
              nodes: [node]
            }
          )
        );
        return;
      }
      const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
      const isNullLiteral = !value || value.kind === _kinds.Kind.NULL;
      const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === _kinds.Kind.VARIABLE;
      if (isNullLiteral) {
        context2.reportError(
          new _GraphQLError.GraphQLError(
            `Field "${type2.name}.${keys[0]}" must be non-null.`,
            {
              nodes: [node]
            }
          )
        );
        return;
      }
      if (isVariable) {
        const variableName = value.name.value;
        const definition = variableDefinitions[variableName];
        const isNullableVariable = definition.type.kind !== _kinds.Kind.NON_NULL_TYPE;
        if (isNullableVariable) {
          context2.reportError(
            new _GraphQLError.GraphQLError(
              `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`,
              {
                nodes: [node]
              }
            )
          );
        }
      }
    }
    __name(validateOneOfInputObject, "validateOneOfInputObject");
  }
});

// ../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
var require_VariablesAreInputTypesRule = __commonJS({
  "../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var _GraphQLError = require_GraphQLError();
    var _printer = require_printer();
    var _definition = require_definition();
    var _typeFromAST = require_typeFromAST();
    function VariablesAreInputTypesRule(context2) {
      return {
        VariableDefinition(node) {
          const type2 = (0, _typeFromAST.typeFromAST)(
            context2.getSchema(),
            node.type
          );
          if (type2 !== void 0 && !(0, _definition.isInputType)(type2)) {
            const variableName = node.variable.name.value;
            const typeName = (0, _printer.print)(node.type);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
                {
                  nodes: node.type
                }
              )
            );
          }
        }
      };
    }
    __name(VariablesAreInputTypesRule, "VariablesAreInputTypesRule");
  }
});

// ../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
var require_VariablesInAllowedPositionRule = __commonJS({
  "../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var _inspect = require_inspect();
    var _GraphQLError = require_GraphQLError();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _typeComparators = require_typeComparators();
    var _typeFromAST = require_typeFromAST();
    function VariablesInAllowedPositionRule(context2) {
      let varDefMap = /* @__PURE__ */ Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            varDefMap = /* @__PURE__ */ Object.create(null);
          },
          leave(operation) {
            const usages = context2.getRecursiveVariableUsages(operation);
            for (const { node, type: type2, defaultValue, parentType } of usages) {
              const varName = node.name.value;
              const varDef = varDefMap[varName];
              if (varDef && type2) {
                const schema = context2.getSchema();
                const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                if (varType && !allowedVariableUsage(
                  schema,
                  varType,
                  varDef.defaultValue,
                  type2,
                  defaultValue
                )) {
                  const varTypeStr = (0, _inspect.inspect)(varType);
                  const typeStr = (0, _inspect.inspect)(type2);
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                      {
                        nodes: [varDef, node]
                      }
                    )
                  );
                }
                if ((0, _definition.isInputObjectType)(parentType) && parentType.isOneOf && (0, _definition.isNullableType)(varType)) {
                  context2.reportError(
                    new _GraphQLError.GraphQLError(
                      `Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`,
                      {
                        nodes: [varDef, node]
                      }
                    )
                  );
                }
              }
            }
          }
        },
        VariableDefinition(node) {
          varDefMap[node.variable.name.value] = node;
        }
      };
    }
    __name(VariablesInAllowedPositionRule, "VariablesInAllowedPositionRule");
    function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
      if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
        const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
        const hasLocationDefaultValue = locationDefaultValue !== void 0;
        if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
          return false;
        }
        const nullableLocationType = locationType.ofType;
        return (0, _typeComparators.isTypeSubTypeOf)(
          schema,
          varType,
          nullableLocationType
        );
      }
      return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
    }
    __name(allowedVariableUsage, "allowedVariableUsage");
  }
});

// ../node_modules/graphql/validation/specifiedRules.js
var require_specifiedRules = __commonJS({
  "../node_modules/graphql/validation/specifiedRules.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.specifiedSDLRules = exports2.specifiedRules = exports2.recommendedRules = void 0;
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var recommendedRules = Object.freeze([
      _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule
    ]);
    exports2.recommendedRules = recommendedRules;
    var specifiedRules2 = Object.freeze([
      _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
      _UniqueOperationNamesRule.UniqueOperationNamesRule,
      _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
      _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
      _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
      _ScalarLeafsRule.ScalarLeafsRule,
      _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
      _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
      _KnownFragmentNamesRule.KnownFragmentNamesRule,
      _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
      _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
      _NoFragmentCyclesRule.NoFragmentCyclesRule,
      _UniqueVariableNamesRule.UniqueVariableNamesRule,
      _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
      _NoUnusedVariablesRule.NoUnusedVariablesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _KnownArgumentNamesRule.KnownArgumentNamesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
      _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
      _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
      ...recommendedRules
    ]);
    exports2.specifiedRules = specifiedRules2;
    var specifiedSDLRules = Object.freeze([
      _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
      _UniqueOperationTypesRule.UniqueOperationTypesRule,
      _UniqueTypeNamesRule.UniqueTypeNamesRule,
      _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
      _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
      _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
      _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
      _KnownTypeNamesRule.KnownTypeNamesRule,
      _KnownDirectivesRule.KnownDirectivesRule,
      _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
      _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
      _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
      _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
      _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
      _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
    ]);
    exports2.specifiedSDLRules = specifiedSDLRules;
  }
});

// ../node_modules/graphql/validation/ValidationContext.js
var require_ValidationContext = __commonJS({
  "../node_modules/graphql/validation/ValidationContext.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValidationContext = exports2.SDLValidationContext = exports2.ASTValidationContext = void 0;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    var _TypeInfo = require_TypeInfo();
    var ASTValidationContext = class {
      static {
        __name(this, "ASTValidationContext");
      }
      constructor(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = /* @__PURE__ */ new Map();
        this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
        this._onError = onError;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(error3) {
        this._onError(error3);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(name) {
        let fragments;
        if (this._fragments) {
          fragments = this._fragments;
        } else {
          fragments = /* @__PURE__ */ Object.create(null);
          for (const defNode of this.getDocument().definitions) {
            if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
              fragments[defNode.name.value] = defNode;
            }
          }
          this._fragments = fragments;
        }
        return fragments[name];
      }
      getFragmentSpreads(node) {
        let spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          const setsToVisit = [node];
          let set;
          while (set = setsToVisit.pop()) {
            for (const selection of set.selections) {
              if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      }
      getRecursivelyReferencedFragments(operation) {
        let fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          const collectedNames = /* @__PURE__ */ Object.create(null);
          const nodesToVisit = [operation.selectionSet];
          let node;
          while (node = nodesToVisit.pop()) {
            for (const spread of this.getFragmentSpreads(node)) {
              const fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                const fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      }
    };
    exports2.ASTValidationContext = ASTValidationContext;
    var SDLValidationContext = class extends ASTValidationContext {
      static {
        __name(this, "SDLValidationContext");
      }
      constructor(ast, schema, onError) {
        super(ast, onError);
        this._schema = schema;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    };
    exports2.SDLValidationContext = SDLValidationContext;
    var ValidationContext = class extends ASTValidationContext {
      static {
        __name(this, "ValidationContext");
      }
      constructor(schema, ast, typeInfo, onError) {
        super(ast, onError);
        this._schema = schema;
        this._typeInfo = typeInfo;
        this._variableUsages = /* @__PURE__ */ new Map();
        this._recursiveVariableUsages = /* @__PURE__ */ new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(node) {
        let usages = this._variableUsages.get(node);
        if (!usages) {
          const newUsages = [];
          const typeInfo = new _TypeInfo.TypeInfo(this._schema);
          (0, _visitor.visit)(
            node,
            (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
              VariableDefinition: /* @__PURE__ */ __name(() => false, "VariableDefinition"),
              Variable(variable) {
                newUsages.push({
                  node: variable,
                  type: typeInfo.getInputType(),
                  defaultValue: typeInfo.getDefaultValue(),
                  parentType: typeInfo.getParentInputType()
                });
              }
            })
          );
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      }
      getRecursiveVariableUsages(operation) {
        let usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (const frag of this.getRecursivelyReferencedFragments(operation)) {
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    };
    exports2.ValidationContext = ValidationContext;
  }
});

// ../node_modules/graphql/validation/validate.js
var require_validate2 = __commonJS({
  "../node_modules/graphql/validation/validate.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidSDL = assertValidSDL;
    exports2.assertValidSDLExtension = assertValidSDLExtension;
    exports2.validate = validate2;
    exports2.validateSDL = validateSDL;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _visitor = require_visitor();
    var _validate = require_validate();
    var _TypeInfo = require_TypeInfo();
    var _specifiedRules = require_specifiedRules();
    var _ValidationContext = require_ValidationContext();
    function validate2(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
      var _options$maxErrors;
      const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
      documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      const abortObj = Object.freeze({});
      const errors = [];
      const context2 = new _ValidationContext.ValidationContext(
        schema,
        documentAST,
        typeInfo,
        (error3) => {
          if (errors.length >= maxErrors) {
            errors.push(
              new _GraphQLError.GraphQLError(
                "Too many validation errors, error limit reached. Validation aborted."
              )
            );
            throw abortObj;
          }
          errors.push(error3);
        }
      );
      const visitor = (0, _visitor.visitInParallel)(
        rules.map((rule) => rule(context2))
      );
      try {
        (0, _visitor.visit)(
          documentAST,
          (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor)
        );
      } catch (e) {
        if (e !== abortObj) {
          throw e;
        }
      }
      return errors;
    }
    __name(validate2, "validate");
    function validateSDL(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
      const errors = [];
      const context2 = new _ValidationContext.SDLValidationContext(
        documentAST,
        schemaToExtend,
        (error3) => {
          errors.push(error3);
        }
      );
      const visitors = rules.map((rule) => rule(context2));
      (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
      return errors;
    }
    __name(validateSDL, "validateSDL");
    function assertValidSDL(documentAST) {
      const errors = validateSDL(documentAST);
      if (errors.length !== 0) {
        throw new Error(errors.map((error3) => error3.message).join("\n\n"));
      }
    }
    __name(assertValidSDL, "assertValidSDL");
    function assertValidSDLExtension(documentAST, schema) {
      const errors = validateSDL(documentAST, schema);
      if (errors.length !== 0) {
        throw new Error(errors.map((error3) => error3.message).join("\n\n"));
      }
    }
    __name(assertValidSDLExtension, "assertValidSDLExtension");
  }
});

// ../node_modules/graphql/jsutils/memoize3.js
var require_memoize3 = __commonJS({
  "../node_modules/graphql/jsutils/memoize3.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.memoize3 = memoize3;
    function memoize3(fn) {
      let cache0;
      return /* @__PURE__ */ __name(function memoized(a1, a2, a3) {
        if (cache0 === void 0) {
          cache0 = /* @__PURE__ */ new WeakMap();
        }
        let cache1 = cache0.get(a1);
        if (cache1 === void 0) {
          cache1 = /* @__PURE__ */ new WeakMap();
          cache0.set(a1, cache1);
        }
        let cache2 = cache1.get(a2);
        if (cache2 === void 0) {
          cache2 = /* @__PURE__ */ new WeakMap();
          cache1.set(a2, cache2);
        }
        let fnResult = cache2.get(a3);
        if (fnResult === void 0) {
          fnResult = fn(a1, a2, a3);
          cache2.set(a3, fnResult);
        }
        return fnResult;
      }, "memoized");
    }
    __name(memoize3, "memoize3");
  }
});

// ../node_modules/graphql/jsutils/promiseForObject.js
var require_promiseForObject = __commonJS({
  "../node_modules/graphql/jsutils/promiseForObject.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseForObject = promiseForObject;
    function promiseForObject(object) {
      return Promise.all(Object.values(object)).then((resolvedValues) => {
        const resolvedObject = /* @__PURE__ */ Object.create(null);
        for (const [i, key] of Object.keys(object).entries()) {
          resolvedObject[key] = resolvedValues[i];
        }
        return resolvedObject;
      });
    }
    __name(promiseForObject, "promiseForObject");
  }
});

// ../node_modules/graphql/jsutils/promiseReduce.js
var require_promiseReduce = __commonJS({
  "../node_modules/graphql/jsutils/promiseReduce.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.promiseReduce = promiseReduce;
    var _isPromise = require_isPromise();
    function promiseReduce(values, callbackFn, initialValue) {
      let accumulator = initialValue;
      for (const value of values) {
        accumulator = (0, _isPromise.isPromise)(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
      }
      return accumulator;
    }
    __name(promiseReduce, "promiseReduce");
  }
});

// ../node_modules/graphql/jsutils/toError.js
var require_toError = __commonJS({
  "../node_modules/graphql/jsutils/toError.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toError = toError;
    var _inspect = require_inspect();
    function toError(thrownValue) {
      return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
    }
    __name(toError, "toError");
    var NonErrorThrown = class extends Error {
      static {
        __name(this, "NonErrorThrown");
      }
      constructor(thrownValue) {
        super("Unexpected error value: " + (0, _inspect.inspect)(thrownValue));
        this.name = "NonErrorThrown";
        this.thrownValue = thrownValue;
      }
    };
  }
});

// ../node_modules/graphql/error/locatedError.js
var require_locatedError = __commonJS({
  "../node_modules/graphql/error/locatedError.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.locatedError = locatedError;
    var _toError = require_toError();
    var _GraphQLError = require_GraphQLError();
    function locatedError(rawOriginalError, nodes, path) {
      var _nodes;
      const originalError = (0, _toError.toError)(rawOriginalError);
      if (isLocatedGraphQLError(originalError)) {
        return originalError;
      }
      return new _GraphQLError.GraphQLError(originalError.message, {
        nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
        source: originalError.source,
        positions: originalError.positions,
        path,
        originalError
      });
    }
    __name(locatedError, "locatedError");
    function isLocatedGraphQLError(error3) {
      return Array.isArray(error3.path);
    }
    __name(isLocatedGraphQLError, "isLocatedGraphQLError");
  }
});

// ../node_modules/graphql/execution/execute.js
var require_execute = __commonJS({
  "../node_modules/graphql/execution/execute.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidExecutionArguments = assertValidExecutionArguments;
    exports2.buildExecutionContext = buildExecutionContext;
    exports2.buildResolveInfo = buildResolveInfo;
    exports2.defaultTypeResolver = exports2.defaultFieldResolver = void 0;
    exports2.execute = execute2;
    exports2.executeSync = executeSync;
    exports2.getFieldDef = getFieldDef;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _isIterableObject = require_isIterableObject();
    var _isObjectLike = require_isObjectLike();
    var _isPromise = require_isPromise();
    var _memoize = require_memoize3();
    var _Path = require_Path();
    var _promiseForObject = require_promiseForObject();
    var _promiseReduce = require_promiseReduce();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _ast = require_ast();
    var _kinds = require_kinds();
    var _definition = require_definition();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _collectFields = require_collectFields();
    var _values = require_values();
    var collectSubfields = (0, _memoize.memoize3)(
      (exeContext, returnType, fieldNodes) => (0, _collectFields.collectSubfields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        returnType,
        fieldNodes
      )
    );
    function execute2(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const { schema, document, variableValues, rootValue } = args;
      assertValidExecutionArguments(schema, document, variableValues);
      const exeContext = buildExecutionContext(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const { operation } = exeContext;
        const result = executeOperation(exeContext, operation, rootValue);
        if ((0, _isPromise.isPromise)(result)) {
          return result.then(
            (data) => buildResponse(data, exeContext.errors),
            (error3) => {
              exeContext.errors.push(error3);
              return buildResponse(null, exeContext.errors);
            }
          );
        }
        return buildResponse(result, exeContext.errors);
      } catch (error3) {
        exeContext.errors.push(error3);
        return buildResponse(null, exeContext.errors);
      }
    }
    __name(execute2, "execute");
    function executeSync(args) {
      const result = execute2(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    __name(executeSync, "executeSync");
    function buildResponse(data, errors) {
      return errors.length === 0 ? {
        data
      } : {
        errors,
        data
      };
    }
    __name(buildResponse, "buildResponse");
    function assertValidExecutionArguments(schema, document, rawVariableValues) {
      document || (0, _devAssert.devAssert)(false, "Must provide document.");
      (0, _validate.assertValidSchema)(schema);
      rawVariableValues == null || (0, _isObjectLike.isObjectLike)(rawVariableValues) || (0, _devAssert.devAssert)(
        false,
        "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
      );
    }
    __name(assertValidExecutionArguments, "assertValidExecutionArguments");
    function buildExecutionContext(args) {
      var _definition$name, _operation$variableDe, _options$maxCoercionE;
      const {
        schema,
        document,
        rootValue,
        contextValue,
        variableValues: rawVariableValues,
        operationName,
        fieldResolver,
        typeResolver,
        subscribeFieldResolver,
        options
      } = args;
      let operation;
      const fragments = /* @__PURE__ */ Object.create(null);
      for (const definition of document.definitions) {
        switch (definition.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            if (operationName == null) {
              if (operation !== void 0) {
                return [
                  new _GraphQLError.GraphQLError(
                    "Must provide operation name if query contains multiple operations."
                  )
                ];
              }
              operation = definition;
            } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
              operation = definition;
            }
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            fragments[definition.name.value] = definition;
            break;
          default:
        }
      }
      if (!operation) {
        if (operationName != null) {
          return [
            new _GraphQLError.GraphQLError(
              `Unknown operation named "${operationName}".`
            )
          ];
        }
        return [new _GraphQLError.GraphQLError("Must provide an operation.")];
      }
      const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
      const coercedVariableValues = (0, _values.getVariableValues)(
        schema,
        variableDefinitions,
        rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
        {
          maxErrors: (_options$maxCoercionE = options === null || options === void 0 ? void 0 : options.maxCoercionErrors) !== null && _options$maxCoercionE !== void 0 ? _options$maxCoercionE : 50
        }
      );
      if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
      }
      return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver2,
        typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
        subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver2,
        errors: []
      };
    }
    __name(buildExecutionContext, "buildExecutionContext");
    function executeOperation(exeContext, operation, rootValue) {
      const rootType = exeContext.schema.getRootType(operation.operation);
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(
          `Schema is not configured to execute ${operation.operation} operation.`,
          {
            nodes: operation
          }
        );
      }
      const rootFields = (0, _collectFields.collectFields)(
        exeContext.schema,
        exeContext.fragments,
        exeContext.variableValues,
        rootType,
        operation.selectionSet
      );
      const path = void 0;
      switch (operation.operation) {
        case _ast.OperationTypeNode.QUERY:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
        case _ast.OperationTypeNode.MUTATION:
          return executeFieldsSerially(
            exeContext,
            rootType,
            rootValue,
            path,
            rootFields
          );
        case _ast.OperationTypeNode.SUBSCRIPTION:
          return executeFields(exeContext, rootType, rootValue, path, rootFields);
      }
    }
    __name(executeOperation, "executeOperation");
    function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
      return (0, _promiseReduce.promiseReduce)(
        fields.entries(),
        (results, [responseName, fieldNodes]) => {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result === void 0) {
            return results;
          }
          if ((0, _isPromise.isPromise)(result)) {
            return result.then((resolvedResult) => {
              results[responseName] = resolvedResult;
              return results;
            });
          }
          results[responseName] = result;
          return results;
        },
        /* @__PURE__ */ Object.create(null)
      );
    }
    __name(executeFieldsSerially, "executeFieldsSerially");
    function executeFields(exeContext, parentType, sourceValue, path, fields) {
      const results = /* @__PURE__ */ Object.create(null);
      let containsPromise = false;
      try {
        for (const [responseName, fieldNodes] of fields.entries()) {
          const fieldPath = (0, _Path.addPath)(path, responseName, parentType.name);
          const result = executeField(
            exeContext,
            parentType,
            sourceValue,
            fieldNodes,
            fieldPath
          );
          if (result !== void 0) {
            results[responseName] = result;
            if ((0, _isPromise.isPromise)(result)) {
              containsPromise = true;
            }
          }
        }
      } catch (error3) {
        if (containsPromise) {
          return (0, _promiseForObject.promiseForObject)(results).finally(() => {
            throw error3;
          });
        }
        throw error3;
      }
      if (!containsPromise) {
        return results;
      }
      return (0, _promiseForObject.promiseForObject)(results);
    }
    __name(executeFields, "executeFields");
    function executeField(exeContext, parentType, source, fieldNodes, path) {
      var _fieldDef$resolve;
      const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
      if (!fieldDef) {
        return;
      }
      const returnType = fieldDef.type;
      const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
      const info3 = buildResolveInfo(
        exeContext,
        fieldDef,
        fieldNodes,
        parentType,
        path
      );
      try {
        const args = (0, _values.getArgumentValues)(
          fieldDef,
          fieldNodes[0],
          exeContext.variableValues
        );
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info3);
        let completed;
        if ((0, _isPromise.isPromise)(result)) {
          completed = result.then(
            (resolved) => completeValue(exeContext, returnType, fieldNodes, info3, path, resolved)
          );
        } else {
          completed = completeValue(
            exeContext,
            returnType,
            fieldNodes,
            info3,
            path,
            result
          );
        }
        if ((0, _isPromise.isPromise)(completed)) {
          return completed.then(void 0, (rawError) => {
            const error3 = (0, _locatedError.locatedError)(
              rawError,
              fieldNodes,
              (0, _Path.pathToArray)(path)
            );
            return handleFieldError(error3, returnType, exeContext);
          });
        }
        return completed;
      } catch (rawError) {
        const error3 = (0, _locatedError.locatedError)(
          rawError,
          fieldNodes,
          (0, _Path.pathToArray)(path)
        );
        return handleFieldError(error3, returnType, exeContext);
      }
    }
    __name(executeField, "executeField");
    function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
      return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues
      };
    }
    __name(buildResolveInfo, "buildResolveInfo");
    function handleFieldError(error3, returnType, exeContext) {
      if ((0, _definition.isNonNullType)(returnType)) {
        throw error3;
      }
      exeContext.errors.push(error3);
      return null;
    }
    __name(handleFieldError, "handleFieldError");
    function completeValue(exeContext, returnType, fieldNodes, info3, path, result) {
      if (result instanceof Error) {
        throw result;
      }
      if ((0, _definition.isNonNullType)(returnType)) {
        const completed = completeValue(
          exeContext,
          returnType.ofType,
          fieldNodes,
          info3,
          path,
          result
        );
        if (completed === null) {
          throw new Error(
            `Cannot return null for non-nullable field ${info3.parentType.name}.${info3.fieldName}.`
          );
        }
        return completed;
      }
      if (result == null) {
        return null;
      }
      if ((0, _definition.isListType)(returnType)) {
        return completeListValue(
          exeContext,
          returnType,
          fieldNodes,
          info3,
          path,
          result
        );
      }
      if ((0, _definition.isLeafType)(returnType)) {
        return completeLeafValue(returnType, result);
      }
      if ((0, _definition.isAbstractType)(returnType)) {
        return completeAbstractValue(
          exeContext,
          returnType,
          fieldNodes,
          info3,
          path,
          result
        );
      }
      if ((0, _definition.isObjectType)(returnType)) {
        return completeObjectValue(
          exeContext,
          returnType,
          fieldNodes,
          info3,
          path,
          result
        );
      }
      (0, _invariant.invariant)(
        false,
        "Cannot complete value of unexpected output type: " + (0, _inspect.inspect)(returnType)
      );
    }
    __name(completeValue, "completeValue");
    function completeListValue(exeContext, returnType, fieldNodes, info3, path, result) {
      if (!(0, _isIterableObject.isIterableObject)(result)) {
        throw new _GraphQLError.GraphQLError(
          `Expected Iterable, but did not find one for field "${info3.parentType.name}.${info3.fieldName}".`
        );
      }
      const itemType = returnType.ofType;
      let containsPromise = false;
      const completedResults = Array.from(result, (item, index) => {
        const itemPath = (0, _Path.addPath)(path, index, void 0);
        try {
          let completedItem;
          if ((0, _isPromise.isPromise)(item)) {
            completedItem = item.then(
              (resolved) => completeValue(
                exeContext,
                itemType,
                fieldNodes,
                info3,
                itemPath,
                resolved
              )
            );
          } else {
            completedItem = completeValue(
              exeContext,
              itemType,
              fieldNodes,
              info3,
              itemPath,
              item
            );
          }
          if ((0, _isPromise.isPromise)(completedItem)) {
            containsPromise = true;
            return completedItem.then(void 0, (rawError) => {
              const error3 = (0, _locatedError.locatedError)(
                rawError,
                fieldNodes,
                (0, _Path.pathToArray)(itemPath)
              );
              return handleFieldError(error3, itemType, exeContext);
            });
          }
          return completedItem;
        } catch (rawError) {
          const error3 = (0, _locatedError.locatedError)(
            rawError,
            fieldNodes,
            (0, _Path.pathToArray)(itemPath)
          );
          return handleFieldError(error3, itemType, exeContext);
        }
      });
      return containsPromise ? Promise.all(completedResults) : completedResults;
    }
    __name(completeListValue, "completeListValue");
    function completeLeafValue(returnType, result) {
      const serializedResult = returnType.serialize(result);
      if (serializedResult == null) {
        throw new Error(
          `Expected \`${(0, _inspect.inspect)(returnType)}.serialize(${(0, _inspect.inspect)(result)})\` to return non-nullable value, returned: ${(0, _inspect.inspect)(
            serializedResult
          )}`
        );
      }
      return serializedResult;
    }
    __name(completeLeafValue, "completeLeafValue");
    function completeAbstractValue(exeContext, returnType, fieldNodes, info3, path, result) {
      var _returnType$resolveTy;
      const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
      const contextValue = exeContext.contextValue;
      const runtimeType = resolveTypeFn(result, contextValue, info3, returnType);
      if ((0, _isPromise.isPromise)(runtimeType)) {
        return runtimeType.then(
          (resolvedRuntimeType) => completeObjectValue(
            exeContext,
            ensureValidRuntimeType(
              resolvedRuntimeType,
              exeContext,
              returnType,
              fieldNodes,
              info3,
              result
            ),
            fieldNodes,
            info3,
            path,
            result
          )
        );
      }
      return completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          runtimeType,
          exeContext,
          returnType,
          fieldNodes,
          info3,
          result
        ),
        fieldNodes,
        info3,
        path,
        result
      );
    }
    __name(completeAbstractValue, "completeAbstractValue");
    function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info3, result) {
      if (runtimeTypeName == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info3.parentType.name}.${info3.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
          fieldNodes
        );
      }
      if ((0, _definition.isObjectType)(runtimeTypeName)) {
        throw new _GraphQLError.GraphQLError(
          "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
        );
      }
      if (typeof runtimeTypeName !== "string") {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info3.parentType.name}.${info3.fieldName}" with value ${(0, _inspect.inspect)(result)}, received "${(0, _inspect.inspect)(runtimeTypeName)}".`
        );
      }
      const runtimeType = exeContext.schema.getType(runtimeTypeName);
      if (runtimeType == null) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!(0, _definition.isObjectType)(runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new _GraphQLError.GraphQLError(
          `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
          {
            nodes: fieldNodes
          }
        );
      }
      return runtimeType;
    }
    __name(ensureValidRuntimeType, "ensureValidRuntimeType");
    function completeObjectValue(exeContext, returnType, fieldNodes, info3, path, result) {
      const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
      if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info3);
        if ((0, _isPromise.isPromise)(isTypeOf)) {
          return isTypeOf.then((resolvedIsTypeOf) => {
            if (!resolvedIsTypeOf) {
              throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
            return executeFields(
              exeContext,
              returnType,
              result,
              path,
              subFieldNodes
            );
          });
        }
        if (!isTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
      }
      return executeFields(exeContext, returnType, result, path, subFieldNodes);
    }
    __name(completeObjectValue, "completeObjectValue");
    function invalidReturnTypeError(returnType, result, fieldNodes) {
      return new _GraphQLError.GraphQLError(
        `Expected value of type "${returnType.name}" but got: ${(0, _inspect.inspect)(result)}.`,
        {
          nodes: fieldNodes
        }
      );
    }
    __name(invalidReturnTypeError, "invalidReturnTypeError");
    var defaultTypeResolver = /* @__PURE__ */ __name(function(value, contextValue, info3, abstractType) {
      if ((0, _isObjectLike.isObjectLike)(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      const possibleTypes = info3.schema.getPossibleTypes(abstractType);
      const promisedIsTypeOfResults = [];
      for (let i = 0; i < possibleTypes.length; i++) {
        const type2 = possibleTypes[i];
        if (type2.isTypeOf) {
          const isTypeOfResult = type2.isTypeOf(value, contextValue, info3);
          if ((0, _isPromise.isPromise)(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type2.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
          for (let i = 0; i < isTypeOfResults.length; i++) {
            if (isTypeOfResults[i]) {
              return possibleTypes[i].name;
            }
          }
        });
      }
    }, "defaultTypeResolver");
    exports2.defaultTypeResolver = defaultTypeResolver;
    var defaultFieldResolver2 = /* @__PURE__ */ __name(function(source, args, contextValue, info3) {
      if ((0, _isObjectLike.isObjectLike)(source) || typeof source === "function") {
        const property = source[info3.fieldName];
        if (typeof property === "function") {
          return source[info3.fieldName](args, contextValue, info3);
        }
        return property;
      }
    }, "defaultFieldResolver");
    exports2.defaultFieldResolver = defaultFieldResolver2;
    function getFieldDef(schema, parentType, fieldNode) {
      const fieldName = fieldNode.name.value;
      if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.SchemaMetaFieldDef;
      } else if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
        return _introspection.TypeMetaFieldDef;
      } else if (fieldName === _introspection.TypeNameMetaFieldDef.name) {
        return _introspection.TypeNameMetaFieldDef;
      }
      return parentType.getFields()[fieldName];
    }
    __name(getFieldDef, "getFieldDef");
  }
});

// ../node_modules/graphql/graphql.js
var require_graphql = __commonJS({
  "../node_modules/graphql/graphql.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.graphql = graphql;
    exports2.graphqlSync = graphqlSync;
    var _devAssert = require_devAssert();
    var _isPromise = require_isPromise();
    var _parser = require_parser();
    var _validate = require_validate();
    var _validate2 = require_validate2();
    var _execute = require_execute();
    function graphql(args) {
      return new Promise((resolve) => resolve(graphqlImpl(args)));
    }
    __name(graphql, "graphql");
    function graphqlSync(args) {
      const result = graphqlImpl(args);
      if ((0, _isPromise.isPromise)(result)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return result;
    }
    __name(graphqlSync, "graphqlSync");
    function graphqlImpl(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const {
        schema,
        source,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      } = args;
      const schemaValidationErrors = (0, _validate.validateSchema)(schema);
      if (schemaValidationErrors.length > 0) {
        return {
          errors: schemaValidationErrors
        };
      }
      let document;
      try {
        document = (0, _parser.parse)(source);
      } catch (syntaxError) {
        return {
          errors: [syntaxError]
        };
      }
      const validationErrors = (0, _validate2.validate)(schema, document);
      if (validationErrors.length > 0) {
        return {
          errors: validationErrors
        };
      }
      return (0, _execute.execute)({
        schema,
        document,
        rootValue,
        contextValue,
        variableValues,
        operationName,
        fieldResolver,
        typeResolver
      });
    }
    __name(graphqlImpl, "graphqlImpl");
  }
});

// ../node_modules/graphql/type/index.js
var require_type = __commonJS({
  "../node_modules/graphql/type/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.DEFAULT_DEPRECATION_REASON;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GRAPHQL_MAX_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GRAPHQL_MIN_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLBoolean;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLDeprecatedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLFloat;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLID;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLIncludeDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLInt;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLList;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLNonNull;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLOneOfDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLOneOfDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _schema.GraphQLSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLSkipDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.GraphQLSpecifiedByDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.GraphQLString;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.GraphQLUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.SchemaMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.TypeMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.TypeNameMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Directive;
      }, "get")
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__EnumValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Field;
      }, "get")
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__InputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Schema;
      }, "get")
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__Type;
      }, "get")
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.__TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.assertDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertName.assertEnumValueName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertListType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertName.assertName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _schema.assertSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _validate.assertValidSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.assertWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.getNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.getNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.introspectionTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.isDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspection.isIntrospectionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isListType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isRequiredArgument;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isRequiredInputField;
      }, "get")
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _schema.isSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.isSpecifiedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.isSpecifiedScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isType;
      }, "get")
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.isWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.resolveObjMapThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _definition.resolveReadonlyArrayThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directives.specifiedDirectives;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _scalars.specifiedScalarTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _validate.validateSchema;
      }, "get")
    });
    var _schema = require_schema();
    var _definition = require_definition();
    var _directives = require_directives();
    var _scalars = require_scalars();
    var _introspection = require_introspection();
    var _validate = require_validate();
    var _assertName = require_assertName();
  }
});

// ../node_modules/graphql/language/index.js
var require_language = __commonJS({
  "../node_modules/graphql/language/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.BREAK;
      }, "get")
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _directiveLocation.DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _kinds.Kind;
      }, "get")
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _lexer.Lexer;
      }, "get")
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ast.Location;
      }, "get")
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ast.OperationTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _source.Source;
      }, "get")
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ast.Token;
      }, "get")
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _tokenKind.TokenKind;
      }, "get")
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.getEnterLeaveForKind;
      }, "get")
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _location.getLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.getVisitFn;
      }, "get")
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isConstValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isExecutableDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isSelectionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeSystemDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isTypeSystemExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _predicates.isValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parse;
      }, "get")
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parseConstValue;
      }, "get")
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parseType;
      }, "get")
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _parser.parseValue;
      }, "get")
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printer.print;
      }, "get")
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printLocation.printLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printLocation.printSourceLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.visit;
      }, "get")
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _visitor.visitInParallel;
      }, "get")
    });
    var _source = require_source();
    var _location = require_location();
    var _printLocation = require_printLocation();
    var _kinds = require_kinds();
    var _tokenKind = require_tokenKind();
    var _lexer = require_lexer();
    var _parser = require_parser();
    var _printer = require_printer();
    var _visitor = require_visitor();
    var _ast = require_ast();
    var _predicates = require_predicates();
    var _directiveLocation = require_directiveLocation();
  }
});

// ../node_modules/graphql/jsutils/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "../node_modules/graphql/jsutils/isAsyncIterable.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = isAsyncIterable;
    function isAsyncIterable(maybeAsyncIterable) {
      return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
    }
    __name(isAsyncIterable, "isAsyncIterable");
  }
});

// ../node_modules/graphql/execution/mapAsyncIterator.js
var require_mapAsyncIterator = __commonJS({
  "../node_modules/graphql/execution/mapAsyncIterator.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapAsyncIterator = mapAsyncIterator;
    function mapAsyncIterator(iterable, callback) {
      const iterator = iterable[Symbol.asyncIterator]();
      async function mapResult(result) {
        if (result.done) {
          return result;
        }
        try {
          return {
            value: await callback(result.value),
            done: false
          };
        } catch (error3) {
          if (typeof iterator.return === "function") {
            try {
              await iterator.return();
            } catch (_e) {
            }
          }
          throw error3;
        }
      }
      __name(mapResult, "mapResult");
      return {
        async next() {
          return mapResult(await iterator.next());
        },
        async return() {
          return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
            value: void 0,
            done: true
          };
        },
        async throw(error3) {
          if (typeof iterator.throw === "function") {
            return mapResult(await iterator.throw(error3));
          }
          throw error3;
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    __name(mapAsyncIterator, "mapAsyncIterator");
  }
});

// ../node_modules/graphql/execution/subscribe.js
var require_subscribe = __commonJS({
  "../node_modules/graphql/execution/subscribe.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSourceEventStream = createSourceEventStream;
    exports2.subscribe = subscribe;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isAsyncIterable = require_isAsyncIterable();
    var _Path = require_Path();
    var _GraphQLError = require_GraphQLError();
    var _locatedError = require_locatedError();
    var _collectFields = require_collectFields();
    var _execute = require_execute();
    var _mapAsyncIterator = require_mapAsyncIterator();
    var _values = require_values();
    async function subscribe(args) {
      arguments.length < 2 || (0, _devAssert.devAssert)(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const resultOrStream = await createSourceEventStream(args);
      if (!(0, _isAsyncIterable.isAsyncIterable)(resultOrStream)) {
        return resultOrStream;
      }
      const mapSourceToResponse = /* @__PURE__ */ __name((payload) => (0, _execute.execute)({ ...args, rootValue: payload }), "mapSourceToResponse");
      return (0, _mapAsyncIterator.mapAsyncIterator)(
        resultOrStream,
        mapSourceToResponse
      );
    }
    __name(subscribe, "subscribe");
    function toNormalizedArgs(args) {
      const firstArg = args[0];
      if (firstArg && "document" in firstArg) {
        return firstArg;
      }
      return {
        schema: firstArg,
        // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        subscribeFieldResolver: args[6]
      };
    }
    __name(toNormalizedArgs, "toNormalizedArgs");
    async function createSourceEventStream(...rawArgs) {
      const args = toNormalizedArgs(rawArgs);
      const { schema, document, variableValues } = args;
      (0, _execute.assertValidExecutionArguments)(schema, document, variableValues);
      const exeContext = (0, _execute.buildExecutionContext)(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const eventStream = await executeSubscription(exeContext);
        if (!(0, _isAsyncIterable.isAsyncIterable)(eventStream)) {
          throw new Error(
            `Subscription field must return Async Iterable. Received: ${(0, _inspect.inspect)(eventStream)}.`
          );
        }
        return eventStream;
      } catch (error3) {
        if (error3 instanceof _GraphQLError.GraphQLError) {
          return {
            errors: [error3]
          };
        }
        throw error3;
      }
    }
    __name(createSourceEventStream, "createSourceEventStream");
    async function executeSubscription(exeContext) {
      const { schema, fragments, operation, variableValues, rootValue } = exeContext;
      const rootType = schema.getSubscriptionType();
      if (rootType == null) {
        throw new _GraphQLError.GraphQLError(
          "Schema is not configured to execute subscription operation.",
          {
            nodes: operation
          }
        );
      }
      const rootFields = (0, _collectFields.collectFields)(
        schema,
        fragments,
        variableValues,
        rootType,
        operation.selectionSet
      );
      const [responseName, fieldNodes] = [...rootFields.entries()][0];
      const fieldDef = (0, _execute.getFieldDef)(schema, rootType, fieldNodes[0]);
      if (!fieldDef) {
        const fieldName = fieldNodes[0].name.value;
        throw new _GraphQLError.GraphQLError(
          `The subscription field "${fieldName}" is not defined.`,
          {
            nodes: fieldNodes
          }
        );
      }
      const path = (0, _Path.addPath)(void 0, responseName, rootType.name);
      const info3 = (0, _execute.buildResolveInfo)(
        exeContext,
        fieldDef,
        fieldNodes,
        rootType,
        path
      );
      try {
        var _fieldDef$subscribe;
        const args = (0, _values.getArgumentValues)(
          fieldDef,
          fieldNodes[0],
          variableValues
        );
        const contextValue = exeContext.contextValue;
        const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
        const eventStream = await resolveFn(rootValue, args, contextValue, info3);
        if (eventStream instanceof Error) {
          throw eventStream;
        }
        return eventStream;
      } catch (error3) {
        throw (0, _locatedError.locatedError)(
          error3,
          fieldNodes,
          (0, _Path.pathToArray)(path)
        );
      }
    }
    __name(executeSubscription, "executeSubscription");
  }
});

// ../node_modules/graphql/execution/index.js
var require_execution = __commonJS({
  "../node_modules/graphql/execution/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _subscribe.createSourceEventStream;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.defaultFieldResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.defaultTypeResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.execute;
      }, "get")
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _execute.executeSync;
      }, "get")
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _values.getArgumentValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _values.getDirectiveValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _values.getVariableValues;
      }, "get")
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _Path.pathToArray;
      }, "get")
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _subscribe.subscribe;
      }, "get")
    });
    var _Path = require_Path();
    var _execute = require_execute();
    var _subscribe = require_subscribe();
    var _values = require_values();
  }
});

// ../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js
var require_NoDeprecatedCustomRule = __commonJS({
  "../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
    var _invariant = require_invariant();
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    function NoDeprecatedCustomRule(context2) {
      return {
        Field(node) {
          const fieldDef = context2.getFieldDef();
          const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
          if (fieldDef && deprecationReason != null) {
            const parentType = context2.getParentType();
            parentType != null || (0, _invariant.invariant)(false);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        },
        Argument(node) {
          const argDef = context2.getArgument();
          const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
          if (argDef && deprecationReason != null) {
            const directiveDef = context2.getDirective();
            if (directiveDef != null) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            } else {
              const parentType = context2.getParentType();
              const fieldDef = context2.getFieldDef();
              parentType != null && fieldDef != null || (0, _invariant.invariant)(false);
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        ObjectField(node) {
          const inputObjectDef = (0, _definition.getNamedType)(
            context2.getParentInputType()
          );
          if ((0, _definition.isInputObjectType)(inputObjectDef)) {
            const inputFieldDef = inputObjectDef.getFields()[node.name.value];
            const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
            if (deprecationReason != null) {
              context2.reportError(
                new _GraphQLError.GraphQLError(
                  `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        },
        EnumValue(node) {
          const enumValueDef = context2.getEnumValue();
          const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
          if (enumValueDef && deprecationReason != null) {
            const enumTypeDef = (0, _definition.getNamedType)(
              context2.getInputType()
            );
            enumTypeDef != null || (0, _invariant.invariant)(false);
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(NoDeprecatedCustomRule, "NoDeprecatedCustomRule");
  }
});

// ../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js
var require_NoSchemaIntrospectionCustomRule = __commonJS({
  "../node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
    var _GraphQLError = require_GraphQLError();
    var _definition = require_definition();
    var _introspection = require_introspection();
    function NoSchemaIntrospectionCustomRule(context2) {
      return {
        Field(node) {
          const type2 = (0, _definition.getNamedType)(context2.getType());
          if (type2 && (0, _introspection.isIntrospectionType)(type2)) {
            context2.reportError(
              new _GraphQLError.GraphQLError(
                `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      };
    }
    __name(NoSchemaIntrospectionCustomRule, "NoSchemaIntrospectionCustomRule");
  }
});

// ../node_modules/graphql/validation/index.js
var require_validation = __commonJS({
  "../node_modules/graphql/validation/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ExecutableDefinitionsRule.ExecutableDefinitionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownArgumentNamesRule.KnownArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownDirectivesRule.KnownDirectivesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownFragmentNamesRule.KnownFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _KnownTypeNamesRule.KnownTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _LoneAnonymousOperationRule.LoneAnonymousOperationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "MaxIntrospectionDepthRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _MaxIntrospectionDepthRule.MaxIntrospectionDepthRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoDeprecatedCustomRule.NoDeprecatedCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoFragmentCyclesRule.NoFragmentCyclesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoSchemaIntrospectionCustomRule.NoSchemaIntrospectionCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoUndefinedVariablesRule.NoUndefinedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoUnusedFragmentsRule.NoUnusedFragmentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _NoUnusedVariablesRule.NoUnusedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ScalarLeafsRule.ScalarLeafsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueArgumentNamesRule.UniqueArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueFragmentNamesRule.UniqueFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueOperationNamesRule.UniqueOperationNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueOperationTypesRule.UniqueOperationTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueTypeNamesRule.UniqueTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _UniqueVariableNamesRule.UniqueVariableNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ValidationContext.ValidationContext;
      }, "get")
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _VariablesAreInputTypesRule.VariablesAreInputTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "recommendedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _specifiedRules.recommendedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _specifiedRules.specifiedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _validate.validate;
      }, "get")
    });
    var _validate = require_validate2();
    var _ValidationContext = require_ValidationContext();
    var _specifiedRules = require_specifiedRules();
    var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
    var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
    var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
    var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
    var _KnownDirectivesRule = require_KnownDirectivesRule();
    var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
    var _KnownTypeNamesRule = require_KnownTypeNamesRule();
    var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
    var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
    var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
    var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
    var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
    var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
    var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
    var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
    var _ScalarLeafsRule = require_ScalarLeafsRule();
    var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
    var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
    var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
    var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
    var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
    var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
    var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
    var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
    var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
    var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
    var _MaxIntrospectionDepthRule = require_MaxIntrospectionDepthRule();
    var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
    var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
    var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
    var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
    var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
    var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
    var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
    var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
    var _NoDeprecatedCustomRule = require_NoDeprecatedCustomRule();
    var _NoSchemaIntrospectionCustomRule = require_NoSchemaIntrospectionCustomRule();
  }
});

// ../node_modules/graphql/error/index.js
var require_error = __commonJS({
  "../node_modules/graphql/error/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _GraphQLError.GraphQLError;
      }, "get")
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _GraphQLError.formatError;
      }, "get")
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _locatedError.locatedError;
      }, "get")
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _GraphQLError.printError;
      }, "get")
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _syntaxError.syntaxError;
      }, "get")
    });
    var _GraphQLError = require_GraphQLError();
    var _syntaxError = require_syntaxError();
    var _locatedError = require_locatedError();
  }
});

// ../node_modules/graphql/utilities/getIntrospectionQuery.js
var require_getIntrospectionQuery = __commonJS({
  "../node_modules/graphql/utilities/getIntrospectionQuery.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getIntrospectionQuery = getIntrospectionQuery;
    function getIntrospectionQuery(options) {
      const optionsWithDefault = {
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false,
        oneOf: false,
        ...options
      };
      const descriptions = optionsWithDefault.descriptions ? "description" : "";
      const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
      const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
      const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
      function inputDeprecation(str) {
        return optionsWithDefault.inputValueDeprecation ? str : "";
      }
      __name(inputDeprecation, "inputDeprecation");
      const oneOf = optionsWithDefault.oneOf ? "isOneOf" : "";
      return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      ${oneOf}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    }
    __name(getIntrospectionQuery, "getIntrospectionQuery");
  }
});

// ../node_modules/graphql/utilities/getOperationAST.js
var require_getOperationAST = __commonJS({
  "../node_modules/graphql/utilities/getOperationAST.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationAST = getOperationAST2;
    var _kinds = require_kinds();
    function getOperationAST2(documentAST, operationName) {
      let operation = null;
      for (const definition of documentAST.definitions) {
        if (definition.kind === _kinds.Kind.OPERATION_DEFINITION) {
          var _definition$name;
          if (operationName == null) {
            if (operation) {
              return null;
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            return definition;
          }
        }
      }
      return operation;
    }
    __name(getOperationAST2, "getOperationAST");
  }
});

// ../node_modules/graphql/utilities/getOperationRootType.js
var require_getOperationRootType = __commonJS({
  "../node_modules/graphql/utilities/getOperationRootType.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getOperationRootType = getOperationRootType;
    var _GraphQLError = require_GraphQLError();
    function getOperationRootType(schema, operation) {
      if (operation.operation === "query") {
        const queryType = schema.getQueryType();
        if (!queryType) {
          throw new _GraphQLError.GraphQLError(
            "Schema does not define the required query root type.",
            {
              nodes: operation
            }
          );
        }
        return queryType;
      }
      if (operation.operation === "mutation") {
        const mutationType = schema.getMutationType();
        if (!mutationType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for mutations.",
            {
              nodes: operation
            }
          );
        }
        return mutationType;
      }
      if (operation.operation === "subscription") {
        const subscriptionType = schema.getSubscriptionType();
        if (!subscriptionType) {
          throw new _GraphQLError.GraphQLError(
            "Schema is not configured for subscriptions.",
            {
              nodes: operation
            }
          );
        }
        return subscriptionType;
      }
      throw new _GraphQLError.GraphQLError(
        "Can only have query, mutation and subscription operations.",
        {
          nodes: operation
        }
      );
    }
    __name(getOperationRootType, "getOperationRootType");
  }
});

// ../node_modules/graphql/utilities/introspectionFromSchema.js
var require_introspectionFromSchema = __commonJS({
  "../node_modules/graphql/utilities/introspectionFromSchema.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.introspectionFromSchema = introspectionFromSchema;
    var _invariant = require_invariant();
    var _parser = require_parser();
    var _execute = require_execute();
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    function introspectionFromSchema(schema, options) {
      const optionsWithDefaults = {
        specifiedByUrl: true,
        directiveIsRepeatable: true,
        schemaDescription: true,
        inputValueDeprecation: true,
        oneOf: true,
        ...options
      };
      const document = (0, _parser.parse)(
        (0, _getIntrospectionQuery.getIntrospectionQuery)(optionsWithDefaults)
      );
      const result = (0, _execute.executeSync)({
        schema,
        document
      });
      !result.errors && result.data || (0, _invariant.invariant)(false);
      return result.data;
    }
    __name(introspectionFromSchema, "introspectionFromSchema");
  }
});

// ../node_modules/graphql/utilities/buildClientSchema.js
var require_buildClientSchema = __commonJS({
  "../node_modules/graphql/utilities/buildClientSchema.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildClientSchema = buildClientSchema;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _isObjectLike = require_isObjectLike();
    var _keyValMap = require_keyValMap();
    var _parser = require_parser();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _valueFromAST = require_valueFromAST();
    function buildClientSchema(introspection, options) {
      (0, _isObjectLike.isObjectLike)(introspection) && (0, _isObjectLike.isObjectLike)(introspection.__schema) || (0, _devAssert.devAssert)(
        false,
        `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, _inspect.inspect)(introspection)}.`
      );
      const schemaIntrospection = introspection.__schema;
      const typeMap = (0, _keyValMap.keyValMap)(
        schemaIntrospection.types,
        (typeIntrospection) => typeIntrospection.name,
        (typeIntrospection) => buildType(typeIntrospection)
      );
      for (const stdType of [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ]) {
        if (typeMap[stdType.name]) {
          typeMap[stdType.name] = stdType;
        }
      }
      const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
      const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
      const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
      const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
      return new _schema.GraphQLSchema({
        description: schemaIntrospection.description,
        query: queryType,
        mutation: mutationType,
        subscription: subscriptionType,
        types: Object.values(typeMap),
        directives,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
      function getType(typeRef) {
        if (typeRef.kind === _introspection.TypeKind.LIST) {
          const itemRef = typeRef.ofType;
          if (!itemRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new _definition.GraphQLList(getType(itemRef));
        }
        if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
          const nullableRef = typeRef.ofType;
          if (!nullableRef) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          const nullableType = getType(nullableRef);
          return new _definition.GraphQLNonNull(
            (0, _definition.assertNullableType)(nullableType)
          );
        }
        return getNamedType6(typeRef);
      }
      __name(getType, "getType");
      function getNamedType6(typeRef) {
        const typeName = typeRef.name;
        if (!typeName) {
          throw new Error(
            `Unknown type reference: ${(0, _inspect.inspect)(typeRef)}.`
          );
        }
        const type2 = typeMap[typeName];
        if (!type2) {
          throw new Error(
            `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
          );
        }
        return type2;
      }
      __name(getNamedType6, "getNamedType");
      function getObjectType(typeRef) {
        return (0, _definition.assertObjectType)(getNamedType6(typeRef));
      }
      __name(getObjectType, "getObjectType");
      function getInterfaceType(typeRef) {
        return (0, _definition.assertInterfaceType)(getNamedType6(typeRef));
      }
      __name(getInterfaceType, "getInterfaceType");
      function buildType(type2) {
        if (type2 != null && type2.name != null && type2.kind != null) {
          switch (type2.kind) {
            case _introspection.TypeKind.SCALAR:
              return buildScalarDef(type2);
            case _introspection.TypeKind.OBJECT:
              return buildObjectDef(type2);
            case _introspection.TypeKind.INTERFACE:
              return buildInterfaceDef(type2);
            case _introspection.TypeKind.UNION:
              return buildUnionDef(type2);
            case _introspection.TypeKind.ENUM:
              return buildEnumDef(type2);
            case _introspection.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(type2);
          }
        }
        const typeStr = (0, _inspect.inspect)(type2);
        throw new Error(
          `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
        );
      }
      __name(buildType, "buildType");
      function buildScalarDef(scalarIntrospection) {
        return new _definition.GraphQLScalarType({
          name: scalarIntrospection.name,
          description: scalarIntrospection.description,
          specifiedByURL: scalarIntrospection.specifiedByURL
        });
      }
      __name(buildScalarDef, "buildScalarDef");
      function buildImplementationsList(implementingIntrospection) {
        if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === _introspection.TypeKind.INTERFACE) {
          return [];
        }
        if (!implementingIntrospection.interfaces) {
          const implementingIntrospectionStr = (0, _inspect.inspect)(
            implementingIntrospection
          );
          throw new Error(
            `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
          );
        }
        return implementingIntrospection.interfaces.map(getInterfaceType);
      }
      __name(buildImplementationsList, "buildImplementationsList");
      function buildObjectDef(objectIntrospection) {
        return new _definition.GraphQLObjectType({
          name: objectIntrospection.name,
          description: objectIntrospection.description,
          interfaces: /* @__PURE__ */ __name(() => buildImplementationsList(objectIntrospection), "interfaces"),
          fields: /* @__PURE__ */ __name(() => buildFieldDefMap(objectIntrospection), "fields")
        });
      }
      __name(buildObjectDef, "buildObjectDef");
      function buildInterfaceDef(interfaceIntrospection) {
        return new _definition.GraphQLInterfaceType({
          name: interfaceIntrospection.name,
          description: interfaceIntrospection.description,
          interfaces: /* @__PURE__ */ __name(() => buildImplementationsList(interfaceIntrospection), "interfaces"),
          fields: /* @__PURE__ */ __name(() => buildFieldDefMap(interfaceIntrospection), "fields")
        });
      }
      __name(buildInterfaceDef, "buildInterfaceDef");
      function buildUnionDef(unionIntrospection) {
        if (!unionIntrospection.possibleTypes) {
          const unionIntrospectionStr = (0, _inspect.inspect)(unionIntrospection);
          throw new Error(
            `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLUnionType({
          name: unionIntrospection.name,
          description: unionIntrospection.description,
          types: /* @__PURE__ */ __name(() => unionIntrospection.possibleTypes.map(getObjectType), "types")
        });
      }
      __name(buildUnionDef, "buildUnionDef");
      function buildEnumDef(enumIntrospection) {
        if (!enumIntrospection.enumValues) {
          const enumIntrospectionStr = (0, _inspect.inspect)(enumIntrospection);
          throw new Error(
            `Introspection result missing enumValues: ${enumIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLEnumType({
          name: enumIntrospection.name,
          description: enumIntrospection.description,
          values: (0, _keyValMap.keyValMap)(
            enumIntrospection.enumValues,
            (valueIntrospection) => valueIntrospection.name,
            (valueIntrospection) => ({
              description: valueIntrospection.description,
              deprecationReason: valueIntrospection.deprecationReason
            })
          )
        });
      }
      __name(buildEnumDef, "buildEnumDef");
      function buildInputObjectDef(inputObjectIntrospection) {
        if (!inputObjectIntrospection.inputFields) {
          const inputObjectIntrospectionStr = (0, _inspect.inspect)(
            inputObjectIntrospection
          );
          throw new Error(
            `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
          );
        }
        return new _definition.GraphQLInputObjectType({
          name: inputObjectIntrospection.name,
          description: inputObjectIntrospection.description,
          fields: /* @__PURE__ */ __name(() => buildInputValueDefMap(inputObjectIntrospection.inputFields), "fields"),
          isOneOf: inputObjectIntrospection.isOneOf
        });
      }
      __name(buildInputObjectDef, "buildInputObjectDef");
      function buildFieldDefMap(typeIntrospection) {
        if (!typeIntrospection.fields) {
          throw new Error(
            `Introspection result missing fields: ${(0, _inspect.inspect)(
              typeIntrospection
            )}.`
          );
        }
        return (0, _keyValMap.keyValMap)(
          typeIntrospection.fields,
          (fieldIntrospection) => fieldIntrospection.name,
          buildField
        );
      }
      __name(buildFieldDefMap, "buildFieldDefMap");
      function buildField(fieldIntrospection) {
        const type2 = getType(fieldIntrospection.type);
        if (!(0, _definition.isOutputType)(type2)) {
          const typeStr = (0, _inspect.inspect)(type2);
          throw new Error(
            `Introspection must provide output type for fields, but received: ${typeStr}.`
          );
        }
        if (!fieldIntrospection.args) {
          const fieldIntrospectionStr = (0, _inspect.inspect)(fieldIntrospection);
          throw new Error(
            `Introspection result missing field args: ${fieldIntrospectionStr}.`
          );
        }
        return {
          description: fieldIntrospection.description,
          deprecationReason: fieldIntrospection.deprecationReason,
          type: type2,
          args: buildInputValueDefMap(fieldIntrospection.args)
        };
      }
      __name(buildField, "buildField");
      function buildInputValueDefMap(inputValueIntrospections) {
        return (0, _keyValMap.keyValMap)(
          inputValueIntrospections,
          (inputValue) => inputValue.name,
          buildInputValue
        );
      }
      __name(buildInputValueDefMap, "buildInputValueDefMap");
      function buildInputValue(inputValueIntrospection) {
        const type2 = getType(inputValueIntrospection.type);
        if (!(0, _definition.isInputType)(type2)) {
          const typeStr = (0, _inspect.inspect)(type2);
          throw new Error(
            `Introspection must provide input type for arguments, but received: ${typeStr}.`
          );
        }
        const defaultValue = inputValueIntrospection.defaultValue != null ? (0, _valueFromAST.valueFromAST)(
          (0, _parser.parseValue)(inputValueIntrospection.defaultValue),
          type2
        ) : void 0;
        return {
          description: inputValueIntrospection.description,
          type: type2,
          defaultValue,
          deprecationReason: inputValueIntrospection.deprecationReason
        };
      }
      __name(buildInputValue, "buildInputValue");
      function buildDirective(directiveIntrospection) {
        if (!directiveIntrospection.args) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive args: ${directiveIntrospectionStr}.`
          );
        }
        if (!directiveIntrospection.locations) {
          const directiveIntrospectionStr = (0, _inspect.inspect)(
            directiveIntrospection
          );
          throw new Error(
            `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
          );
        }
        return new _directives.GraphQLDirective({
          name: directiveIntrospection.name,
          description: directiveIntrospection.description,
          isRepeatable: directiveIntrospection.isRepeatable,
          locations: directiveIntrospection.locations.slice(),
          args: buildInputValueDefMap(directiveIntrospection.args)
        });
      }
      __name(buildDirective, "buildDirective");
    }
    __name(buildClientSchema, "buildClientSchema");
  }
});

// ../node_modules/graphql/utilities/extendSchema.js
var require_extendSchema = __commonJS({
  "../node_modules/graphql/utilities/extendSchema.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extendSchema = extendSchema;
    exports2.extendSchemaImpl = extendSchemaImpl;
    var _devAssert = require_devAssert();
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _mapValue = require_mapValue();
    var _kinds = require_kinds();
    var _predicates = require_predicates();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _values = require_values();
    var _valueFromAST = require_valueFromAST();
    function extendSchema(schema, documentAST, options) {
      (0, _schema.assertSchema)(schema);
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDLExtension)(documentAST, schema);
      }
      const schemaConfig = schema.toConfig();
      const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
      return schemaConfig === extendedConfig ? schema : new _schema.GraphQLSchema(extendedConfig);
    }
    __name(extendSchema, "extendSchema");
    function extendSchemaImpl(schemaConfig, documentAST, options) {
      var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
      const typeDefs2 = [];
      const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
      const directiveDefs = [];
      let schemaDef;
      const schemaExtensions = [];
      for (const def of documentAST.definitions) {
        if (def.kind === _kinds.Kind.SCHEMA_DEFINITION) {
          schemaDef = def;
        } else if (def.kind === _kinds.Kind.SCHEMA_EXTENSION) {
          schemaExtensions.push(def);
        } else if ((0, _predicates.isTypeDefinitionNode)(def)) {
          typeDefs2.push(def);
        } else if ((0, _predicates.isTypeExtensionNode)(def)) {
          const extendedTypeName = def.name.value;
          const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
          typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
        } else if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
          directiveDefs.push(def);
        }
      }
      if (Object.keys(typeExtensionsMap).length === 0 && typeDefs2.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
        return schemaConfig;
      }
      const typeMap = /* @__PURE__ */ Object.create(null);
      for (const existingType of schemaConfig.types) {
        typeMap[existingType.name] = extendNamedType(existingType);
      }
      for (const typeNode of typeDefs2) {
        var _stdTypeMap$name;
        const name = typeNode.name.value;
        typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
      }
      const operationTypes = {
        // Get the extended root operation types.
        query: schemaConfig.query && replaceNamedType(schemaConfig.query),
        mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
        subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
        // Then, incorporate schema definition and all schema extensions.
        ...schemaDef && getOperationTypes([schemaDef]),
        ...getOperationTypes(schemaExtensions)
      };
      return {
        description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
        ...operationTypes,
        types: Object.values(typeMap),
        directives: [
          ...schemaConfig.directives.map(replaceDirective),
          ...directiveDefs.map(buildDirective)
        ],
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
        extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
        assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
      };
      function replaceType(type2) {
        if ((0, _definition.isListType)(type2)) {
          return new _definition.GraphQLList(replaceType(type2.ofType));
        }
        if ((0, _definition.isNonNullType)(type2)) {
          return new _definition.GraphQLNonNull(replaceType(type2.ofType));
        }
        return replaceNamedType(type2);
      }
      __name(replaceType, "replaceType");
      function replaceNamedType(type2) {
        return typeMap[type2.name];
      }
      __name(replaceNamedType, "replaceNamedType");
      function replaceDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          args: (0, _mapValue.mapValue)(config2.args, extendArg)
        });
      }
      __name(replaceDirective, "replaceDirective");
      function extendNamedType(type2) {
        if ((0, _introspection.isIntrospectionType)(type2) || (0, _scalars.isSpecifiedScalarType)(type2)) {
          return type2;
        }
        if ((0, _definition.isScalarType)(type2)) {
          return extendScalarType(type2);
        }
        if ((0, _definition.isObjectType)(type2)) {
          return extendObjectType(type2);
        }
        if ((0, _definition.isInterfaceType)(type2)) {
          return extendInterfaceType(type2);
        }
        if ((0, _definition.isUnionType)(type2)) {
          return extendUnionType(type2);
        }
        if ((0, _definition.isEnumType)(type2)) {
          return extendEnumType(type2);
        }
        if ((0, _definition.isInputObjectType)(type2)) {
          return extendInputObjectType(type2);
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type2)
        );
      }
      __name(extendNamedType, "extendNamedType");
      function extendInputObjectType(type2) {
        var _typeExtensionsMap$co;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
        return new _definition.GraphQLInputObjectType({
          ...config2,
          fields: /* @__PURE__ */ __name(() => ({
            ...(0, _mapValue.mapValue)(config2.fields, (field) => ({
              ...field,
              type: replaceType(field.type)
            })),
            ...buildInputFieldMap(extensions)
          }), "fields"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendInputObjectType, "extendInputObjectType");
      function extendEnumType(type2) {
        var _typeExtensionsMap$ty;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
        return new _definition.GraphQLEnumType({
          ...config2,
          values: { ...config2.values, ...buildEnumValueMap(extensions) },
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendEnumType, "extendEnumType");
      function extendScalarType(type2) {
        var _typeExtensionsMap$co2;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
        let specifiedByURL = config2.specifiedByURL;
        for (const extensionNode of extensions) {
          var _getSpecifiedByURL;
          specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
        }
        return new _definition.GraphQLScalarType({
          ...config2,
          specifiedByURL,
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendScalarType, "extendScalarType");
      function extendObjectType(type2) {
        var _typeExtensionsMap$co3;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
        return new _definition.GraphQLObjectType({
          ...config2,
          interfaces: /* @__PURE__ */ __name(() => [
            ...type2.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ], "interfaces"),
          fields: /* @__PURE__ */ __name(() => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }), "fields"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendObjectType, "extendObjectType");
      function extendInterfaceType(type2) {
        var _typeExtensionsMap$co4;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
        return new _definition.GraphQLInterfaceType({
          ...config2,
          interfaces: /* @__PURE__ */ __name(() => [
            ...type2.getInterfaces().map(replaceNamedType),
            ...buildInterfaces(extensions)
          ], "interfaces"),
          fields: /* @__PURE__ */ __name(() => ({
            ...(0, _mapValue.mapValue)(config2.fields, extendField),
            ...buildFieldMap(extensions)
          }), "fields"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendInterfaceType, "extendInterfaceType");
      function extendUnionType(type2) {
        var _typeExtensionsMap$co5;
        const config2 = type2.toConfig();
        const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
        return new _definition.GraphQLUnionType({
          ...config2,
          types: /* @__PURE__ */ __name(() => [
            ...type2.getTypes().map(replaceNamedType),
            ...buildUnionTypes(extensions)
          ], "types"),
          extensionASTNodes: config2.extensionASTNodes.concat(extensions)
        });
      }
      __name(extendUnionType, "extendUnionType");
      function extendField(field) {
        return {
          ...field,
          type: replaceType(field.type),
          args: field.args && (0, _mapValue.mapValue)(field.args, extendArg)
        };
      }
      __name(extendField, "extendField");
      function extendArg(arg) {
        return { ...arg, type: replaceType(arg.type) };
      }
      __name(extendArg, "extendArg");
      function getOperationTypes(nodes) {
        const opTypes = {};
        for (const node of nodes) {
          var _node$operationTypes;
          const operationTypesNodes = (
            /* c8 ignore next */
            (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
          );
          for (const operationType of operationTypesNodes) {
            opTypes[operationType.operation] = getNamedType6(operationType.type);
          }
        }
        return opTypes;
      }
      __name(getOperationTypes, "getOperationTypes");
      function getNamedType6(node) {
        var _stdTypeMap$name2;
        const name = node.name.value;
        const type2 = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
        if (type2 === void 0) {
          throw new Error(`Unknown type: "${name}".`);
        }
        return type2;
      }
      __name(getNamedType6, "getNamedType");
      function getWrappedType(node) {
        if (node.kind === _kinds.Kind.LIST_TYPE) {
          return new _definition.GraphQLList(getWrappedType(node.type));
        }
        if (node.kind === _kinds.Kind.NON_NULL_TYPE) {
          return new _definition.GraphQLNonNull(getWrappedType(node.type));
        }
        return getNamedType6(node);
      }
      __name(getWrappedType, "getWrappedType");
      function buildDirective(node) {
        var _node$description;
        return new _directives.GraphQLDirective({
          name: node.name.value,
          description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
          // @ts-expect-error
          locations: node.locations.map(({ value }) => value),
          isRepeatable: node.repeatable,
          args: buildArgumentMap(node.arguments),
          astNode: node
        });
      }
      __name(buildDirective, "buildDirective");
      function buildFieldMap(nodes) {
        const fieldConfigMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields;
          const nodeFields = (
            /* c8 ignore next */
            (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
          );
          for (const field of nodeFields) {
            var _field$description;
            fieldConfigMap[field.name.value] = {
              // Note: While this could make assertions to get the correctly typed
              // value, that would throw immediately while type system validation
              // with validateSchema() will produce more actionable results.
              type: getWrappedType(field.type),
              description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
              args: buildArgumentMap(field.arguments),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return fieldConfigMap;
      }
      __name(buildFieldMap, "buildFieldMap");
      function buildArgumentMap(args) {
        const argsNodes = (
          /* c8 ignore next */
          args !== null && args !== void 0 ? args : []
        );
        const argConfigMap = /* @__PURE__ */ Object.create(null);
        for (const arg of argsNodes) {
          var _arg$description;
          const type2 = getWrappedType(arg.type);
          argConfigMap[arg.name.value] = {
            type: type2,
            description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
            defaultValue: (0, _valueFromAST.valueFromAST)(arg.defaultValue, type2),
            deprecationReason: getDeprecationReason(arg),
            astNode: arg
          };
        }
        return argConfigMap;
      }
      __name(buildArgumentMap, "buildArgumentMap");
      function buildInputFieldMap(nodes) {
        const inputFieldMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$fields2;
          const fieldsNodes = (
            /* c8 ignore next */
            (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
          );
          for (const field of fieldsNodes) {
            var _field$description2;
            const type2 = getWrappedType(field.type);
            inputFieldMap[field.name.value] = {
              type: type2,
              description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
              defaultValue: (0, _valueFromAST.valueFromAST)(
                field.defaultValue,
                type2
              ),
              deprecationReason: getDeprecationReason(field),
              astNode: field
            };
          }
        }
        return inputFieldMap;
      }
      __name(buildInputFieldMap, "buildInputFieldMap");
      function buildEnumValueMap(nodes) {
        const enumValueMap = /* @__PURE__ */ Object.create(null);
        for (const node of nodes) {
          var _node$values;
          const valuesNodes = (
            /* c8 ignore next */
            (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
          );
          for (const value of valuesNodes) {
            var _value$description;
            enumValueMap[value.name.value] = {
              description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
              deprecationReason: getDeprecationReason(value),
              astNode: value
            };
          }
        }
        return enumValueMap;
      }
      __name(buildEnumValueMap, "buildEnumValueMap");
      function buildInterfaces(nodes) {
        return nodes.flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (node) => {
            var _node$interfaces$map, _node$interfaces;
            return (
              /* c8 ignore next */
              (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType6)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
            );
          }
        );
      }
      __name(buildInterfaces, "buildInterfaces");
      function buildUnionTypes(nodes) {
        return nodes.flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (node) => {
            var _node$types$map, _node$types;
            return (
              /* c8 ignore next */
              (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType6)) !== null && _node$types$map !== void 0 ? _node$types$map : []
            );
          }
        );
      }
      __name(buildUnionTypes, "buildUnionTypes");
      function buildType(astNode) {
        var _typeExtensionsMap$na;
        const name = astNode.name.value;
        const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
        switch (astNode.kind) {
          case _kinds.Kind.OBJECT_TYPE_DEFINITION: {
            var _astNode$description;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLObjectType({
              name,
              description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
              interfaces: /* @__PURE__ */ __name(() => buildInterfaces(allNodes), "interfaces"),
              fields: /* @__PURE__ */ __name(() => buildFieldMap(allNodes), "fields"),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION: {
            var _astNode$description2;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInterfaceType({
              name,
              description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
              interfaces: /* @__PURE__ */ __name(() => buildInterfaces(allNodes), "interfaces"),
              fields: /* @__PURE__ */ __name(() => buildFieldMap(allNodes), "fields"),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.ENUM_TYPE_DEFINITION: {
            var _astNode$description3;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLEnumType({
              name,
              description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
              values: buildEnumValueMap(allNodes),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.UNION_TYPE_DEFINITION: {
            var _astNode$description4;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLUnionType({
              name,
              description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
              types: /* @__PURE__ */ __name(() => buildUnionTypes(allNodes), "types"),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.SCALAR_TYPE_DEFINITION: {
            var _astNode$description5;
            return new _definition.GraphQLScalarType({
              name,
              description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
              specifiedByURL: getSpecifiedByURL(astNode),
              astNode,
              extensionASTNodes
            });
          }
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var _astNode$description6;
            const allNodes = [astNode, ...extensionASTNodes];
            return new _definition.GraphQLInputObjectType({
              name,
              description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
              fields: /* @__PURE__ */ __name(() => buildInputFieldMap(allNodes), "fields"),
              astNode,
              extensionASTNodes,
              isOneOf: isOneOf(astNode)
            });
          }
        }
      }
      __name(buildType, "buildType");
    }
    __name(extendSchemaImpl, "extendSchemaImpl");
    var stdTypeMap = (0, _keyMap.keyMap)(
      [..._scalars.specifiedScalarTypes, ..._introspection.introspectionTypes],
      (type2) => type2.name
    );
    function getDeprecationReason(node) {
      const deprecated = (0, _values.getDirectiveValues)(
        _directives.GraphQLDeprecatedDirective,
        node
      );
      return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
    }
    __name(getDeprecationReason, "getDeprecationReason");
    function getSpecifiedByURL(node) {
      const specifiedBy = (0, _values.getDirectiveValues)(
        _directives.GraphQLSpecifiedByDirective,
        node
      );
      return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
    }
    __name(getSpecifiedByURL, "getSpecifiedByURL");
    function isOneOf(node) {
      return Boolean(
        (0, _values.getDirectiveValues)(_directives.GraphQLOneOfDirective, node)
      );
    }
    __name(isOneOf, "isOneOf");
  }
});

// ../node_modules/graphql/utilities/buildASTSchema.js
var require_buildASTSchema = __commonJS({
  "../node_modules/graphql/utilities/buildASTSchema.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildASTSchema = buildASTSchema2;
    exports2.buildSchema = buildSchema3;
    var _devAssert = require_devAssert();
    var _kinds = require_kinds();
    var _parser = require_parser();
    var _directives = require_directives();
    var _schema = require_schema();
    var _validate = require_validate2();
    var _extendSchema = require_extendSchema();
    function buildASTSchema2(documentAST, options) {
      documentAST != null && documentAST.kind === _kinds.Kind.DOCUMENT || (0, _devAssert.devAssert)(false, "Must provide valid Document AST.");
      if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
        (0, _validate.assertValidSDL)(documentAST);
      }
      const emptySchemaConfig = {
        description: void 0,
        types: [],
        directives: [],
        extensions: /* @__PURE__ */ Object.create(null),
        extensionASTNodes: [],
        assumeValid: false
      };
      const config2 = (0, _extendSchema.extendSchemaImpl)(
        emptySchemaConfig,
        documentAST,
        options
      );
      if (config2.astNode == null) {
        for (const type2 of config2.types) {
          switch (type2.name) {
            // Note: While this could make early assertions to get the correctly
            // typed values below, that would throw immediately while type system
            // validation with validateSchema() will produce more actionable results.
            case "Query":
              config2.query = type2;
              break;
            case "Mutation":
              config2.mutation = type2;
              break;
            case "Subscription":
              config2.subscription = type2;
              break;
          }
        }
      }
      const directives = [
        ...config2.directives,
        // If specified directives were not explicitly declared, add them.
        ..._directives.specifiedDirectives.filter(
          (stdDirective) => config2.directives.every(
            (directive) => directive.name !== stdDirective.name
          )
        )
      ];
      return new _schema.GraphQLSchema({ ...config2, directives });
    }
    __name(buildASTSchema2, "buildASTSchema");
    function buildSchema3(source, options) {
      const document = (0, _parser.parse)(source, {
        noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
        allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
      });
      return buildASTSchema2(document, {
        assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
        assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
      });
    }
    __name(buildSchema3, "buildSchema");
  }
});

// ../node_modules/graphql/utilities/lexicographicSortSchema.js
var require_lexicographicSortSchema = __commonJS({
  "../node_modules/graphql/utilities/lexicographicSortSchema.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.lexicographicSortSchema = lexicographicSortSchema;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyValMap = require_keyValMap();
    var _naturalCompare = require_naturalCompare();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _schema = require_schema();
    function lexicographicSortSchema(schema) {
      const schemaConfig = schema.toConfig();
      const typeMap = (0, _keyValMap.keyValMap)(
        sortByName(schemaConfig.types),
        (type2) => type2.name,
        sortNamedType
      );
      return new _schema.GraphQLSchema({
        ...schemaConfig,
        types: Object.values(typeMap),
        directives: sortByName(schemaConfig.directives).map(sortDirective),
        query: replaceMaybeType(schemaConfig.query),
        mutation: replaceMaybeType(schemaConfig.mutation),
        subscription: replaceMaybeType(schemaConfig.subscription)
      });
      function replaceType(type2) {
        if ((0, _definition.isListType)(type2)) {
          return new _definition.GraphQLList(replaceType(type2.ofType));
        } else if ((0, _definition.isNonNullType)(type2)) {
          return new _definition.GraphQLNonNull(replaceType(type2.ofType));
        }
        return replaceNamedType(type2);
      }
      __name(replaceType, "replaceType");
      function replaceNamedType(type2) {
        return typeMap[type2.name];
      }
      __name(replaceNamedType, "replaceNamedType");
      function replaceMaybeType(maybeType) {
        return maybeType && replaceNamedType(maybeType);
      }
      __name(replaceMaybeType, "replaceMaybeType");
      function sortDirective(directive) {
        const config2 = directive.toConfig();
        return new _directives.GraphQLDirective({
          ...config2,
          locations: sortBy(config2.locations, (x) => x),
          args: sortArgs(config2.args)
        });
      }
      __name(sortDirective, "sortDirective");
      function sortArgs(args) {
        return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
      }
      __name(sortArgs, "sortArgs");
      function sortFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type),
          args: field.args && sortArgs(field.args)
        }));
      }
      __name(sortFields, "sortFields");
      function sortInputFields(fieldsMap) {
        return sortObjMap(fieldsMap, (field) => ({
          ...field,
          type: replaceType(field.type)
        }));
      }
      __name(sortInputFields, "sortInputFields");
      function sortTypes(array) {
        return sortByName(array).map(replaceNamedType);
      }
      __name(sortTypes, "sortTypes");
      function sortNamedType(type2) {
        if ((0, _definition.isScalarType)(type2) || (0, _introspection.isIntrospectionType)(type2)) {
          return type2;
        }
        if ((0, _definition.isObjectType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLObjectType({
            ...config2,
            interfaces: /* @__PURE__ */ __name(() => sortTypes(config2.interfaces), "interfaces"),
            fields: /* @__PURE__ */ __name(() => sortFields(config2.fields), "fields")
          });
        }
        if ((0, _definition.isInterfaceType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLInterfaceType({
            ...config2,
            interfaces: /* @__PURE__ */ __name(() => sortTypes(config2.interfaces), "interfaces"),
            fields: /* @__PURE__ */ __name(() => sortFields(config2.fields), "fields")
          });
        }
        if ((0, _definition.isUnionType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLUnionType({
            ...config2,
            types: /* @__PURE__ */ __name(() => sortTypes(config2.types), "types")
          });
        }
        if ((0, _definition.isEnumType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLEnumType({
            ...config2,
            values: sortObjMap(config2.values, (value) => value)
          });
        }
        if ((0, _definition.isInputObjectType)(type2)) {
          const config2 = type2.toConfig();
          return new _definition.GraphQLInputObjectType({
            ...config2,
            fields: /* @__PURE__ */ __name(() => sortInputFields(config2.fields), "fields")
          });
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type2)
        );
      }
      __name(sortNamedType, "sortNamedType");
    }
    __name(lexicographicSortSchema, "lexicographicSortSchema");
    function sortObjMap(map, sortValueFn) {
      const sortedMap = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(map).sort(_naturalCompare.naturalCompare)) {
        sortedMap[key] = sortValueFn(map[key]);
      }
      return sortedMap;
    }
    __name(sortObjMap, "sortObjMap");
    function sortByName(array) {
      return sortBy(array, (obj) => obj.name);
    }
    __name(sortByName, "sortByName");
    function sortBy(array, mapToKey) {
      return array.slice().sort((obj1, obj2) => {
        const key1 = mapToKey(obj1);
        const key2 = mapToKey(obj2);
        return (0, _naturalCompare.naturalCompare)(key1, key2);
      });
    }
    __name(sortBy, "sortBy");
  }
});

// ../node_modules/graphql/utilities/printSchema.js
var require_printSchema = __commonJS({
  "../node_modules/graphql/utilities/printSchema.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printIntrospectionSchema = printIntrospectionSchema;
    exports2.printSchema = printSchema4;
    exports2.printType = printType;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _blockString = require_blockString();
    var _kinds = require_kinds();
    var _printer = require_printer();
    var _definition = require_definition();
    var _directives = require_directives();
    var _introspection = require_introspection();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    function printSchema4(schema) {
      return printFilteredSchema(
        schema,
        (n) => !(0, _directives.isSpecifiedDirective)(n),
        isDefinedType
      );
    }
    __name(printSchema4, "printSchema");
    function printIntrospectionSchema(schema) {
      return printFilteredSchema(
        schema,
        _directives.isSpecifiedDirective,
        _introspection.isIntrospectionType
      );
    }
    __name(printIntrospectionSchema, "printIntrospectionSchema");
    function isDefinedType(type2) {
      return !(0, _scalars.isSpecifiedScalarType)(type2) && !(0, _introspection.isIntrospectionType)(type2);
    }
    __name(isDefinedType, "isDefinedType");
    function printFilteredSchema(schema, directiveFilter, typeFilter) {
      const directives = schema.getDirectives().filter(directiveFilter);
      const types3 = Object.values(schema.getTypeMap()).filter(typeFilter);
      return [
        printSchemaDefinition(schema),
        ...directives.map((directive) => printDirective(directive)),
        ...types3.map((type2) => printType(type2))
      ].filter(Boolean).join("\n\n");
    }
    __name(printFilteredSchema, "printFilteredSchema");
    function printSchemaDefinition(schema) {
      if (schema.description == null && isSchemaOfCommonNames(schema)) {
        return;
      }
      const operationTypes = [];
      const queryType = schema.getQueryType();
      if (queryType) {
        operationTypes.push(`  query: ${queryType.name}`);
      }
      const mutationType = schema.getMutationType();
      if (mutationType) {
        operationTypes.push(`  mutation: ${mutationType.name}`);
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType) {
        operationTypes.push(`  subscription: ${subscriptionType.name}`);
      }
      return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
    }
    __name(printSchemaDefinition, "printSchemaDefinition");
    function isSchemaOfCommonNames(schema) {
      const queryType = schema.getQueryType();
      if (queryType && queryType.name !== "Query") {
        return false;
      }
      const mutationType = schema.getMutationType();
      if (mutationType && mutationType.name !== "Mutation") {
        return false;
      }
      const subscriptionType = schema.getSubscriptionType();
      if (subscriptionType && subscriptionType.name !== "Subscription") {
        return false;
      }
      return true;
    }
    __name(isSchemaOfCommonNames, "isSchemaOfCommonNames");
    function printType(type2) {
      if ((0, _definition.isScalarType)(type2)) {
        return printScalar(type2);
      }
      if ((0, _definition.isObjectType)(type2)) {
        return printObject(type2);
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        return printInterface(type2);
      }
      if ((0, _definition.isUnionType)(type2)) {
        return printUnion(type2);
      }
      if ((0, _definition.isEnumType)(type2)) {
        return printEnum(type2);
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        return printInputObject(type2);
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(printType, "printType");
    function printScalar(type2) {
      return printDescription(type2) + `scalar ${type2.name}` + printSpecifiedByURL(type2);
    }
    __name(printScalar, "printScalar");
    function printImplementedInterfaces(type2) {
      const interfaces = type2.getInterfaces();
      return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
    }
    __name(printImplementedInterfaces, "printImplementedInterfaces");
    function printObject(type2) {
      return printDescription(type2) + `type ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
    }
    __name(printObject, "printObject");
    function printInterface(type2) {
      return printDescription(type2) + `interface ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
    }
    __name(printInterface, "printInterface");
    function printUnion(type2) {
      const types3 = type2.getTypes();
      const possibleTypes = types3.length ? " = " + types3.join(" | ") : "";
      return printDescription(type2) + "union " + type2.name + possibleTypes;
    }
    __name(printUnion, "printUnion");
    function printEnum(type2) {
      const values = type2.getValues().map(
        (value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason)
      );
      return printDescription(type2) + `enum ${type2.name}` + printBlock(values);
    }
    __name(printEnum, "printEnum");
    function printInputObject(type2) {
      const fields = Object.values(type2.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f)
      );
      return printDescription(type2) + `input ${type2.name}` + (type2.isOneOf ? " @oneOf" : "") + printBlock(fields);
    }
    __name(printInputObject, "printInputObject");
    function printFields(type2) {
      const fields = Object.values(type2.getFields()).map(
        (f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason)
      );
      return printBlock(fields);
    }
    __name(printFields, "printFields");
    function printBlock(items) {
      return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
    }
    __name(printBlock, "printBlock");
    function printArgs(args, indentation = "") {
      if (args.length === 0) {
        return "";
      }
      if (args.every((arg) => !arg.description)) {
        return "(" + args.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + args.map(
        (arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)
      ).join("\n") + "\n" + indentation + ")";
    }
    __name(printArgs, "printArgs");
    function printInputValue(arg) {
      const defaultAST = (0, _astFromValue.astFromValue)(
        arg.defaultValue,
        arg.type
      );
      let argDecl = arg.name + ": " + String(arg.type);
      if (defaultAST) {
        argDecl += ` = ${(0, _printer.print)(defaultAST)}`;
      }
      return argDecl + printDeprecated(arg.deprecationReason);
    }
    __name(printInputValue, "printInputValue");
    function printDirective(directive) {
      return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
    }
    __name(printDirective, "printDirective");
    function printDeprecated(reason) {
      if (reason == null) {
        return "";
      }
      if (reason !== _directives.DEFAULT_DEPRECATION_REASON) {
        const astValue = (0, _printer.print)({
          kind: _kinds.Kind.STRING,
          value: reason
        });
        return ` @deprecated(reason: ${astValue})`;
      }
      return " @deprecated";
    }
    __name(printDeprecated, "printDeprecated");
    function printSpecifiedByURL(scalar) {
      if (scalar.specifiedByURL == null) {
        return "";
      }
      const astValue = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: scalar.specifiedByURL
      });
      return ` @specifiedBy(url: ${astValue})`;
    }
    __name(printSpecifiedByURL, "printSpecifiedByURL");
    function printDescription(def, indentation = "", firstInBlock = true) {
      const { description } = def;
      if (description == null) {
        return "";
      }
      const blockString = (0, _printer.print)({
        kind: _kinds.Kind.STRING,
        value: description,
        block: (0, _blockString.isPrintableAsBlockString)(description)
      });
      const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
      return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
    }
    __name(printDescription, "printDescription");
  }
});

// ../node_modules/graphql/utilities/concatAST.js
var require_concatAST = __commonJS({
  "../node_modules/graphql/utilities/concatAST.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.concatAST = concatAST;
    var _kinds = require_kinds();
    function concatAST(documents) {
      const definitions = [];
      for (const doc of documents) {
        definitions.push(...doc.definitions);
      }
      return {
        kind: _kinds.Kind.DOCUMENT,
        definitions
      };
    }
    __name(concatAST, "concatAST");
  }
});

// ../node_modules/graphql/utilities/separateOperations.js
var require_separateOperations = __commonJS({
  "../node_modules/graphql/utilities/separateOperations.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.separateOperations = separateOperations;
    var _kinds = require_kinds();
    var _visitor = require_visitor();
    function separateOperations(documentAST) {
      const operations = [];
      const depGraph = /* @__PURE__ */ Object.create(null);
      for (const definitionNode of documentAST.definitions) {
        switch (definitionNode.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            operations.push(definitionNode);
            break;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            depGraph[definitionNode.name.value] = collectDependencies(
              definitionNode.selectionSet
            );
            break;
          default:
        }
      }
      const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
      for (const operation of operations) {
        const dependencies = /* @__PURE__ */ new Set();
        for (const fragmentName of collectDependencies(operation.selectionSet)) {
          collectTransitiveDependencies(dependencies, depGraph, fragmentName);
        }
        const operationName = operation.name ? operation.name.value : "";
        separatedDocumentASTs[operationName] = {
          kind: _kinds.Kind.DOCUMENT,
          definitions: documentAST.definitions.filter(
            (node) => node === operation || node.kind === _kinds.Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
          )
        };
      }
      return separatedDocumentASTs;
    }
    __name(separateOperations, "separateOperations");
    function collectTransitiveDependencies(collected, depGraph, fromName) {
      if (!collected.has(fromName)) {
        collected.add(fromName);
        const immediateDeps = depGraph[fromName];
        if (immediateDeps !== void 0) {
          for (const toName of immediateDeps) {
            collectTransitiveDependencies(collected, depGraph, toName);
          }
        }
      }
    }
    __name(collectTransitiveDependencies, "collectTransitiveDependencies");
    function collectDependencies(selectionSet) {
      const dependencies = [];
      (0, _visitor.visit)(selectionSet, {
        FragmentSpread(node) {
          dependencies.push(node.name.value);
        }
      });
      return dependencies;
    }
    __name(collectDependencies, "collectDependencies");
  }
});

// ../node_modules/graphql/utilities/stripIgnoredCharacters.js
var require_stripIgnoredCharacters = __commonJS({
  "../node_modules/graphql/utilities/stripIgnoredCharacters.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.stripIgnoredCharacters = stripIgnoredCharacters;
    var _blockString = require_blockString();
    var _lexer = require_lexer();
    var _source = require_source();
    var _tokenKind = require_tokenKind();
    function stripIgnoredCharacters(source) {
      const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
      const body = sourceObj.body;
      const lexer = new _lexer.Lexer(sourceObj);
      let strippedBody = "";
      let wasLastAddedTokenNonPunctuator = false;
      while (lexer.advance().kind !== _tokenKind.TokenKind.EOF) {
        const currentToken = lexer.token;
        const tokenKind = currentToken.kind;
        const isNonPunctuator = !(0, _lexer.isPunctuatorTokenKind)(
          currentToken.kind
        );
        if (wasLastAddedTokenNonPunctuator) {
          if (isNonPunctuator || currentToken.kind === _tokenKind.TokenKind.SPREAD) {
            strippedBody += " ";
          }
        }
        const tokenBody = body.slice(currentToken.start, currentToken.end);
        if (tokenKind === _tokenKind.TokenKind.BLOCK_STRING) {
          strippedBody += (0, _blockString.printBlockString)(currentToken.value, {
            minimize: true
          });
        } else {
          strippedBody += tokenBody;
        }
        wasLastAddedTokenNonPunctuator = isNonPunctuator;
      }
      return strippedBody;
    }
    __name(stripIgnoredCharacters, "stripIgnoredCharacters");
  }
});

// ../node_modules/graphql/utilities/assertValidName.js
var require_assertValidName = __commonJS({
  "../node_modules/graphql/utilities/assertValidName.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertValidName = assertValidName;
    exports2.isValidNameError = isValidNameError;
    var _devAssert = require_devAssert();
    var _GraphQLError = require_GraphQLError();
    var _assertName = require_assertName();
    function assertValidName(name) {
      const error3 = isValidNameError(name);
      if (error3) {
        throw error3;
      }
      return name;
    }
    __name(assertValidName, "assertValidName");
    function isValidNameError(name) {
      typeof name === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
      if (name.startsWith("__")) {
        return new _GraphQLError.GraphQLError(
          `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
        );
      }
      try {
        (0, _assertName.assertName)(name);
      } catch (error3) {
        return error3;
      }
    }
    __name(isValidNameError, "isValidNameError");
  }
});

// ../node_modules/graphql/utilities/findBreakingChanges.js
var require_findBreakingChanges = __commonJS({
  "../node_modules/graphql/utilities/findBreakingChanges.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DangerousChangeType = exports2.BreakingChangeType = void 0;
    exports2.findBreakingChanges = findBreakingChanges;
    exports2.findDangerousChanges = findDangerousChanges;
    var _inspect = require_inspect();
    var _invariant = require_invariant();
    var _keyMap = require_keyMap();
    var _printer = require_printer();
    var _definition = require_definition();
    var _scalars = require_scalars();
    var _astFromValue = require_astFromValue();
    var _sortValueNode = require_sortValueNode();
    var BreakingChangeType;
    exports2.BreakingChangeType = BreakingChangeType;
    (function(BreakingChangeType2) {
      BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
      BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
      BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
      BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(
      BreakingChangeType || (exports2.BreakingChangeType = BreakingChangeType = {})
    );
    var DangerousChangeType;
    exports2.DangerousChangeType = DangerousChangeType;
    (function(DangerousChangeType2) {
      DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(
      DangerousChangeType || (exports2.DangerousChangeType = DangerousChangeType = {})
    );
    function findBreakingChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in BreakingChangeType
      );
    }
    __name(findBreakingChanges, "findBreakingChanges");
    function findDangerousChanges(oldSchema, newSchema) {
      return findSchemaChanges(oldSchema, newSchema).filter(
        (change) => change.type in DangerousChangeType
      );
    }
    __name(findDangerousChanges, "findDangerousChanges");
    function findSchemaChanges(oldSchema, newSchema) {
      return [
        ...findTypeChanges(oldSchema, newSchema),
        ...findDirectiveChanges(oldSchema, newSchema)
      ];
    }
    __name(findSchemaChanges, "findSchemaChanges");
    function findDirectiveChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const directivesDiff = diff(
        oldSchema.getDirectives(),
        newSchema.getDirectives()
      );
      for (const oldDirective of directivesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REMOVED,
          description: `${oldDirective.name} was removed.`
        });
      }
      for (const [oldDirective, newDirective] of directivesDiff.persisted) {
        const argsDiff = diff(oldDirective.args, newDirective.args);
        for (const newArg of argsDiff.added) {
          if ((0, _definition.isRequiredArgument)(newArg)) {
            schemaChanges.push({
              type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
              description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
            });
          }
        }
        for (const oldArg of argsDiff.removed) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
            description: `${oldArg.name} was removed from ${oldDirective.name}.`
          });
        }
        if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
            description: `Repeatable flag was removed from ${oldDirective.name}.`
          });
        }
        for (const location of oldDirective.locations) {
          if (!newDirective.locations.includes(location)) {
            schemaChanges.push({
              type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
              description: `${location} was removed from ${oldDirective.name}.`
            });
          }
        }
      }
      return schemaChanges;
    }
    __name(findDirectiveChanges, "findDirectiveChanges");
    function findTypeChanges(oldSchema, newSchema) {
      const schemaChanges = [];
      const typesDiff = diff(
        Object.values(oldSchema.getTypeMap()),
        Object.values(newSchema.getTypeMap())
      );
      for (const oldType of typesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED,
          description: (0, _scalars.isSpecifiedScalarType)(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
        });
      }
      for (const [oldType, newType] of typesDiff.persisted) {
        if ((0, _definition.isEnumType)(oldType) && (0, _definition.isEnumType)(newType)) {
          schemaChanges.push(...findEnumTypeChanges(oldType, newType));
        } else if ((0, _definition.isUnionType)(oldType) && (0, _definition.isUnionType)(newType)) {
          schemaChanges.push(...findUnionTypeChanges(oldType, newType));
        } else if ((0, _definition.isInputObjectType)(oldType) && (0, _definition.isInputObjectType)(newType)) {
          schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
        } else if ((0, _definition.isObjectType)(oldType) && (0, _definition.isObjectType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if ((0, _definition.isInterfaceType)(oldType) && (0, _definition.isInterfaceType)(newType)) {
          schemaChanges.push(
            ...findFieldChanges(oldType, newType),
            ...findImplementedInterfacesChanges(oldType, newType)
          );
        } else if (oldType.constructor !== newType.constructor) {
          schemaChanges.push({
            type: BreakingChangeType.TYPE_CHANGED_KIND,
            description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findTypeChanges, "findTypeChanges");
    function findInputObjectTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const newField of fieldsDiff.added) {
        if ((0, _definition.isRequiredInputField)(newField)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
            description: `A required field ${newField.name} on input type ${oldType.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
            description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
          });
        }
      }
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findInputObjectTypeChanges, "findInputObjectTypeChanges");
    function findUnionTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
      for (const newPossibleType of possibleTypesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.TYPE_ADDED_TO_UNION,
          description: `${newPossibleType.name} was added to union type ${oldType.name}.`
        });
      }
      for (const oldPossibleType of possibleTypesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
          description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findUnionTypeChanges, "findUnionTypeChanges");
    function findEnumTypeChanges(oldType, newType) {
      const schemaChanges = [];
      const valuesDiff = diff(oldType.getValues(), newType.getValues());
      for (const newValue of valuesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
          description: `${newValue.name} was added to enum type ${oldType.name}.`
        });
      }
      for (const oldValue of valuesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
          description: `${oldValue.name} was removed from enum type ${oldType.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findEnumTypeChanges, "findEnumTypeChanges");
    function findImplementedInterfacesChanges(oldType, newType) {
      const schemaChanges = [];
      const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
      for (const newInterface of interfacesDiff.added) {
        schemaChanges.push({
          type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
          description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
        });
      }
      for (const oldInterface of interfacesDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
          description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
        });
      }
      return schemaChanges;
    }
    __name(findImplementedInterfacesChanges, "findImplementedInterfacesChanges");
    function findFieldChanges(oldType, newType) {
      const schemaChanges = [];
      const fieldsDiff = diff(
        Object.values(oldType.getFields()),
        Object.values(newType.getFields())
      );
      for (const oldField of fieldsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_REMOVED,
          description: `${oldType.name}.${oldField.name} was removed.`
        });
      }
      for (const [oldField, newField] of fieldsDiff.persisted) {
        schemaChanges.push(...findArgChanges(oldType, oldField, newField));
        const isSafe = isChangeSafeForObjectOrInterfaceField(
          oldField.type,
          newField.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.FIELD_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findFieldChanges, "findFieldChanges");
    function findArgChanges(oldType, oldField, newField) {
      const schemaChanges = [];
      const argsDiff = diff(oldField.args, newField.args);
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_REMOVED,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
        });
      }
      for (const [oldArg, newArg] of argsDiff.persisted) {
        const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
          oldArg.type,
          newArg.type
        );
        if (!isSafe) {
          schemaChanges.push({
            type: BreakingChangeType.ARG_CHANGED_KIND,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
          });
        } else if (oldArg.defaultValue !== void 0) {
          if (newArg.defaultValue === void 0) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
            });
          } else {
            const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
            const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
            if (oldValueStr !== newValueStr) {
              schemaChanges.push({
                type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
              });
            }
          }
        }
      }
      for (const newArg of argsDiff.added) {
        if ((0, _definition.isRequiredArgument)(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_ARG_ADDED,
            description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        } else {
          schemaChanges.push({
            type: DangerousChangeType.OPTIONAL_ARG_ADDED,
            description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
          });
        }
      }
      return schemaChanges;
    }
    __name(findArgChanges, "findArgChanges");
    function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (
          // if they're both lists, make sure the underlying types are compatible
          (0, _definition.isListType)(newType) && isChangeSafeForObjectOrInterfaceField(
            oldType.ofType,
            newType.ofType
          ) || // moving from nullable to non-null of the same underlying type is safe
          (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
        );
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
      }
      return (
        // if they're both named types, see if their names are equivalent
        (0, _definition.isNamedType)(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
        (0, _definition.isNonNullType)(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
      );
    }
    __name(isChangeSafeForObjectOrInterfaceField, "isChangeSafeForObjectOrInterfaceField");
    function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
      if ((0, _definition.isListType)(oldType)) {
        return (0, _definition.isListType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
      }
      if ((0, _definition.isNonNullType)(oldType)) {
        return (
          // if they're both non-null, make sure the underlying types are
          // compatible
          (0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
            oldType.ofType,
            newType.ofType
          ) || // moving from non-null to nullable of the same underlying type is safe
          !(0, _definition.isNonNullType)(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
        );
      }
      return (0, _definition.isNamedType)(newType) && oldType.name === newType.name;
    }
    __name(isChangeSafeForInputObjectFieldOrFieldArg, "isChangeSafeForInputObjectFieldOrFieldArg");
    function typeKindName(type2) {
      if ((0, _definition.isScalarType)(type2)) {
        return "a Scalar type";
      }
      if ((0, _definition.isObjectType)(type2)) {
        return "an Object type";
      }
      if ((0, _definition.isInterfaceType)(type2)) {
        return "an Interface type";
      }
      if ((0, _definition.isUnionType)(type2)) {
        return "a Union type";
      }
      if ((0, _definition.isEnumType)(type2)) {
        return "an Enum type";
      }
      if ((0, _definition.isInputObjectType)(type2)) {
        return "an Input type";
      }
      (0, _invariant.invariant)(
        false,
        "Unexpected type: " + (0, _inspect.inspect)(type2)
      );
    }
    __name(typeKindName, "typeKindName");
    function stringifyValue(value, type2) {
      const ast = (0, _astFromValue.astFromValue)(value, type2);
      ast != null || (0, _invariant.invariant)(false);
      return (0, _printer.print)((0, _sortValueNode.sortValueNode)(ast));
    }
    __name(stringifyValue, "stringifyValue");
    function diff(oldArray, newArray) {
      const added = [];
      const removed = [];
      const persisted = [];
      const oldMap = (0, _keyMap.keyMap)(oldArray, ({ name }) => name);
      const newMap = (0, _keyMap.keyMap)(newArray, ({ name }) => name);
      for (const oldItem of oldArray) {
        const newItem = newMap[oldItem.name];
        if (newItem === void 0) {
          removed.push(oldItem);
        } else {
          persisted.push([oldItem, newItem]);
        }
      }
      for (const newItem of newArray) {
        if (oldMap[newItem.name] === void 0) {
          added.push(newItem);
        }
      }
      return {
        added,
        persisted,
        removed
      };
    }
    __name(diff, "diff");
  }
});

// ../node_modules/graphql/utilities/index.js
var require_utilities = __commonJS({
  "../node_modules/graphql/utilities/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.BreakingChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.DangerousChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _TypeInfo.TypeInfo;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertValidName.assertValidName;
      }, "get")
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _astFromValue.astFromValue;
      }, "get")
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _buildASTSchema.buildASTSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _buildClientSchema.buildClientSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _buildASTSchema.buildSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _coerceInputValue.coerceInputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _concatAST.concatAST;
      }, "get")
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeComparators.doTypesOverlap;
      }, "get")
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _extendSchema.extendSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.findBreakingChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _findBreakingChanges.findDangerousChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _getIntrospectionQuery.getIntrospectionQuery;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _getOperationAST.getOperationAST;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _getOperationRootType.getOperationRootType;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _introspectionFromSchema.introspectionFromSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeComparators.isEqualType;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeComparators.isTypeSubTypeOf;
      }, "get")
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _assertValidName.isValidNameError;
      }, "get")
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _lexicographicSortSchema.lexicographicSortSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printSchema.printIntrospectionSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printSchema.printSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _printSchema.printType;
      }, "get")
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _separateOperations.separateOperations;
      }, "get")
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _stripIgnoredCharacters.stripIgnoredCharacters;
      }, "get")
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _typeFromAST.typeFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _valueFromAST.valueFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _valueFromASTUntyped.valueFromASTUntyped;
      }, "get")
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _TypeInfo.visitWithTypeInfo;
      }, "get")
    });
    var _getIntrospectionQuery = require_getIntrospectionQuery();
    var _getOperationAST = require_getOperationAST();
    var _getOperationRootType = require_getOperationRootType();
    var _introspectionFromSchema = require_introspectionFromSchema();
    var _buildClientSchema = require_buildClientSchema();
    var _buildASTSchema = require_buildASTSchema();
    var _extendSchema = require_extendSchema();
    var _lexicographicSortSchema = require_lexicographicSortSchema();
    var _printSchema = require_printSchema();
    var _typeFromAST = require_typeFromAST();
    var _valueFromAST = require_valueFromAST();
    var _valueFromASTUntyped = require_valueFromASTUntyped();
    var _astFromValue = require_astFromValue();
    var _TypeInfo = require_TypeInfo();
    var _coerceInputValue = require_coerceInputValue();
    var _concatAST = require_concatAST();
    var _separateOperations = require_separateOperations();
    var _stripIgnoredCharacters = require_stripIgnoredCharacters();
    var _typeComparators = require_typeComparators();
    var _assertValidName = require_assertValidName();
    var _findBreakingChanges = require_findBreakingChanges();
  }
});

// ../node_modules/graphql/index.js
var require_graphql2 = __commonJS({
  "../node_modules/graphql/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "BREAK", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.BREAK;
      }, "get")
    });
    Object.defineProperty(exports2, "BreakingChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.BreakingChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.DEFAULT_DEPRECATION_REASON;
      }, "get")
    });
    Object.defineProperty(exports2, "DangerousChangeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.DangerousChangeType;
      }, "get")
    });
    Object.defineProperty(exports2, "DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ExecutableDefinitionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.FieldsOnCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.FragmentsOnCompositeTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GRAPHQL_MAX_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GRAPHQL_MIN_INT;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLBoolean", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLBoolean;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLDeprecatedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.GraphQLError;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLFloat", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLFloat;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLID", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLID;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLIncludeDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLIncludeDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInt", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLInt;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLList", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLList;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLNonNull", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLNonNull;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLOneOfDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLOneOfDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSkipDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLSkipDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLSpecifiedByDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLString;
      }, "get")
    });
    Object.defineProperty(exports2, "GraphQLUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.GraphQLUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "Kind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Kind;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownDirectivesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownDirectivesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "KnownTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.KnownTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "Lexer", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Lexer;
      }, "get")
    });
    Object.defineProperty(exports2, "Location", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Location;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.LoneAnonymousOperationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.LoneSchemaDefinitionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "MaxIntrospectionDepthRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.MaxIntrospectionDepthRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoDeprecatedCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoFragmentCyclesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoFragmentCyclesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoSchemaIntrospectionCustomRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoUndefinedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoUnusedFragmentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "NoUnusedVariablesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.NoUnusedVariablesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "OperationTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.OperationTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.OverlappingFieldsCanBeMergedRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.PossibleFragmentSpreadsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.PossibleTypeExtensionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ProvidedRequiredArgumentsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ScalarLeafsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ScalarLeafsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "SchemaMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.SchemaMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.SingleFieldSubscriptionsRule;
      }, "get")
    });
    Object.defineProperty(exports2, "Source", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Source;
      }, "get")
    });
    Object.defineProperty(exports2, "Token", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.Token;
      }, "get")
    });
    Object.defineProperty(exports2, "TokenKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.TokenKind;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.TypeInfo;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.TypeMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.TypeNameMetaFieldDef;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueArgumentDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueArgumentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueDirectiveNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueDirectivesPerLocationRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueEnumValueNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueFieldDefinitionNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueFragmentNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueInputFieldNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueOperationNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueOperationTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueOperationTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueTypeNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueTypeNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "UniqueVariableNamesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.UniqueVariableNamesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "ValidationContext", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ValidationContext;
      }, "get")
    });
    Object.defineProperty(exports2, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.ValuesOfCorrectTypeRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.VariablesAreInputTypesRule;
      }, "get")
    });
    Object.defineProperty(exports2, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.VariablesInAllowedPositionRule;
      }, "get")
    });
    Object.defineProperty(exports2, "__Directive", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Directive;
      }, "get")
    });
    Object.defineProperty(exports2, "__DirectiveLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__DirectiveLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "__EnumValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__EnumValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Field", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Field;
      }, "get")
    });
    Object.defineProperty(exports2, "__InputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__InputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "__Schema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Schema;
      }, "get")
    });
    Object.defineProperty(exports2, "__Type", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__Type;
      }, "get")
    });
    Object.defineProperty(exports2, "__TypeKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.__TypeKind;
      }, "get")
    });
    Object.defineProperty(exports2, "assertAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertEnumValueName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertEnumValueName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertListType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.assertValidName;
      }, "get")
    });
    Object.defineProperty(exports2, "assertValidSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertValidSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "assertWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.assertWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "astFromValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.astFromValue;
      }, "get")
    });
    Object.defineProperty(exports2, "buildASTSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.buildASTSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildClientSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.buildClientSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "buildSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.buildSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "coerceInputValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.coerceInputValue;
      }, "get")
    });
    Object.defineProperty(exports2, "concatAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.concatAST;
      }, "get")
    });
    Object.defineProperty(exports2, "createSourceEventStream", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.createSourceEventStream;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultFieldResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.defaultFieldResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultTypeResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.defaultTypeResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "doTypesOverlap", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.doTypesOverlap;
      }, "get")
    });
    Object.defineProperty(exports2, "execute", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.execute;
      }, "get")
    });
    Object.defineProperty(exports2, "executeSync", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.executeSync;
      }, "get")
    });
    Object.defineProperty(exports2, "extendSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.extendSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "findBreakingChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.findBreakingChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "findDangerousChanges", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.findDangerousChanges;
      }, "get")
    });
    Object.defineProperty(exports2, "formatError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.formatError;
      }, "get")
    });
    Object.defineProperty(exports2, "getArgumentValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.getArgumentValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getDirectiveValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.getDirectiveValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getEnterLeaveForKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.getEnterLeaveForKind;
      }, "get")
    });
    Object.defineProperty(exports2, "getIntrospectionQuery", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.getIntrospectionQuery;
      }, "get")
    });
    Object.defineProperty(exports2, "getLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.getLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "getNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.getNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "getNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.getNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.getOperationAST;
      }, "get")
    });
    Object.defineProperty(exports2, "getOperationRootType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.getOperationRootType;
      }, "get")
    });
    Object.defineProperty(exports2, "getVariableValues", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.getVariableValues;
      }, "get")
    });
    Object.defineProperty(exports2, "getVisitFn", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.getVisitFn;
      }, "get")
    });
    Object.defineProperty(exports2, "graphql", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _graphql.graphql;
      }, "get")
    });
    Object.defineProperty(exports2, "graphqlSync", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _graphql.graphqlSync;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionFromSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.introspectionFromSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "introspectionTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.introspectionTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "isAbstractType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isAbstractType;
      }, "get")
    });
    Object.defineProperty(exports2, "isCompositeType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isCompositeType;
      }, "get")
    });
    Object.defineProperty(exports2, "isConstValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isConstValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isEnumType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isEnumType;
      }, "get")
    });
    Object.defineProperty(exports2, "isEqualType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.isEqualType;
      }, "get")
    });
    Object.defineProperty(exports2, "isExecutableDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isExecutableDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isInputObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isInputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isInterfaceType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isInterfaceType;
      }, "get")
    });
    Object.defineProperty(exports2, "isIntrospectionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isIntrospectionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isLeafType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isLeafType;
      }, "get")
    });
    Object.defineProperty(exports2, "isListType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isListType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNamedType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isNamedType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNonNullType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isNonNullType;
      }, "get")
    });
    Object.defineProperty(exports2, "isNullableType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isNullableType;
      }, "get")
    });
    Object.defineProperty(exports2, "isObjectType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isObjectType;
      }, "get")
    });
    Object.defineProperty(exports2, "isOutputType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isOutputType;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredArgument", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isRequiredArgument;
      }, "get")
    });
    Object.defineProperty(exports2, "isRequiredInputField", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isRequiredInputField;
      }, "get")
    });
    Object.defineProperty(exports2, "isScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "isSelectionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isSelectionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedDirective", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isSpecifiedDirective;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifiedScalarType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isSpecifiedScalarType;
      }, "get")
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isType;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSubTypeOf", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.isTypeSubTypeOf;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeSystemDefinitionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isTypeSystemExtensionNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isUnionType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isUnionType;
      }, "get")
    });
    Object.defineProperty(exports2, "isValidNameError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.isValidNameError;
      }, "get")
    });
    Object.defineProperty(exports2, "isValueNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.isValueNode;
      }, "get")
    });
    Object.defineProperty(exports2, "isWrappingType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.isWrappingType;
      }, "get")
    });
    Object.defineProperty(exports2, "lexicographicSortSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.lexicographicSortSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "locatedError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.locatedError;
      }, "get")
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parse;
      }, "get")
    });
    Object.defineProperty(exports2, "parseConstValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parseConstValue;
      }, "get")
    });
    Object.defineProperty(exports2, "parseType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parseType;
      }, "get")
    });
    Object.defineProperty(exports2, "parseValue", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.parseValue;
      }, "get")
    });
    Object.defineProperty(exports2, "print", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.print;
      }, "get")
    });
    Object.defineProperty(exports2, "printError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.printError;
      }, "get")
    });
    Object.defineProperty(exports2, "printIntrospectionSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.printIntrospectionSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.printLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "printSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.printSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "printSourceLocation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.printSourceLocation;
      }, "get")
    });
    Object.defineProperty(exports2, "printType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.printType;
      }, "get")
    });
    Object.defineProperty(exports2, "recommendedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.recommendedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveObjMapThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.resolveObjMapThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.resolveReadonlyArrayThunk;
      }, "get")
    });
    Object.defineProperty(exports2, "responsePathAsArray", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.responsePathAsArray;
      }, "get")
    });
    Object.defineProperty(exports2, "separateOperations", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.separateOperations;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedDirectives", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.specifiedDirectives;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedRules", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.specifiedRules;
      }, "get")
    });
    Object.defineProperty(exports2, "specifiedScalarTypes", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.specifiedScalarTypes;
      }, "get")
    });
    Object.defineProperty(exports2, "stripIgnoredCharacters", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.stripIgnoredCharacters;
      }, "get")
    });
    Object.defineProperty(exports2, "subscribe", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index3.subscribe;
      }, "get")
    });
    Object.defineProperty(exports2, "syntaxError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index5.syntaxError;
      }, "get")
    });
    Object.defineProperty(exports2, "typeFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.typeFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index4.validate;
      }, "get")
    });
    Object.defineProperty(exports2, "validateSchema", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index.validateSchema;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromAST", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.valueFromAST;
      }, "get")
    });
    Object.defineProperty(exports2, "valueFromASTUntyped", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.valueFromASTUntyped;
      }, "get")
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _version.version;
      }, "get")
    });
    Object.defineProperty(exports2, "versionInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _version.versionInfo;
      }, "get")
    });
    Object.defineProperty(exports2, "visit", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.visit;
      }, "get")
    });
    Object.defineProperty(exports2, "visitInParallel", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index2.visitInParallel;
      }, "get")
    });
    Object.defineProperty(exports2, "visitWithTypeInfo", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return _index6.visitWithTypeInfo;
      }, "get")
    });
    var _version = require_version();
    var _graphql = require_graphql();
    var _index = require_type();
    var _index2 = require_language();
    var _index3 = require_execution();
    var _index4 = require_validation();
    var _index5 = require_error();
    var _index6 = require_utilities();
  }
});

// ../node_modules/loglevel/lib/loglevel.js
var require_loglevel = __commonJS({
  "../node_modules/loglevel/lib/loglevel.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(root, definition) {
      "use strict";
      if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = definition();
      } else {
        root.log = definition();
      }
    })(exports2, function() {
      "use strict";
      var noop = /* @__PURE__ */ __name(function() {
      }, "noop");
      var undefinedType = "undefined";
      var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
      var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ];
      var _loggersByName = {};
      var defaultLogger2 = null;
      function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === "function") {
          return method.bind(obj);
        } else {
          try {
            return Function.prototype.bind.call(method, obj);
          } catch (e) {
            return function() {
              return Function.prototype.apply.apply(method, [obj, arguments]);
            };
          }
        }
      }
      __name(bindMethod, "bindMethod");
      function traceForIE() {
        if (console.log) {
          if (console.log.apply) {
            console.log.apply(console, arguments);
          } else {
            Function.prototype.apply.apply(console.log, [console, arguments]);
          }
        }
        if (console.trace) console.trace();
      }
      __name(traceForIE, "traceForIE");
      function realMethod(methodName) {
        if (methodName === "debug") {
          methodName = "log";
        }
        if (typeof console === undefinedType) {
          return false;
        } else if (methodName === "trace" && isIE) {
          return traceForIE;
        } else if (console[methodName] !== void 0) {
          return bindMethod(console, methodName);
        } else if (console.log !== void 0) {
          return bindMethod(console, "log");
        } else {
          return noop;
        }
      }
      __name(realMethod, "realMethod");
      function replaceLoggingMethods() {
        var level = this.getLevel();
        for (var i = 0; i < logMethods.length; i++) {
          var methodName = logMethods[i];
          this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
        }
        this.log = this.debug;
        if (typeof console === undefinedType && level < this.levels.SILENT) {
          return "No console available for logging";
        }
      }
      __name(replaceLoggingMethods, "replaceLoggingMethods");
      function enableLoggingWhenConsoleArrives(methodName) {
        return function() {
          if (typeof console !== undefinedType) {
            replaceLoggingMethods.call(this);
            this[methodName].apply(this, arguments);
          }
        };
      }
      __name(enableLoggingWhenConsoleArrives, "enableLoggingWhenConsoleArrives");
      function defaultMethodFactory(methodName, _level, _loggerName) {
        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
      }
      __name(defaultMethodFactory, "defaultMethodFactory");
      function Logger(name, factory) {
        var self2 = this;
        var inheritedLevel;
        var defaultLevel;
        var userLevel;
        var storageKey = "loglevel";
        if (typeof name === "string") {
          storageKey += ":" + name;
        } else if (typeof name === "symbol") {
          storageKey = void 0;
        }
        function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || "silent").toUpperCase();
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage[storageKey] = levelName;
            return;
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {
          }
        }
        __name(persistLevelIfPossible, "persistLevelIfPossible");
        function getPersistedLevel() {
          var storedLevel;
          if (typeof window === undefinedType || !storageKey) return;
          try {
            storedLevel = window.localStorage[storageKey];
          } catch (ignore) {
          }
          if (typeof storedLevel === undefinedType) {
            try {
              var cookie = window.document.cookie;
              var cookieName = encodeURIComponent(storageKey);
              var location = cookie.indexOf(cookieName + "=");
              if (location !== -1) {
                storedLevel = /^([^;]+)/.exec(
                  cookie.slice(location + cookieName.length + 1)
                )[1];
              }
            } catch (ignore) {
            }
          }
          if (self2.levels[storedLevel] === void 0) {
            storedLevel = void 0;
          }
          return storedLevel;
        }
        __name(getPersistedLevel, "getPersistedLevel");
        function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;
          try {
            window.localStorage.removeItem(storageKey);
          } catch (ignore) {
          }
          try {
            window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {
          }
        }
        __name(clearPersistedLevel, "clearPersistedLevel");
        function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
            level = self2.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
            return level;
          } else {
            throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
        }
        __name(normalizeLevel, "normalizeLevel");
        self2.name = name;
        self2.levels = {
          "TRACE": 0,
          "DEBUG": 1,
          "INFO": 2,
          "WARN": 3,
          "ERROR": 4,
          "SILENT": 5
        };
        self2.methodFactory = factory || defaultMethodFactory;
        self2.getLevel = function() {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
        };
        self2.setLevel = function(level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {
            persistLevelIfPossible(userLevel);
          }
          return replaceLoggingMethods.call(self2);
        };
        self2.setDefaultLevel = function(level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
            self2.setLevel(level, false);
          }
        };
        self2.resetLevel = function() {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self2);
        };
        self2.enableAll = function(persist) {
          self2.setLevel(self2.levels.TRACE, persist);
        };
        self2.disableAll = function(persist) {
          self2.setLevel(self2.levels.SILENT, persist);
        };
        self2.rebuild = function() {
          if (defaultLogger2 !== self2) {
            inheritedLevel = normalizeLevel(defaultLogger2.getLevel());
          }
          replaceLoggingMethods.call(self2);
          if (defaultLogger2 === self2) {
            for (var childName in _loggersByName) {
              _loggersByName[childName].rebuild();
            }
          }
        };
        inheritedLevel = normalizeLevel(
          defaultLogger2 ? defaultLogger2.getLevel() : "WARN"
        );
        var initialLevel = getPersistedLevel();
        if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
        }
        replaceLoggingMethods.call(self2);
      }
      __name(Logger, "Logger");
      defaultLogger2 = new Logger();
      defaultLogger2.getLogger = /* @__PURE__ */ __name(function getLogger(name) {
        if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }
        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name,
            defaultLogger2.methodFactory
          );
        }
        return logger;
      }, "getLogger");
      var _log = typeof window !== undefinedType ? window.log : void 0;
      defaultLogger2.noConflict = function() {
        if (typeof window !== undefinedType && window.log === defaultLogger2) {
          window.log = _log;
        }
        return defaultLogger2;
      };
      defaultLogger2.getLoggers = /* @__PURE__ */ __name(function getLoggers() {
        return _loggersByName;
      }, "getLoggers");
      defaultLogger2["default"] = defaultLogger2;
      return defaultLogger2;
    });
  }
});

// ../node_modules/negotiator/lib/charset.js
var require_charset = __commonJS({
  "../node_modules/negotiator/lib/charset.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = preferredCharsets;
    module2.exports.preferredCharsets = preferredCharsets;
    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptCharset(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);
        if (charset) {
          accepts[j++] = charset;
        }
      }
      accepts.length = j;
      return accepts;
    }
    __name(parseAcceptCharset, "parseAcceptCharset");
    function parseCharset(str, i) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match) return null;
      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        charset,
        q,
        i
      };
    }
    __name(parseCharset, "parseCharset");
    function getCharsetPriority(charset, accepted, index) {
      var priority2 = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);
        if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
          priority2 = spec;
        }
      }
      return priority2;
    }
    __name(getCharsetPriority, "getCharsetPriority");
    function specify(charset, spec, index) {
      var s = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
      } else if (spec.charset !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    __name(specify, "specify");
    function preferredCharsets(accept, provided) {
      var accepts = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }
      var priorities = provided.map(/* @__PURE__ */ __name(function getPriority2(type2, index) {
        return getCharsetPriority(type2, accepts, index);
      }, "getPriority"));
      return priorities.filter(isQuality).sort(compareSpecs).map(/* @__PURE__ */ __name(function getCharset(priority2) {
        return provided[priorities.indexOf(priority2)];
      }, "getCharset"));
    }
    __name(preferredCharsets, "preferredCharsets");
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    __name(compareSpecs, "compareSpecs");
    function getFullCharset(spec) {
      return spec.charset;
    }
    __name(getFullCharset, "getFullCharset");
    function isQuality(spec) {
      return spec.q > 0;
    }
    __name(isQuality, "isQuality");
  }
});

// ../node_modules/negotiator/lib/encoding.js
var require_encoding = __commonJS({
  "../node_modules/negotiator/lib/encoding.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = preferredEncodings;
    module2.exports.preferredEncodings = preferredEncodings;
    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
    function parseAcceptEncoding(accept) {
      var accepts = accept.split(",");
      var hasIdentity = false;
      var minQuality = 1;
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);
        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify("identity", encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }
      if (!hasIdentity) {
        accepts[j++] = {
          encoding: "identity",
          q: minQuality,
          i
        };
      }
      accepts.length = j;
      return accepts;
    }
    __name(parseAcceptEncoding, "parseAcceptEncoding");
    function parseEncoding(str, i) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match) return null;
      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split("=");
          if (p[0] === "q") {
            q = parseFloat(p[1]);
            break;
          }
        }
      }
      return {
        encoding,
        q,
        i
      };
    }
    __name(parseEncoding, "parseEncoding");
    function getEncodingPriority(encoding, accepted, index) {
      var priority2 = { encoding, o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);
        if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
          priority2 = spec;
        }
      }
      return priority2;
    }
    __name(getEncodingPriority, "getEncodingPriority");
    function specify(encoding, spec, index) {
      var s = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
      } else if (spec.encoding !== "*") {
        return null;
      }
      return {
        encoding,
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    __name(specify, "specify");
    function preferredEncodings(accept, provided, preferred) {
      var accepts = parseAcceptEncoding(accept || "");
      var comparator = preferred ? /* @__PURE__ */ __name(function comparator2(a, b) {
        if (a.q !== b.q) {
          return b.q - a.q;
        }
        var aPreferred = preferred.indexOf(a.encoding);
        var bPreferred = preferred.indexOf(b.encoding);
        if (aPreferred === -1 && bPreferred === -1) {
          return b.s - a.s || a.o - b.o || a.i - b.i;
        }
        if (aPreferred !== -1 && bPreferred !== -1) {
          return aPreferred - bPreferred;
        }
        return aPreferred === -1 ? 1 : -1;
      }, "comparator") : compareSpecs;
      if (!provided) {
        return accepts.filter(isQuality).sort(comparator).map(getFullEncoding);
      }
      var priorities = provided.map(/* @__PURE__ */ __name(function getPriority2(type2, index) {
        return getEncodingPriority(type2, accepts, index);
      }, "getPriority"));
      return priorities.filter(isQuality).sort(comparator).map(/* @__PURE__ */ __name(function getEncoding(priority2) {
        return provided[priorities.indexOf(priority2)];
      }, "getEncoding"));
    }
    __name(preferredEncodings, "preferredEncodings");
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
    }
    __name(compareSpecs, "compareSpecs");
    function getFullEncoding(spec) {
      return spec.encoding;
    }
    __name(getFullEncoding, "getFullEncoding");
    function isQuality(spec) {
      return spec.q > 0;
    }
    __name(isQuality, "isQuality");
  }
});

// ../node_modules/negotiator/lib/language.js
var require_language2 = __commonJS({
  "../node_modules/negotiator/lib/language.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = preferredLanguages;
    module2.exports.preferredLanguages = preferredLanguages;
    var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
    function parseAcceptLanguage(accept) {
      var accepts = accept.split(",");
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var language = parseLanguage(accepts[i].trim(), i);
        if (language) {
          accepts[j++] = language;
        }
      }
      accepts.length = j;
      return accepts;
    }
    __name(parseAcceptLanguage, "parseAcceptLanguage");
    function parseLanguage(str, i) {
      var match = simpleLanguageRegExp.exec(str);
      if (!match) return null;
      var prefix = match[1];
      var suffix = match[2];
      var full = prefix;
      if (suffix) full += "-" + suffix;
      var q = 1;
      if (match[3]) {
        var params = match[3].split(";");
        for (var j = 0; j < params.length; j++) {
          var p = params[j].split("=");
          if (p[0] === "q") q = parseFloat(p[1]);
        }
      }
      return {
        prefix,
        suffix,
        q,
        i,
        full
      };
    }
    __name(parseLanguage, "parseLanguage");
    function getLanguagePriority(language, accepted, index) {
      var priority2 = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(language, accepted[i], index);
        if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
          priority2 = spec;
        }
      }
      return priority2;
    }
    __name(getLanguagePriority, "getLanguagePriority");
    function specify(language, spec, index) {
      var p = parseLanguage(language);
      if (!p) return null;
      var s = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== "*") {
        return null;
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    __name(specify, "specify");
    function preferredLanguages(accept, provided) {
      var accepts = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }
      var priorities = provided.map(/* @__PURE__ */ __name(function getPriority2(type2, index) {
        return getLanguagePriority(type2, accepts, index);
      }, "getPriority"));
      return priorities.filter(isQuality).sort(compareSpecs).map(/* @__PURE__ */ __name(function getLanguage(priority2) {
        return provided[priorities.indexOf(priority2)];
      }, "getLanguage"));
    }
    __name(preferredLanguages, "preferredLanguages");
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    __name(compareSpecs, "compareSpecs");
    function getFullLanguage(spec) {
      return spec.full;
    }
    __name(getFullLanguage, "getFullLanguage");
    function isQuality(spec) {
      return spec.q > 0;
    }
    __name(isQuality, "isQuality");
  }
});

// ../node_modules/negotiator/lib/mediaType.js
var require_mediaType = __commonJS({
  "../node_modules/negotiator/lib/mediaType.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = preferredMediaTypes;
    module2.exports.preferredMediaTypes = preferredMediaTypes;
    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);
      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);
        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }
      accepts.length = j;
      return accepts;
    }
    __name(parseAccept, "parseAccept");
    function parseMediaType(str, i) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match) return null;
      var params = /* @__PURE__ */ Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type2 = match[1];
      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);
        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key = pair[0].toLowerCase();
          var val = pair[1];
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.slice(1, -1) : val;
          if (key === "q") {
            q = parseFloat(value);
            break;
          }
          params[key] = value;
        }
      }
      return {
        type: type2,
        subtype,
        params,
        q,
        i
      };
    }
    __name(parseMediaType, "parseMediaType");
    function getMediaTypePriority(type2, accepted, index) {
      var priority2 = { o: -1, q: 0, s: 0 };
      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type2, accepted[i], index);
        if (spec && (priority2.s - spec.s || priority2.q - spec.q || priority2.o - spec.o) < 0) {
          priority2 = spec;
        }
      }
      return priority2;
    }
    __name(getMediaTypePriority, "getMediaTypePriority");
    function specify(type2, spec, index) {
      var p = parseMediaType(type2);
      var s = 0;
      if (!p) {
        return null;
      }
      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
      } else if (spec.type != "*") {
        return null;
      }
      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
      } else if (spec.subtype != "*") {
        return null;
      }
      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (keys.every(function(k) {
          return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
        })) {
          s |= 1;
        } else {
          return null;
        }
      }
      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s
      };
    }
    __name(specify, "specify");
    function preferredMediaTypes(accept, provided) {
      var accepts = parseAccept(accept === void 0 ? "*/*" : accept || "");
      if (!provided) {
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }
      var priorities = provided.map(/* @__PURE__ */ __name(function getPriority2(type2, index) {
        return getMediaTypePriority(type2, accepts, index);
      }, "getPriority"));
      return priorities.filter(isQuality).sort(compareSpecs).map(/* @__PURE__ */ __name(function getType(priority2) {
        return provided[priorities.indexOf(priority2)];
      }, "getType"));
    }
    __name(preferredMediaTypes, "preferredMediaTypes");
    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }
    __name(compareSpecs, "compareSpecs");
    function getFullType(spec) {
      return spec.type + "/" + spec.subtype;
    }
    __name(getFullType, "getFullType");
    function isQuality(spec) {
      return spec.q > 0;
    }
    __name(isQuality, "isQuality");
    function quoteCount(string) {
      var count3 = 0;
      var index = 0;
      while ((index = string.indexOf('"', index)) !== -1) {
        count3++;
        index++;
      }
      return count3;
    }
    __name(quoteCount, "quoteCount");
    function splitKeyValuePair(str) {
      var index = str.indexOf("=");
      var key;
      var val;
      if (index === -1) {
        key = str;
      } else {
        key = str.slice(0, index);
        val = str.slice(index + 1);
      }
      return [key, val];
    }
    __name(splitKeyValuePair, "splitKeyValuePair");
    function splitMediaTypes(accept) {
      var accepts = accept.split(",");
      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += "," + accepts[i];
        }
      }
      accepts.length = j + 1;
      return accepts;
    }
    __name(splitMediaTypes, "splitMediaTypes");
    function splitParameters(str) {
      var parameters = str.split(";");
      for (var i = 1, j = 0; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i];
        } else {
          parameters[j] += ";" + parameters[i];
        }
      }
      parameters.length = j + 1;
      for (var i = 0; i < parameters.length; i++) {
        parameters[i] = parameters[i].trim();
      }
      return parameters;
    }
    __name(splitParameters, "splitParameters");
  }
});

// ../node_modules/negotiator/index.js
var require_negotiator = __commonJS({
  "../node_modules/negotiator/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var preferredCharsets = require_charset();
    var preferredEncodings = require_encoding();
    var preferredLanguages = require_language2();
    var preferredMediaTypes = require_mediaType();
    module2.exports = Negotiator3;
    module2.exports.Negotiator = Negotiator3;
    function Negotiator3(request) {
      if (!(this instanceof Negotiator3)) {
        return new Negotiator3(request);
      }
      this.request = request;
    }
    __name(Negotiator3, "Negotiator");
    Negotiator3.prototype.charset = /* @__PURE__ */ __name(function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    }, "charset");
    Negotiator3.prototype.charsets = /* @__PURE__ */ __name(function charsets(available) {
      return preferredCharsets(this.request.headers["accept-charset"], available);
    }, "charsets");
    Negotiator3.prototype.encoding = /* @__PURE__ */ __name(function encoding(available, preferred) {
      var set = this.encodings(available, preferred);
      return set && set[0];
    }, "encoding");
    Negotiator3.prototype.encodings = /* @__PURE__ */ __name(function encodings(available, preferred) {
      return preferredEncodings(this.request.headers["accept-encoding"], available, preferred);
    }, "encodings");
    Negotiator3.prototype.language = /* @__PURE__ */ __name(function language(available) {
      var set = this.languages(available);
      return set && set[0];
    }, "language");
    Negotiator3.prototype.languages = /* @__PURE__ */ __name(function languages(available) {
      return preferredLanguages(this.request.headers["accept-language"], available);
    }, "languages");
    Negotiator3.prototype.mediaType = /* @__PURE__ */ __name(function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    }, "mediaType");
    Negotiator3.prototype.mediaTypes = /* @__PURE__ */ __name(function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    }, "mediaTypes");
    Negotiator3.prototype.preferredCharset = Negotiator3.prototype.charset;
    Negotiator3.prototype.preferredCharsets = Negotiator3.prototype.charsets;
    Negotiator3.prototype.preferredEncoding = Negotiator3.prototype.encoding;
    Negotiator3.prototype.preferredEncodings = Negotiator3.prototype.encodings;
    Negotiator3.prototype.preferredLanguage = Negotiator3.prototype.language;
    Negotiator3.prototype.preferredLanguages = Negotiator3.prototype.languages;
    Negotiator3.prototype.preferredMediaType = Negotiator3.prototype.mediaType;
    Negotiator3.prototype.preferredMediaTypes = Negotiator3.prototype.mediaTypes;
  }
});

// ../node_modules/@apollo/server/dist/esm/cachePolicy.js
function newCachePolicy() {
  return {
    maxAge: void 0,
    scope: void 0,
    restrict(hint) {
      if (hint.maxAge !== void 0 && (this.maxAge === void 0 || hint.maxAge < this.maxAge)) {
        this.maxAge = hint.maxAge;
      }
      if (hint.scope !== void 0 && this.scope !== "PRIVATE") {
        this.scope = hint.scope;
      }
    },
    replace(hint) {
      if (hint.maxAge !== void 0) {
        this.maxAge = hint.maxAge;
      }
      if (hint.scope !== void 0) {
        this.scope = hint.scope;
      }
    },
    policyIfCacheable() {
      if (this.maxAge === void 0 || this.maxAge === 0) {
        return null;
      }
      return { maxAge: this.maxAge, scope: this.scope ?? "PUBLIC" };
    }
  };
}
var init_cachePolicy = __esm({
  "../node_modules/@apollo/server/dist/esm/cachePolicy.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(newCachePolicy, "newCachePolicy");
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs
var subtle;
var init_web = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    subtle = globalThis.crypto?.subtle;
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs
var webcrypto, createCipher, createDecipher, pseudoRandomBytes, Cipher, Decipher;
var init_node = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    webcrypto = new Proxy(globalThis.crypto, { get(_, key) {
      if (key === "CryptoKey") {
        return globalThis.CryptoKey;
      }
      if (typeof globalThis.crypto[key] === "function") {
        return globalThis.crypto[key].bind(globalThis.crypto);
      }
      return globalThis.crypto[key];
    } });
    createCipher = /* @__PURE__ */ notImplemented("crypto.createCipher");
    createDecipher = /* @__PURE__ */ notImplemented("crypto.createDecipher");
    pseudoRandomBytes = /* @__PURE__ */ notImplemented("crypto.pseudoRandomBytes");
    Cipher = /* @__PURE__ */ notImplementedClass("crypto.Cipher");
    Decipher = /* @__PURE__ */ notImplementedClass("crypto.Decipher");
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs
var SSL_OP_ALL, SSL_OP_ALLOW_NO_DHE_KEX, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_NO_COMPRESSION, SSL_OP_NO_ENCRYPT_THEN_MAC, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_RENEGOTIATION, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_NO_TLSv1_3, SSL_OP_PRIORITIZE_CHACHA, SSL_OP_TLS_ROLLBACK_BUG, ENGINE_METHOD_RSA, ENGINE_METHOD_DSA, ENGINE_METHOD_DH, ENGINE_METHOD_RAND, ENGINE_METHOD_EC, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_ALL, ENGINE_METHOD_NONE, DH_CHECK_P_NOT_SAFE_PRIME, DH_CHECK_P_NOT_PRIME, DH_UNABLE_TO_CHECK_GENERATOR, DH_NOT_SUITABLE_GENERATOR, RSA_PKCS1_PADDING, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_X931_PADDING, RSA_PKCS1_PSS_PADDING, RSA_PSS_SALTLEN_DIGEST, RSA_PSS_SALTLEN_MAX_SIGN, RSA_PSS_SALTLEN_AUTO, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_UNCOMPRESSED, POINT_CONVERSION_HYBRID, defaultCoreCipherList, defaultCipherList, OPENSSL_VERSION_NUMBER, TLS1_VERSION, TLS1_1_VERSION, TLS1_2_VERSION, TLS1_3_VERSION;
var init_constants = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SSL_OP_ALL = 2147485776;
    SSL_OP_ALLOW_NO_DHE_KEX = 1024;
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;
    SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;
    SSL_OP_CISCO_ANYCONNECT = 32768;
    SSL_OP_COOKIE_EXCHANGE = 8192;
    SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;
    SSL_OP_LEGACY_SERVER_CONNECT = 4;
    SSL_OP_NO_COMPRESSION = 131072;
    SSL_OP_NO_ENCRYPT_THEN_MAC = 524288;
    SSL_OP_NO_QUERY_MTU = 4096;
    SSL_OP_NO_RENEGOTIATION = 1073741824;
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;
    SSL_OP_NO_SSLv2 = 0;
    SSL_OP_NO_SSLv3 = 33554432;
    SSL_OP_NO_TICKET = 16384;
    SSL_OP_NO_TLSv1 = 67108864;
    SSL_OP_NO_TLSv1_1 = 268435456;
    SSL_OP_NO_TLSv1_2 = 134217728;
    SSL_OP_NO_TLSv1_3 = 536870912;
    SSL_OP_PRIORITIZE_CHACHA = 2097152;
    SSL_OP_TLS_ROLLBACK_BUG = 8388608;
    ENGINE_METHOD_RSA = 1;
    ENGINE_METHOD_DSA = 2;
    ENGINE_METHOD_DH = 4;
    ENGINE_METHOD_RAND = 8;
    ENGINE_METHOD_EC = 2048;
    ENGINE_METHOD_CIPHERS = 64;
    ENGINE_METHOD_DIGESTS = 128;
    ENGINE_METHOD_PKEY_METHS = 512;
    ENGINE_METHOD_PKEY_ASN1_METHS = 1024;
    ENGINE_METHOD_ALL = 65535;
    ENGINE_METHOD_NONE = 0;
    DH_CHECK_P_NOT_SAFE_PRIME = 2;
    DH_CHECK_P_NOT_PRIME = 1;
    DH_UNABLE_TO_CHECK_GENERATOR = 4;
    DH_NOT_SUITABLE_GENERATOR = 8;
    RSA_PKCS1_PADDING = 1;
    RSA_NO_PADDING = 3;
    RSA_PKCS1_OAEP_PADDING = 4;
    RSA_X931_PADDING = 5;
    RSA_PKCS1_PSS_PADDING = 6;
    RSA_PSS_SALTLEN_DIGEST = -1;
    RSA_PSS_SALTLEN_MAX_SIGN = -2;
    RSA_PSS_SALTLEN_AUTO = -2;
    POINT_CONVERSION_COMPRESSED = 2;
    POINT_CONVERSION_UNCOMPRESSED = 4;
    POINT_CONVERSION_HYBRID = 6;
    defaultCoreCipherList = "";
    defaultCipherList = "";
    OPENSSL_VERSION_NUMBER = 0;
    TLS1_VERSION = 0;
    TLS1_1_VERSION = 0;
    TLS1_2_VERSION = 0;
    TLS1_3_VERSION = 0;
  }
});

// ../node_modules/unenv/dist/runtime/node/crypto.mjs
var constants;
var init_crypto = __esm({
  "../node_modules/unenv/dist/runtime/node/crypto.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constants();
    init_web();
    init_node();
    constants = {
      OPENSSL_VERSION_NUMBER,
      SSL_OP_ALL,
      SSL_OP_ALLOW_NO_DHE_KEX,
      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
      SSL_OP_CIPHER_SERVER_PREFERENCE,
      SSL_OP_CISCO_ANYCONNECT,
      SSL_OP_COOKIE_EXCHANGE,
      SSL_OP_CRYPTOPRO_TLSEXT_BUG,
      SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
      SSL_OP_LEGACY_SERVER_CONNECT,
      SSL_OP_NO_COMPRESSION,
      SSL_OP_NO_ENCRYPT_THEN_MAC,
      SSL_OP_NO_QUERY_MTU,
      SSL_OP_NO_RENEGOTIATION,
      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
      SSL_OP_NO_SSLv2,
      SSL_OP_NO_SSLv3,
      SSL_OP_NO_TICKET,
      SSL_OP_NO_TLSv1,
      SSL_OP_NO_TLSv1_1,
      SSL_OP_NO_TLSv1_2,
      SSL_OP_NO_TLSv1_3,
      SSL_OP_PRIORITIZE_CHACHA,
      SSL_OP_TLS_ROLLBACK_BUG,
      ENGINE_METHOD_RSA,
      ENGINE_METHOD_DSA,
      ENGINE_METHOD_DH,
      ENGINE_METHOD_RAND,
      ENGINE_METHOD_EC,
      ENGINE_METHOD_CIPHERS,
      ENGINE_METHOD_DIGESTS,
      ENGINE_METHOD_PKEY_METHS,
      ENGINE_METHOD_PKEY_ASN1_METHS,
      ENGINE_METHOD_ALL,
      ENGINE_METHOD_NONE,
      DH_CHECK_P_NOT_SAFE_PRIME,
      DH_CHECK_P_NOT_PRIME,
      DH_UNABLE_TO_CHECK_GENERATOR,
      DH_NOT_SUITABLE_GENERATOR,
      RSA_PKCS1_PADDING,
      RSA_NO_PADDING,
      RSA_PKCS1_OAEP_PADDING,
      RSA_X931_PADDING,
      RSA_PKCS1_PSS_PADDING,
      RSA_PSS_SALTLEN_DIGEST,
      RSA_PSS_SALTLEN_MAX_SIGN,
      RSA_PSS_SALTLEN_AUTO,
      defaultCoreCipherList,
      TLS1_VERSION,
      TLS1_1_VERSION,
      TLS1_2_VERSION,
      TLS1_3_VERSION,
      POINT_CONVERSION_COMPRESSED,
      POINT_CONVERSION_UNCOMPRESSED,
      POINT_CONVERSION_HYBRID,
      defaultCipherList
    };
  }
});

// ../node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs
var workerdCrypto, Certificate, checkPrime, checkPrimeSync, Cipheriv, createCipheriv, createDecipheriv, createDiffieHellman, createDiffieHellmanGroup, createECDH, createHash, createHmac, createPrivateKey, createPublicKey, createSecretKey, createSign, createVerify, Decipheriv, diffieHellman, DiffieHellman, DiffieHellmanGroup, ECDH, fips, generateKey, generateKeyPair, generateKeyPairSync, generateKeySync, generatePrime, generatePrimeSync, getCipherInfo, getCiphers, getCurves, getDiffieHellman, getFips, getHashes, getRandomValues, hash, Hash, hkdf, hkdfSync, Hmac, KeyObject, pbkdf2, pbkdf2Sync, privateDecrypt, privateEncrypt, publicDecrypt, publicEncrypt, randomBytes, randomFill, randomFillSync, randomInt, randomUUID, scrypt, scryptSync, secureHeapUsed, setEngine, setFips, sign, Sign, subtle2, timingSafeEqual, verify, Verify, X509Certificate, webcrypto2, crypto_default;
var init_crypto2 = __esm({
  "../node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto();
    workerdCrypto = process.getBuiltinModule("node:crypto");
    ({
      Certificate,
      checkPrime,
      checkPrimeSync,
      Cipheriv: (
        // @ts-expect-error
        Cipheriv
      ),
      createCipheriv,
      createDecipheriv,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      createSign,
      createVerify,
      Decipheriv: (
        // @ts-expect-error
        Decipheriv
      ),
      diffieHellman,
      DiffieHellman,
      DiffieHellmanGroup,
      ECDH,
      fips,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCipherInfo,
      getCiphers,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hash,
      Hash,
      hkdf,
      hkdfSync,
      Hmac,
      KeyObject,
      pbkdf2,
      pbkdf2Sync,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      scrypt,
      scryptSync,
      secureHeapUsed,
      setEngine,
      setFips,
      sign,
      Sign,
      subtle: subtle2,
      timingSafeEqual,
      verify,
      Verify,
      X509Certificate
    } = workerdCrypto);
    webcrypto2 = {
      // @ts-expect-error
      CryptoKey: webcrypto.CryptoKey,
      getRandomValues,
      randomUUID,
      subtle: subtle2
    };
    crypto_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      Certificate,
      Cipher,
      Cipheriv,
      Decipher,
      Decipheriv,
      ECDH,
      Sign,
      Verify,
      X509Certificate,
      // @ts-expect-error @types/node is out of date - this is a bug in typings
      constants,
      createCipheriv,
      createDecipheriv,
      createECDH,
      createSign,
      createVerify,
      diffieHellman,
      getCipherInfo,
      hash,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      scrypt,
      scryptSync,
      sign,
      verify,
      // default-only export from unenv
      // @ts-expect-error unenv has unknown type
      createCipher,
      // @ts-expect-error unenv has unknown type
      createDecipher,
      // @ts-expect-error unenv has unknown type
      pseudoRandomBytes,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      DiffieHellman,
      DiffieHellmanGroup,
      Hash,
      Hmac,
      KeyObject,
      checkPrime,
      checkPrimeSync,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCiphers,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hkdf,
      hkdfSync,
      pbkdf2,
      pbkdf2Sync,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      secureHeapUsed,
      setEngine,
      setFips,
      subtle: subtle2,
      timingSafeEqual,
      // default-only export from workerd
      fips,
      // special-cased deep merged symbols
      webcrypto: webcrypto2
    };
  }
});

// node-built-in-modules:crypto
var require_crypto = __commonJS({
  "node-built-in-modules:crypto"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto2();
    module2.exports = crypto_default;
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs
var isRegExp, isDate, isBoolean, isNull, isNullOrUndefined, isNumber, isString, isSymbol, isUndefined, isFunction, isBuffer, isObject2, isError, isPrimitive;
var init_legacy_types = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isRegExp = /* @__PURE__ */ __name((val) => val instanceof RegExp, "isRegExp");
    isDate = /* @__PURE__ */ __name((val) => val instanceof Date, "isDate");
    isBoolean = /* @__PURE__ */ __name((val) => typeof val === "boolean", "isBoolean");
    isNull = /* @__PURE__ */ __name((val) => val === null, "isNull");
    isNullOrUndefined = /* @__PURE__ */ __name((val) => val === null || val === void 0, "isNullOrUndefined");
    isNumber = /* @__PURE__ */ __name((val) => typeof val === "number", "isNumber");
    isString = /* @__PURE__ */ __name((val) => typeof val === "string", "isString");
    isSymbol = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol");
    isUndefined = /* @__PURE__ */ __name((val) => val === void 0, "isUndefined");
    isFunction = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction");
    isBuffer = /* @__PURE__ */ __name((val) => {
      return val && typeof val === "object" && typeof val.copy === "function" && typeof val.fill === "function" && typeof val.readUInt8 === "function";
    }, "isBuffer");
    isObject2 = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object" && Object.getPrototypeOf(val).isPrototypeOf(Object), "isObject");
    isError = /* @__PURE__ */ __name((val) => val instanceof Error, "isError");
    isPrimitive = /* @__PURE__ */ __name((val) => {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    }, "isPrimitive");
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/util/log.mjs
var init_log = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/util/log.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// ../node_modules/unenv/dist/runtime/node/util.mjs
import types from "node:util/types";
import { default as default2 } from "node:util/types";
var TextDecoder2, TextEncoder, _errnoException, _exceptionWithHostPort, getSystemErrorMap, getSystemErrorName, parseEnv, styleText;
var init_util = __esm({
  "../node_modules/unenv/dist/runtime/node/util.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_legacy_types();
    init_log();
    TextDecoder2 = globalThis.TextDecoder;
    TextEncoder = globalThis.TextEncoder;
    _errnoException = /* @__PURE__ */ notImplemented("util._errnoException");
    _exceptionWithHostPort = /* @__PURE__ */ notImplemented("util._exceptionWithHostPort");
    getSystemErrorMap = /* @__PURE__ */ notImplemented("util.getSystemErrorMap");
    getSystemErrorName = /* @__PURE__ */ notImplemented("util.getSystemErrorName");
    parseEnv = /* @__PURE__ */ notImplemented("util.parseEnv");
    styleText = /* @__PURE__ */ notImplemented("util.styleText");
  }
});

// ../node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs
var workerdUtil, MIMEParams, MIMEType, TextDecoder3, TextEncoder2, _extend, aborted, callbackify, debug3, debuglog, deprecate, format, formatWithOptions, getCallSite, inherits, inspect2, isArray, isDeepStrictEqual, log3, parseArgs, promisify, stripVTControlCharacters, toUSVString, transferableAbortController, transferableAbortSignal, types2, util_default;
var init_util2 = __esm({
  "../node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util();
    workerdUtil = process.getBuiltinModule("node:util");
    ({
      MIMEParams,
      MIMEType,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder2,
      _extend: (
        // @ts-expect-error missing types?
        _extend
      ),
      aborted,
      callbackify,
      debug: debug3,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite: (
        // @ts-expect-error unknown type
        getCallSite
      ),
      inherits,
      inspect: inspect2,
      isArray,
      isDeepStrictEqual,
      log: log3,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal
    } = workerdUtil);
    types2 = workerdUtil.types;
    util_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      _errnoException,
      _exceptionWithHostPort,
      // @ts-expect-error unenv has unknown type
      getSystemErrorMap,
      // @ts-expect-error unenv has unknown type
      getSystemErrorName,
      isBoolean,
      isBuffer,
      isDate,
      isError,
      isFunction,
      isNull,
      isNullOrUndefined,
      isNumber,
      isObject: isObject2,
      isPrimitive,
      isRegExp,
      isString,
      isSymbol,
      isUndefined,
      // @ts-expect-error unenv has unknown type
      parseEnv,
      // @ts-expect-error unenv has unknown type
      styleText,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      _extend,
      aborted,
      callbackify,
      debug: debug3,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite,
      inherits,
      inspect: inspect2,
      isArray,
      isDeepStrictEqual,
      log: log3,
      MIMEParams,
      MIMEType,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder2,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal,
      // special-cased deep merged symbols
      types: types2
    };
  }
});

// ../node_modules/unenv/dist/runtime/npm/inherits.mjs
var inherits_exports = {};
__export(inherits_exports, {
  default: () => inherits_default
});
var inherits_default;
var init_inherits = __esm({
  "../node_modules/unenv/dist/runtime/npm/inherits.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util2();
    inherits_default = inherits;
  }
});

// required-unenv-alias:inherits
var require_inherits = __commonJS({
  "required-unenv-alias:inherits"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_inherits();
    module2.exports = Object.entries(inherits_exports).filter(([k]) => k !== "default").reduce(
      (cjs, [k, value]) => Object.defineProperty(cjs, k, { value, enumerable: true }),
      "default" in inherits_exports ? inherits_default : {}
    );
  }
});

// node-built-in-modules:buffer
import libDefault from "buffer";
var require_buffer = __commonJS({
  "node-built-in-modules:buffer"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = libDefault;
  }
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/safe-buffer/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "../node_modules/sha.js/hash.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash2(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    __name(Hash2, "Hash");
    Hash2.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block2 = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block2[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block2);
        }
      }
      this._len += length;
      return this;
    };
    Hash2.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash2 = this._hash();
      return enc ? hash2.toString(enc) : hash2;
    };
    Hash2.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module2.exports = Hash2;
  }
});

// ../node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "../node_modules/sha.js/sha.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha, "Sha");
    inherits2(Sha, Hash2);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    __name(rotl5, "rotl5");
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    __name(rotl30, "rotl30");
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    __name(ft, "ft");
    Sha.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha;
  }
});

// ../node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "../node_modules/sha.js/sha1.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha1, "Sha1");
    inherits2(Sha1, Hash2);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    __name(rotl1, "rotl1");
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    __name(rotl5, "rotl5");
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    __name(rotl30, "rotl30");
    function ft(s, b, c, d) {
      if (s === 0) return b & c | ~b & d;
      if (s === 2) return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    __name(ft, "ft");
    Sha1.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 80; ++i) W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module2.exports = Sha1;
  }
});

// ../node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "../node_modules/sha.js/sha256.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha256, "Sha256");
    inherits2(Sha256, Hash2);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    __name(ch, "ch");
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    __name(maj, "maj");
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    __name(sigma0, "sigma0");
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    __name(sigma1, "sigma1");
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    __name(gamma0, "gamma0");
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    __name(gamma1, "gamma1");
    Sha256.prototype._update = function(M) {
      var W2 = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) W2[i] = M.readInt32BE(i * 4);
      for (; i < 64; ++i) W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module2.exports = Sha256;
  }
});

// ../node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "../node_modules/sha.js/sha224.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Sha256 = require_sha256();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    __name(Sha224, "Sha224");
    inherits2(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module2.exports = Sha224;
  }
});

// ../node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "../node_modules/sha.js/sha512.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    __name(Sha512, "Sha512");
    inherits2(Sha512, Hash2);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    __name(Ch, "Ch");
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    __name(maj, "maj");
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    __name(sigma0, "sigma0");
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    __name(sigma1, "sigma1");
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    __name(Gamma0, "Gamma0");
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    __name(Gamma0l, "Gamma0l");
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    __name(Gamma1, "Gamma1");
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    __name(Gamma1l, "Gamma1l");
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    __name(getCarry, "getCarry");
    Sha512.prototype._update = function(M) {
      var W2 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        W2[i] = M.readInt32BE(i * 4);
        W2[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = W2[i - 15 * 2];
        var xl = W2[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W2[i - 2 * 2];
        xl = W2[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W2[i - 7 * 2];
        var Wi7l = W2[i - 7 * 2 + 1];
        var Wi16h = W2[i - 16 * 2];
        var Wi16l = W2[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W2[i] = Wih;
        W2[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = W2[j];
        Wil = W2[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      __name(writeInt64BE, "writeInt64BE");
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module2.exports = Sha512;
  }
});

// ../node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "../node_modules/sha.js/sha384.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_inherits();
    var SHA512 = require_sha512();
    var Hash2 = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash2.call(this, 128, 112);
    }
    __name(Sha384, "Sha384");
    inherits2(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      __name(writeInt64BE, "writeInt64BE");
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module2.exports = Sha384;
  }
});

// ../node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "../node_modules/sha.js/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var exports2 = module2.exports = /* @__PURE__ */ __name(function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports2[algorithm];
      if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    }, "SHA");
    exports2.sha = require_sha();
    exports2.sha1 = require_sha1();
    exports2.sha224 = require_sha224();
    exports2.sha256 = require_sha256();
    exports2.sha384 = require_sha384();
    exports2.sha512 = require_sha512();
  }
});

// ../node_modules/@apollo/utils.createhash/dist/index.js
var require_dist3 = __commonJS({
  "../node_modules/@apollo/utils.createhash/dist/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createHash = void 0;
    var utils_isnodelike_1 = require_dist();
    function createHash6(kind) {
      if (utils_isnodelike_1.isNodeLike && module2.require) {
        return require_crypto().createHash(kind);
      }
      return require_sha2()(kind);
    }
    __name(createHash6, "createHash");
    exports2.createHash = createHash6;
  }
});

// ../node_modules/@apollo/server/dist/esm/internalPlugin.js
function internalPlugin(p) {
  return p;
}
function pluginIsInternal(plugin) {
  return "__internal_plugin_id__" in plugin;
}
var init_internalPlugin = __esm({
  "../node_modules/@apollo/server/dist/esm/internalPlugin.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(internalPlugin, "internalPlugin");
    __name(pluginIsInternal, "pluginIsInternal");
  }
});

// ../node_modules/whatwg-mimetype/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/whatwg-mimetype/lib/utils.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports2.removeLeadingAndTrailingHTTPWhitespace = (string) => {
      return string.replace(/^[ \t\n\r]+/u, "").replace(/[ \t\n\r]+$/u, "");
    };
    exports2.removeTrailingHTTPWhitespace = (string) => {
      return string.replace(/[ \t\n\r]+$/u, "");
    };
    exports2.isHTTPWhitespaceChar = (char) => {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    };
    exports2.solelyContainsHTTPTokenCodePoints = (string) => {
      return /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/u.test(string);
    };
    exports2.soleyContainsHTTPQuotedStringTokenCodePoints = (string) => {
      return /^[\t\u0020-\u007E\u0080-\u00FF]*$/u.test(string);
    };
    exports2.asciiLowercase = (string) => {
      return string.replace(/[A-Z]/ug, (l) => l.toLowerCase());
    };
    exports2.collectAnHTTPQuotedString = (input, position) => {
      let value = "";
      position++;
      while (true) {
        while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
          value += input[position];
          ++position;
        }
        if (position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position];
        ++position;
        if (quoteOrBackslash === "\\") {
          if (position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position];
          ++position;
        } else {
          break;
        }
      }
      return [value, position];
    };
  }
});

// ../node_modules/whatwg-mimetype/lib/mime-type-parameters.js
var require_mime_type_parameters = __commonJS({
  "../node_modules/whatwg-mimetype/lib/mime-type-parameters.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints
    } = require_utils();
    module2.exports = class MIMETypeParameters {
      static {
        __name(this, "MIMETypeParameters");
      }
      constructor(map) {
        this._map = map;
      }
      get size() {
        return this._map.size;
      }
      get(name) {
        name = asciiLowercase(String(name));
        return this._map.get(name);
      }
      has(name) {
        name = asciiLowercase(String(name));
        return this._map.has(name);
      }
      set(name, value) {
        name = asciiLowercase(String(name));
        value = String(value);
        if (!solelyContainsHTTPTokenCodePoints(name)) {
          throw new Error(`Invalid MIME type parameter name "${name}": only HTTP token code points are valid.`);
        }
        if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {
          throw new Error(`Invalid MIME type parameter value "${value}": only HTTP quoted-string token code points are valid.`);
        }
        return this._map.set(name, value);
      }
      clear() {
        this._map.clear();
      }
      delete(name) {
        name = asciiLowercase(String(name));
        return this._map.delete(name);
      }
      forEach(callbackFn, thisArg) {
        this._map.forEach(callbackFn, thisArg);
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.values();
      }
      entries() {
        return this._map.entries();
      }
      [Symbol.iterator]() {
        return this._map[Symbol.iterator]();
      }
    };
  }
});

// ../node_modules/whatwg-mimetype/lib/parser.js
var require_parser2 = __commonJS({
  "../node_modules/whatwg-mimetype/lib/parser.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      removeLeadingAndTrailingHTTPWhitespace,
      removeTrailingHTTPWhitespace,
      isHTTPWhitespaceChar,
      solelyContainsHTTPTokenCodePoints,
      soleyContainsHTTPQuotedStringTokenCodePoints,
      asciiLowercase,
      collectAnHTTPQuotedString
    } = require_utils();
    module2.exports = (input) => {
      input = removeLeadingAndTrailingHTTPWhitespace(input);
      let position = 0;
      let type2 = "";
      while (position < input.length && input[position] !== "/") {
        type2 += input[position];
        ++position;
      }
      if (type2.length === 0 || !solelyContainsHTTPTokenCodePoints(type2)) {
        return null;
      }
      if (position >= input.length) {
        return null;
      }
      ++position;
      let subtype = "";
      while (position < input.length && input[position] !== ";") {
        subtype += input[position];
        ++position;
      }
      subtype = removeTrailingHTTPWhitespace(subtype);
      if (subtype.length === 0 || !solelyContainsHTTPTokenCodePoints(subtype)) {
        return null;
      }
      const mimeType = {
        type: asciiLowercase(type2),
        subtype: asciiLowercase(subtype),
        parameters: /* @__PURE__ */ new Map()
      };
      while (position < input.length) {
        ++position;
        while (isHTTPWhitespaceChar(input[position])) {
          ++position;
        }
        let parameterName = "";
        while (position < input.length && input[position] !== ";" && input[position] !== "=") {
          parameterName += input[position];
          ++position;
        }
        parameterName = asciiLowercase(parameterName);
        if (position < input.length) {
          if (input[position] === ";") {
            continue;
          }
          ++position;
        }
        let parameterValue = null;
        if (input[position] === '"') {
          [parameterValue, position] = collectAnHTTPQuotedString(input, position);
          while (position < input.length && input[position] !== ";") {
            ++position;
          }
        } else {
          parameterValue = "";
          while (position < input.length && input[position] !== ";") {
            parameterValue += input[position];
            ++position;
          }
          parameterValue = removeTrailingHTTPWhitespace(parameterValue);
          if (parameterValue === "") {
            continue;
          }
        }
        if (parameterName.length > 0 && solelyContainsHTTPTokenCodePoints(parameterName) && soleyContainsHTTPQuotedStringTokenCodePoints(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    };
  }
});

// ../node_modules/whatwg-mimetype/lib/serializer.js
var require_serializer = __commonJS({
  "../node_modules/whatwg-mimetype/lib/serializer.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { solelyContainsHTTPTokenCodePoints } = require_utils();
    module2.exports = (mimeType) => {
      let serialization = `${mimeType.type}/${mimeType.subtype}`;
      if (mimeType.parameters.size === 0) {
        return serialization;
      }
      for (let [name, value] of mimeType.parameters) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!solelyContainsHTTPTokenCodePoints(value) || value.length === 0) {
          value = value.replace(/(["\\])/ug, "\\$1");
          value = `"${value}"`;
        }
        serialization += value;
      }
      return serialization;
    };
  }
});

// ../node_modules/whatwg-mimetype/lib/mime-type.js
var require_mime_type = __commonJS({
  "../node_modules/whatwg-mimetype/lib/mime-type.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var MIMETypeParameters = require_mime_type_parameters();
    var parse3 = require_parser2();
    var serialize = require_serializer();
    var {
      asciiLowercase,
      solelyContainsHTTPTokenCodePoints
    } = require_utils();
    module2.exports = class MIMEType {
      static {
        __name(this, "MIMEType");
      }
      constructor(string) {
        string = String(string);
        const result = parse3(string);
        if (result === null) {
          throw new Error(`Could not parse MIME type string "${string}"`);
        }
        this._type = result.type;
        this._subtype = result.subtype;
        this._parameters = new MIMETypeParameters(result.parameters);
      }
      static parse(string) {
        try {
          return new this(string);
        } catch (e) {
          return null;
        }
      }
      get essence() {
        return `${this.type}/${this.subtype}`;
      }
      get type() {
        return this._type;
      }
      set type(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid type: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid type ${value}: must contain only HTTP token code points`);
        }
        this._type = value;
      }
      get subtype() {
        return this._subtype;
      }
      set subtype(value) {
        value = asciiLowercase(String(value));
        if (value.length === 0) {
          throw new Error("Invalid subtype: must be a non-empty string");
        }
        if (!solelyContainsHTTPTokenCodePoints(value)) {
          throw new Error(`Invalid subtype ${value}: must contain only HTTP token code points`);
        }
        this._subtype = value;
      }
      get parameters() {
        return this._parameters;
      }
      toString() {
        return serialize(this);
      }
      isJavaScript({ prohibitParameters = false } = {}) {
        switch (this._type) {
          case "text": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "javascript1.0":
              case "javascript1.1":
              case "javascript1.2":
              case "javascript1.3":
              case "javascript1.4":
              case "javascript1.5":
              case "jscript":
              case "livescript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          case "application": {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "x-ecmascript":
              case "x-javascript": {
                return !prohibitParameters || this._parameters.size === 0;
              }
              default: {
                return false;
              }
            }
          }
          default: {
            return false;
          }
        }
      }
      isXML() {
        return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
      }
      isHTML() {
        return this._subtype === "html" && this._type === "text";
      }
    };
  }
});

// ../node_modules/@apollo/server/dist/esm/utils/UnreachableCaseError.js
var UnreachableCaseError;
var init_UnreachableCaseError = __esm({
  "../node_modules/@apollo/server/dist/esm/utils/UnreachableCaseError.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UnreachableCaseError = class extends Error {
      static {
        __name(this, "UnreachableCaseError");
      }
      constructor(val) {
        super(`Unreachable case: ${val}`);
      }
    };
  }
});

// ../node_modules/@apollo/server/dist/esm/utils/computeCoreSchemaHash.js
function computeCoreSchemaHash(schema) {
  return (0, import_utils23.createHash)("sha256").update(schema).digest("hex");
}
var import_utils23;
var init_computeCoreSchemaHash = __esm({
  "../node_modules/@apollo/server/dist/esm/utils/computeCoreSchemaHash.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_utils23 = __toESM(require_dist3(), 1);
    __name(computeCoreSchemaHash, "computeCoreSchemaHash");
  }
});

// ../node_modules/lru-cache/index.mjs
var perf, hasAbortController, AC, hasAbortSignal, hasACAbortSignal, AS, warned, deprecatedOption, deprecatedMethod, deprecatedProperty, emitWarning2, shouldWarn, warn3, isPosInt, getUintArray, ZeroArray, Stack, LRUCache, lru_cache_default;
var init_lru_cache = __esm({
  "../node_modules/lru-cache/index.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    hasAbortController = typeof AbortController === "function";
    AC = hasAbortController ? AbortController : class AbortController2 {
      static {
        __name(this, "AbortController");
      }
      constructor() {
        this.signal = new AS();
      }
      abort(reason = new Error("This operation was aborted")) {
        this.signal.reason = this.signal.reason || reason;
        this.signal.aborted = true;
        this.signal.dispatchEvent({
          type: "abort",
          target: this.signal
        });
      }
    };
    hasAbortSignal = typeof AbortSignal === "function";
    hasACAbortSignal = typeof AC.AbortSignal === "function";
    AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal2 {
      static {
        __name(this, "AbortSignal");
      }
      constructor() {
        this.reason = void 0;
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(e) {
        if (e.type === "abort") {
          this.aborted = true;
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    warned = /* @__PURE__ */ new Set();
    deprecatedOption = /* @__PURE__ */ __name((opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn3(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    }, "deprecatedOption");
    deprecatedMethod = /* @__PURE__ */ __name((method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, method);
        warn3(code, `${method} method`, `cache.${instead}()`, get);
      }
    }, "deprecatedMethod");
    deprecatedProperty = /* @__PURE__ */ __name((field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get } = Object.getOwnPropertyDescriptor(prototype, field);
        warn3(code, `${field} property`, `cache.${instead}`, get);
      }
    }, "deprecatedProperty");
    emitWarning2 = /* @__PURE__ */ __name((...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    }, "emitWarning");
    shouldWarn = /* @__PURE__ */ __name((code) => !warned.has(code), "shouldWarn");
    warn3 = /* @__PURE__ */ __name((code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning2(msg, "DeprecationWarning", code, fn);
    }, "warn");
    isPosInt = /* @__PURE__ */ __name((n) => n && n === Math.floor(n) && n > 0 && isFinite(n), "isPosInt");
    getUintArray = /* @__PURE__ */ __name((max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null, "getUintArray");
    ZeroArray = class extends Array {
      static {
        __name(this, "ZeroArray");
      }
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    Stack = class {
      static {
        __name(this, "Stack");
      }
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    LRUCache = class _LRUCache {
      static {
        __name(this, "LRUCache");
      }
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          maxEntrySize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize or maxEntrySize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError(
                "maxSize must be a positive integer if specified"
              );
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError(
              "maxEntrySize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning2(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        this.statusTTL = (status, index) => {
          if (status) {
            status.ttl = this.ttls[index];
            status.start = this.starts[index];
            status.now = cachedNow || getNow();
            status.remainingTTL = status.now + status.ttl - status.start;
          }
        };
        let cachedNow = 0;
        const getNow = /* @__PURE__ */ __name(() => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        }, "getNow");
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(_index) {
      }
      statusTTL(_status, _index) {
      }
      setItemTTL(_index, _ttl, _start) {
      }
      isStale(_index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (this.isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size, status) => {
          this.sizes[index] = size;
          if (this.maxSize) {
            const maxSize = this.maxSize - this.sizes[index];
            while (this.calculatedSize > maxSize) {
              this.evict(true);
            }
          }
          this.calculatedSize += this.sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.calculatedSize;
          }
        };
      }
      removeItemSize(_index) {
      }
      addItemSize(_index, _size) {
      }
      requireSize(_k, _v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize or maxEntrySize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return index !== void 0 && this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          if (this.valList[i] !== void 0 && this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          if (this.valList[i] !== void 0 && this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          if (this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          if (this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *values() {
        for (const i of this.indexes()) {
          if (this.valList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          if (this.valList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions) {
        for (const i of this.indexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          if (fn(value, this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(_v, _k, _reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        status
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size, status);
          if (status) {
            status.set = "add";
          }
          noUpdateTTL = false;
        } else {
          this.moveToTail(index);
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, size, status);
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0) status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        this.statusTTL(status, index);
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            if (status) status.has = "hit";
            this.statusTTL(status, index);
            return true;
          } else if (status) {
            status.has = "stale";
            this.statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context2) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        if (options.signal) {
          options.signal.addEventListener(
            "abort",
            () => ac.abort(options.signal.reason)
          );
        }
        const fetchOpts = {
          signal: ac.signal,
          options,
          context: context2
        };
        const cb = /* @__PURE__ */ __name((v2, updateCache = false) => {
          const { aborted: aborted2 } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted2 && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort) options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted2 && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          if (this.valList[index] === p) {
            if (v2 === void 0) {
              if (p.__staleWhileFetching) {
                this.valList[index] = p.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              if (options.status) options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        }, "cb");
        const eb = /* @__PURE__ */ __name((er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        }, "eb");
        const fetchFail = /* @__PURE__ */ __name((er) => {
          const { aborted: aborted2 } = ac.signal;
          const allowStaleAborted = aborted2 && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          if (this.valList[index] === p) {
            const del = !noDelete || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && p.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return p.__staleWhileFetching;
          } else if (p.__returned === p) {
            throw er;
          }
        }, "fetchFail");
        const pcall = /* @__PURE__ */ __name((res, rej) => {
          this.fetchMethod(k, v, fetchOpts).then((v2) => res(v2), rej);
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res();
              if (options.allowStaleOnFetchAbort) {
                res = /* @__PURE__ */ __name((v2) => cb(v2, true), "res");
              }
            }
          });
        }, "pcall");
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, { ...fetchOpts.options, status: void 0 });
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        fetchContext = this.fetchContext,
        forceRefresh = false,
        status,
        signal
      } = {}) {
        if (!this.fetchMethod) {
          if (status) status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          if (status) status.fetch = "miss";
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale) status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.isStale(index);
          if (!forceRefresh && !isStale) {
            if (status) status.fetch = "hit";
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            this.statusTTL(status, index);
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = hasStale && isStale ? "stale" : "refresh";
            if (staleVal && isStale) status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        status
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          this.statusTTL(status, index);
          if (this.isStale(index)) {
            if (status) status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status) status.returnedStale = allowStale;
              return allowStale ? value : void 0;
            } else {
              if (status) {
                status.returnedStale = allowStale && value.__staleWhileFetching !== void 0;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status) status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    lru_cache_default = LRUCache;
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/cacheControl/index.js
var cacheControl_exports = {};
__export(cacheControl_exports, {
  ApolloServerPluginCacheControl: () => ApolloServerPluginCacheControl
});
function ApolloServerPluginCacheControl(options = /* @__PURE__ */ Object.create(null)) {
  let typeAnnotationCache;
  let fieldAnnotationCache;
  return internalPlugin({
    __internal_plugin_id__: "CacheControl",
    __is_disabled_plugin__: false,
    async serverWillStart({ schema }) {
      typeAnnotationCache = new lru_cache_default({
        max: Object.values(schema.getTypeMap()).filter(import_graphql37.isCompositeType).length
      });
      fieldAnnotationCache = new lru_cache_default({
        max: Object.values(schema.getTypeMap()).filter(import_graphql37.isObjectType).flatMap((t) => Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(import_graphql37.isInterfaceType).flatMap((t) => Object.values(t.getFields())).length
      });
      return void 0;
    },
    async requestDidStart(requestContext) {
      function memoizedCacheAnnotationFromType(t) {
        const existing = typeAnnotationCache.get(t);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromType(t);
        typeAnnotationCache.set(t, annotation);
        return annotation;
      }
      __name(memoizedCacheAnnotationFromType, "memoizedCacheAnnotationFromType");
      function memoizedCacheAnnotationFromField(field) {
        const existing = fieldAnnotationCache.get(field);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromField(field);
        fieldAnnotationCache.set(field, annotation);
        return annotation;
      }
      __name(memoizedCacheAnnotationFromField, "memoizedCacheAnnotationFromField");
      const defaultMaxAge = options.defaultMaxAge ?? 0;
      const calculateHttpHeaders = options.calculateHttpHeaders ?? true;
      const { __testing__cacheHints } = options;
      return {
        async executionDidStart() {
          if (isRestricted(requestContext.overallCachePolicy)) {
            const fakeFieldPolicy = newCachePolicy();
            return {
              willResolveField({ info: info3 }) {
                info3.cacheControl = {
                  setCacheHint: /* @__PURE__ */ __name((dynamicHint) => {
                    fakeFieldPolicy.replace(dynamicHint);
                  }, "setCacheHint"),
                  cacheHint: fakeFieldPolicy,
                  cacheHintFromType: memoizedCacheAnnotationFromType
                };
              }
            };
          }
          return {
            willResolveField({ info: info3 }) {
              const fieldPolicy = newCachePolicy();
              let inheritMaxAge = false;
              const targetType = (0, import_graphql37.getNamedType)(info3.returnType);
              if ((0, import_graphql37.isCompositeType)(targetType)) {
                const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                fieldPolicy.replace(typeAnnotation);
                inheritMaxAge = !!typeAnnotation.inheritMaxAge;
              }
              const fieldAnnotation = memoizedCacheAnnotationFromField(info3.parentType.getFields()[info3.fieldName]);
              if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === void 0) {
                inheritMaxAge = true;
                if (fieldAnnotation.scope) {
                  fieldPolicy.replace({ scope: fieldAnnotation.scope });
                }
              } else {
                fieldPolicy.replace(fieldAnnotation);
              }
              info3.cacheControl = {
                setCacheHint: /* @__PURE__ */ __name((dynamicHint) => {
                  fieldPolicy.replace(dynamicHint);
                }, "setCacheHint"),
                cacheHint: fieldPolicy,
                cacheHintFromType: memoizedCacheAnnotationFromType
              };
              return () => {
                if (fieldPolicy.maxAge === void 0 && ((0, import_graphql37.isCompositeType)(targetType) && !inheritMaxAge || !info3.path.prev)) {
                  fieldPolicy.restrict({ maxAge: defaultMaxAge });
                }
                if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                  const path = (0, import_graphql37.responsePathAsArray)(info3.path).join(".");
                  if (__testing__cacheHints.has(path)) {
                    throw Error("shouldn't happen: addHint should only be called once per path");
                  }
                  __testing__cacheHints.set(path, {
                    maxAge: fieldPolicy.maxAge,
                    scope: fieldPolicy.scope
                  });
                }
                requestContext.overallCachePolicy.restrict(fieldPolicy);
              };
            }
          };
        },
        async willSendResponse(requestContext2) {
          if (!calculateHttpHeaders) {
            return;
          }
          const { response, overallCachePolicy } = requestContext2;
          const existingCacheControlHeader = parseExistingCacheControlHeader(response.http.headers.get("cache-control"));
          if (existingCacheControlHeader.kind === "unparsable") {
            return;
          }
          const cachePolicy = newCachePolicy();
          cachePolicy.replace(overallCachePolicy);
          if (existingCacheControlHeader.kind === "parsable-and-cacheable") {
            cachePolicy.restrict(existingCacheControlHeader.hint);
          }
          const policyIfCacheable = cachePolicy.policyIfCacheable();
          if (policyIfCacheable && existingCacheControlHeader.kind !== "uncacheable" && response.body.kind === "single" && !response.body.singleResult.errors) {
            response.http.headers.set("cache-control", `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
          } else if (calculateHttpHeaders !== "if-cacheable") {
            response.http.headers.set("cache-control", CACHE_CONTROL_HEADER_UNCACHEABLE);
          }
        }
      };
    }
  });
}
function parseExistingCacheControlHeader(header) {
  if (!header) {
    return { kind: "no-header" };
  }
  if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {
    return { kind: "uncacheable" };
  }
  const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);
  if (!match) {
    return { kind: "unparsable" };
  }
  return {
    kind: "parsable-and-cacheable",
    hint: {
      maxAge: +match[1],
      scope: match[2] === "public" ? "PUBLIC" : "PRIVATE"
    }
  };
}
function cacheAnnotationFromDirectives(directives) {
  if (!directives)
    return void 0;
  const cacheControlDirective = directives.find((directive) => directive.name.value === "cacheControl");
  if (!cacheControlDirective)
    return void 0;
  if (!cacheControlDirective.arguments)
    return void 0;
  const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "maxAge");
  const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "scope");
  const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === "inheritMaxAge");
  const scopeString = scopeArgument?.value?.kind === "EnumValue" ? scopeArgument.value.value : void 0;
  const scope = scopeString === "PUBLIC" || scopeString === "PRIVATE" ? scopeString : void 0;
  if (inheritMaxAgeArgument?.value?.kind === "BooleanValue" && inheritMaxAgeArgument.value.value) {
    return { inheritMaxAge: true, scope };
  }
  return {
    maxAge: maxAgeArgument?.value?.kind === "IntValue" ? parseInt(maxAgeArgument.value.value) : void 0,
    scope
  };
}
function cacheAnnotationFromType(t) {
  if (t.astNode) {
    const hint = cacheAnnotationFromDirectives(t.astNode.directives);
    if (hint) {
      return hint;
    }
  }
  if (t.extensionASTNodes) {
    for (const node of t.extensionASTNodes) {
      const hint = cacheAnnotationFromDirectives(node.directives);
      if (hint) {
        return hint;
      }
    }
  }
  return {};
}
function cacheAnnotationFromField(field) {
  if (field.astNode) {
    const hint = cacheAnnotationFromDirectives(field.astNode.directives);
    if (hint) {
      return hint;
    }
  }
  return {};
}
function isRestricted(hint) {
  return hint.maxAge !== void 0 || hint.scope !== void 0;
}
var import_graphql37, CACHE_CONTROL_HEADER_CACHEABLE_REGEXP, CACHE_CONTROL_HEADER_UNCACHEABLE;
var init_cacheControl = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/cacheControl/index.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_graphql37 = __toESM(require_graphql2(), 1);
    init_cachePolicy();
    init_internalPlugin();
    init_lru_cache();
    __name(ApolloServerPluginCacheControl, "ApolloServerPluginCacheControl");
    CACHE_CONTROL_HEADER_CACHEABLE_REGEXP = /^max-age=(\d+), (public|private)$/;
    CACHE_CONTROL_HEADER_UNCACHEABLE = "no-store";
    __name(parseExistingCacheControlHeader, "parseExistingCacheControlHeader");
    __name(cacheAnnotationFromDirectives, "cacheAnnotationFromDirectives");
    __name(cacheAnnotationFromType, "cacheAnnotationFromType");
    __name(cacheAnnotationFromField, "cacheAnnotationFromField");
    __name(isRestricted, "isRestricted");
  }
});

// ../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(/* @__PURE__ */ __name(function executor(resolve, reject) {
        params[offset] = /* @__PURE__ */ __name(function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        }, "callback");
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      }, "executor"));
    }
    __name(asPromise, "asPromise");
  }
});

// ../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var base64 = exports2;
    base64.length = /* @__PURE__ */ __name(function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    }, "length");
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = /* @__PURE__ */ __name(function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    }, "encode");
    var invalidEncoding = "invalid encoding";
    base64.decode = /* @__PURE__ */ __name(function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    }, "decode");
    base64.test = /* @__PURE__ */ __name(function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    }, "test");
  }
});

// ../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = EventEmitter2;
    function EventEmitter2() {
      this._listeners = {};
    }
    __name(EventEmitter2, "EventEmitter");
    EventEmitter2.prototype.on = /* @__PURE__ */ __name(function on2(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    }, "on");
    EventEmitter2.prototype.off = /* @__PURE__ */ __name(function off2(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners2 = this._listeners[evt];
          for (var i = 0; i < listeners2.length; )
            if (listeners2[i].fn === fn)
              listeners2.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    }, "off");
    EventEmitter2.prototype.emit = /* @__PURE__ */ __name(function emit2(evt) {
      var listeners2 = this._listeners[evt];
      if (listeners2) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners2.length; )
          listeners2[i].fn.apply(listeners2[i++].ctx, args);
      }
      return this;
    }, "emit");
  }
});

// ../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        __name(writeFloat_f32_cpy, "writeFloat_f32_cpy");
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        __name(writeFloat_f32_rev, "writeFloat_f32_rev");
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        __name(readFloat_f32_cpy, "readFloat_f32_cpy");
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        __name(readFloat_f32_rev, "readFloat_f32_rev");
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign3 = val < 0 ? 1 : 0;
          if (sign3)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign3 << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign3 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign3 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        __name(writeFloat_ieee754, "writeFloat_ieee754");
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign3 = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 1401298464324817e-60 * mantissa : sign3 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        __name(readFloat_ieee754, "readFloat_ieee754");
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        __name(writeDouble_f64_cpy, "writeDouble_f64_cpy");
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        __name(writeDouble_f64_rev, "writeDouble_f64_rev");
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        __name(readDouble_f64_cpy, "readDouble_f64_cpy");
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        __name(readDouble_f64_rev, "readDouble_f64_rev");
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign3 = val < 0 ? 1 : 0;
          if (sign3)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign3 << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign3 << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign3 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        __name(writeDouble_ieee754, "writeDouble_ieee754");
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign3 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign3 * Infinity : exponent === 0 ? sign3 * 5e-324 * mantissa : sign3 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        __name(readDouble_ieee754, "readDouble_ieee754");
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    __name(factory, "factory");
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeUintLE, "writeUintLE");
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    __name(writeUintBE, "writeUintBE");
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    __name(readUintLE, "readUintLE");
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
    __name(readUintBE, "readUintBE");
  }
});

// ../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
    __name(inquire, "inquire");
  }
});

// ../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utf8 = exports2;
    utf8.length = /* @__PURE__ */ __name(function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    }, "utf8_length");
    utf8.read = /* @__PURE__ */ __name(function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    }, "utf8_read");
    utf8.write = /* @__PURE__ */ __name(function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }, "utf8_write");
  }
});

// ../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return /* @__PURE__ */ __name(function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      }, "pool_alloc");
    }
    __name(pool, "pool");
  }
});

// ../node_modules/@apollo/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../node_modules/@apollo/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    __name(LongBits, "LongBits");
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = /* @__PURE__ */ __name(function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign3 = value < 0;
      if (sign3)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign3) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    }, "fromNumber");
    LongBits.from = /* @__PURE__ */ __name(function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }, "from");
    LongBits.prototype.toNumber = /* @__PURE__ */ __name(function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }, "toNumber");
    LongBits.prototype.toLong = /* @__PURE__ */ __name(function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    }, "toLong");
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = /* @__PURE__ */ __name(function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
        (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
      );
    }, "fromHash");
    LongBits.prototype.toHash = /* @__PURE__ */ __name(function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    }, "toHash");
    LongBits.prototype.zzEncode = /* @__PURE__ */ __name(function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }, "zzEncode");
    LongBits.prototype.zzDecode = /* @__PURE__ */ __name(function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }, "zzDecode");
    LongBits.prototype.length = /* @__PURE__ */ __name(function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }, "length");
  }
});

// ../node_modules/@apollo/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../node_modules/@apollo/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.global = typeof window !== "undefined" && window || typeof global !== "undefined" && global || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    /* @__PURE__ */ __name(function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }, "isInteger");
    util.isString = /* @__PURE__ */ __name(function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }, "isString");
    util.isObject = /* @__PURE__ */ __name(function isObject3(value) {
      return value && typeof value === "object";
    }, "isObject");
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = /* @__PURE__ */ __name(function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    }, "isSet");
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = /* @__PURE__ */ __name(function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    }, "newBuffer");
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = typeof process === "undefined" || process.env.ENABLE_LONG ? (
      /* istanbul ignore next */
      util.global.dcodeIO && /* istanbul ignore next */
      util.global.dcodeIO.Long || /* istanbul ignore next */
      util.global.Long || util.inquire("long")
    ) : void 0;
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = /* @__PURE__ */ __name(function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    }, "longToHash");
    util.longFromHash = /* @__PURE__ */ __name(function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    }, "longFromHash");
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    __name(merge, "merge");
    util.merge = merge;
    util.lcFirst = /* @__PURE__ */ __name(function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    }, "lcFirst");
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: /* @__PURE__ */ __name(function() {
          return message;
        }, "get") });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      __name(CustomError, "CustomError");
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: /* @__PURE__ */ __name(function() {
        return name;
      }, "get") });
      CustomError.prototype.toString = /* @__PURE__ */ __name(function toString() {
        return this.name + ": " + this.message;
      }, "toString");
      return CustomError;
    }
    __name(newError, "newError");
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = /* @__PURE__ */ __name(function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    }, "getOneOf");
    util.oneOfSetter = /* @__PURE__ */ __name(function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    }, "setOneOf");
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      }, "Buffer_from");
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      }, "Buffer_allocUnsafe");
    };
  }
});

// ../node_modules/@apollo/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../node_modules/@apollo/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(Op, "Op");
    function noop() {
    }
    __name(noop, "noop");
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    __name(State, "State");
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    __name(Writer, "Writer");
    Writer.create = util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup() {
      return (Writer.create = /* @__PURE__ */ __name(function create_buffer() {
        return new BufferWriter();
      }, "create_buffer"))();
    }, "create_buffer_setup") : /* @__PURE__ */ __name(function create_array() {
      return new Writer();
    }, "create_array");
    Writer.alloc = /* @__PURE__ */ __name(function alloc(size) {
      return new util.Array(size);
    }, "alloc");
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = /* @__PURE__ */ __name(function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }, "push");
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    __name(writeByte, "writeByte");
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    __name(writeVarint32, "writeVarint32");
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(VarintOp, "VarintOp");
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = /* @__PURE__ */ __name(function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    }, "write_uint32");
    Writer.prototype.int32 = /* @__PURE__ */ __name(function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    }, "write_int32");
    Writer.prototype.sint32 = /* @__PURE__ */ __name(function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }, "write_sint32");
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    __name(writeVarint64, "writeVarint64");
    Writer.prototype.uint64 = /* @__PURE__ */ __name(function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_uint64");
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = /* @__PURE__ */ __name(function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_sint64");
    Writer.prototype.bool = /* @__PURE__ */ __name(function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    }, "write_bool");
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeFixed32, "writeFixed32");
    Writer.prototype.fixed32 = /* @__PURE__ */ __name(function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    }, "write_fixed32");
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = /* @__PURE__ */ __name(function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }, "write_fixed64");
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = /* @__PURE__ */ __name(function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    }, "write_float");
    Writer.prototype.double = /* @__PURE__ */ __name(function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    }, "write_double");
    var writeBytes = util.Array.prototype.set ? /* @__PURE__ */ __name(function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytes_set") : /* @__PURE__ */ __name(function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    }, "writeBytes_for");
    Writer.prototype.bytes = /* @__PURE__ */ __name(function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    }, "write_bytes");
    Writer.prototype.string = /* @__PURE__ */ __name(function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    }, "write_string");
    Writer.prototype.fork = /* @__PURE__ */ __name(function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }, "fork");
    Writer.prototype.reset = /* @__PURE__ */ __name(function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }, "reset");
    Writer.prototype.ldelim = /* @__PURE__ */ __name(function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }, "ldelim");
    Writer.prototype.finish = /* @__PURE__ */ __name(function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }, "finish");
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
    };
  }
});

// ../node_modules/@apollo/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../node_modules/@apollo/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    var Buffer2 = util.Buffer;
    function BufferWriter() {
      Writer.call(this);
    }
    __name(BufferWriter, "BufferWriter");
    BufferWriter.alloc = /* @__PURE__ */ __name(function alloc_buffer(size) {
      return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
    }, "alloc_buffer");
    var writeBytesBuffer = Buffer2 && Buffer2.prototype instanceof Uint8Array && Buffer2.prototype.set.name === "set" ? /* @__PURE__ */ __name(function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytesBuffer_set") : /* @__PURE__ */ __name(function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else for (var i = 0; i < val.length; )
        buf[pos++] = val[i++];
    }, "writeBytesBuffer_copy");
    BufferWriter.prototype.bytes = /* @__PURE__ */ __name(function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(writeBytesBuffer, len, value);
      return this;
    }, "write_bytes_buffer");
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else
        buf.utf8Write(val, pos);
    }
    __name(writeStringBuffer, "writeStringBuffer");
    BufferWriter.prototype.string = /* @__PURE__ */ __name(function write_string_buffer(value) {
      var len = Buffer2.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    }, "write_string_buffer");
  }
});

// ../node_modules/@apollo/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../node_modules/@apollo/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    __name(indexOutOfRange, "indexOutOfRange");
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    __name(Reader, "Reader");
    var create_array = typeof Uint8Array !== "undefined" ? /* @__PURE__ */ __name(function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_typed_array") : /* @__PURE__ */ __name(function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_array");
    Reader.create = util.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup(buffer) {
      return (Reader.create = /* @__PURE__ */ __name(function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      }, "create_buffer"))(buffer);
    }, "create_buffer_setup") : create_array;
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = (/* @__PURE__ */ __name(function read_uint32_setup() {
      var value = 4294967295;
      return /* @__PURE__ */ __name(function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      }, "read_uint32");
    }, "read_uint32_setup"))();
    Reader.prototype.int32 = /* @__PURE__ */ __name(function read_int32() {
      return this.uint32() | 0;
    }, "read_int32");
    Reader.prototype.sint32 = /* @__PURE__ */ __name(function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }, "read_sint32");
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    __name(readLongVarint, "readLongVarint");
    Reader.prototype.bool = /* @__PURE__ */ __name(function read_bool() {
      return this.uint32() !== 0;
    }, "read_bool");
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    __name(readFixed32_end, "readFixed32_end");
    Reader.prototype.fixed32 = /* @__PURE__ */ __name(function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    }, "read_fixed32");
    Reader.prototype.sfixed32 = /* @__PURE__ */ __name(function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    }, "read_sfixed32");
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    __name(readFixed64, "readFixed64");
    Reader.prototype.float = /* @__PURE__ */ __name(function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }, "read_float");
    Reader.prototype.double = /* @__PURE__ */ __name(function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }, "read_double");
    Reader.prototype.bytes = /* @__PURE__ */ __name(function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    }, "read_bytes");
    Reader.prototype.string = /* @__PURE__ */ __name(function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    }, "read_string");
    Reader.prototype.skip = /* @__PURE__ */ __name(function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    }, "skip");
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: /* @__PURE__ */ __name(function read_int64() {
          return readLongVarint.call(this)[fn](false);
        }, "read_int64"),
        uint64: /* @__PURE__ */ __name(function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        }, "read_uint64"),
        sint64: /* @__PURE__ */ __name(function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        }, "read_sint64"),
        fixed64: /* @__PURE__ */ __name(function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        }, "read_fixed64"),
        sfixed64: /* @__PURE__ */ __name(function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }, "read_sfixed64")
      });
    };
  }
});

// ../node_modules/@apollo/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../node_modules/@apollo/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    __name(BufferReader, "BufferReader");
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
    BufferReader.prototype.string = /* @__PURE__ */ __name(function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
    }, "read_string_buffer");
  }
});

// ../node_modules/@apollo/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../node_modules/@apollo/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    __name(Service, "Service");
    Service.prototype.rpcCall = /* @__PURE__ */ __name(function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          /* @__PURE__ */ __name(function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }, "rpcCallback")
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    }, "rpcCall");
    Service.prototype.end = /* @__PURE__ */ __name(function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    }, "end");
  }
});

// ../node_modules/@apollo/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../node_modules/@apollo/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../node_modules/@apollo/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../node_modules/@apollo/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = {};
  }
});

// ../node_modules/@apollo/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../node_modules/@apollo/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.Reader._configure(protobuf.BufferReader);
      protobuf.util._configure();
    }
    __name(configure, "configure");
    protobuf.Writer._configure(protobuf.BufferWriter);
    configure();
  }
});

// ../node_modules/@apollo/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../node_modules/@apollo/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = require_index_minimal();
  }
});

// ../node_modules/@apollo/usage-reporting-protobuf/generated/esm/protobuf.js
var import_minimal, $Reader, $Writer, $util, $root, Trace, ReportHeader, PathErrorStats, QueryLatencyStats, StatsContext, ContextualizedQueryLatencyStats, ContextualizedTypeStats, FieldStat, TypeStat, ReferencedFieldsForType, Report, ContextualizedStats, TracesAndStats, google;
var init_protobuf = __esm({
  "../node_modules/@apollo/usage-reporting-protobuf/generated/esm/protobuf.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_minimal = __toESM(require_minimal2(), 1);
    $Reader = import_minimal.default.Reader;
    $Writer = import_minimal.default.Writer;
    $util = import_minimal.default.util;
    $root = import_minimal.default.roots["default"] || (import_minimal.default.roots["default"] = {});
    Trace = $root.Trace = (() => {
      function Trace2(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Trace2, "Trace");
      Trace2.prototype.startTime = null;
      Trace2.prototype.endTime = null;
      Trace2.prototype.durationNs = 0;
      Trace2.prototype.root = null;
      Trace2.prototype.isIncomplete = false;
      Trace2.prototype.signature = "";
      Trace2.prototype.unexecutedOperationBody = "";
      Trace2.prototype.unexecutedOperationName = "";
      Trace2.prototype.details = null;
      Trace2.prototype.clientName = "";
      Trace2.prototype.clientVersion = "";
      Trace2.prototype.http = null;
      Trace2.prototype.cachePolicy = null;
      Trace2.prototype.queryPlan = null;
      Trace2.prototype.fullQueryCacheHit = false;
      Trace2.prototype.persistedQueryHit = false;
      Trace2.prototype.persistedQueryRegister = false;
      Trace2.prototype.registeredOperation = false;
      Trace2.prototype.forbiddenOperation = false;
      Trace2.prototype.fieldExecutionWeight = 0;
      Trace2.create = /* @__PURE__ */ __name(function create(properties) {
        return new Trace2(properties);
      }, "create");
      Trace2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      }, "encode");
      Trace2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Trace2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Trace2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Trace2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          let error3 = $root.google.protobuf.Timestamp.verify(message.startTime);
          if (error3)
            return "startTime." + error3;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          let error3 = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          let error3 = $root.Trace.Node.verify(message.root);
          if (error3)
            return "root." + error3;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          let error3 = $root.Trace.Details.verify(message.details);
          if (error3)
            return "details." + error3;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          let error3 = $root.Trace.HTTP.verify(message.http);
          if (error3)
            return "http." + error3;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          let error3 = $root.Trace.CachePolicy.verify(message.cachePolicy);
          if (error3)
            return "cachePolicy." + error3;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          let error3 = $root.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error3)
            return "queryPlan." + error3;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      }, "verify");
      Trace2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      }, "toObject");
      Trace2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      Trace2.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(CachePolicy, "CachePolicy");
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = /* @__PURE__ */ __name(function create(properties) {
          return new CachePolicy(properties);
        }, "create");
        CachePolicy.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        }, "encode");
        CachePolicy.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        CachePolicy.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        CachePolicy.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        CachePolicy.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        }, "verify");
        CachePolicy.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        }, "toObject");
        CachePolicy.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
        }, "toJSON");
        CachePolicy.Scope = function() {
          const valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace2.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Details, "Details");
        Details.prototype.variablesJson = $util.emptyObject;
        Details.prototype.operationName = "";
        Details.create = /* @__PURE__ */ __name(function create(properties) {
          return new Details(properties);
        }, "create");
        Details.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (let keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        }, "encode");
        Details.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Details.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Details.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Details.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util.isObject(message.variablesJson))
              return "variablesJson: object expected";
            let key = Object.keys(message.variablesJson);
            for (let i = 0; i < key.length; ++i)
              if (!$util.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        }, "verify");
        Details.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          let keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (let j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        }, "toObject");
        Details.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
        }, "toJSON");
        return Details;
      }();
      Trace2.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Error2, "Error");
        Error2.prototype.message = "";
        Error2.prototype.location = $util.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = /* @__PURE__ */ __name(function create(properties) {
          return new Error2(properties);
        }, "create");
        Error2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (let i = 0; i < message.location.length; ++i)
              $root.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        }, "encode");
        Error2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Error2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Error();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Error2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Error2.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (let i = 0; i < message.location.length; ++i) {
              let error3 = $root.Trace.Location.verify(message.location[i]);
              if (error3)
                return "location." + error3;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util.isString(message.json))
              return "json: string expected";
          }
          return null;
        }, "verify");
        Error2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (let j = 0; j < message.location.length; ++j)
              object.location[j] = $root.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        }, "toObject");
        Error2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
        }, "toJSON");
        return Error2;
      }();
      Trace2.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(HTTP, "HTTP");
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util.emptyObject;
        HTTP.prototype.responseHeaders = $util.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = /* @__PURE__ */ __name(function create(properties) {
          return new HTTP(properties);
        }, "create");
        HTTP.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (let keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (let keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        }, "encode");
        HTTP.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        HTTP.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        HTTP.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        HTTP.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            let key = Object.keys(message.requestHeaders);
            for (let i = 0; i < key.length; ++i) {
              let error3 = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error3)
                return "requestHeaders." + error3;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            let key = Object.keys(message.responseHeaders);
            for (let i = 0; i < key.length; ++i) {
              let error3 = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error3)
                return "responseHeaders." + error3;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        }, "verify");
        HTTP.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;
          let keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (let j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (let j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        }, "toObject");
        HTTP.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
        }, "toJSON");
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Values, "Values");
          Values.prototype.value = $util.emptyArray;
          Values.create = /* @__PURE__ */ __name(function create(properties) {
            return new Values(properties);
          }, "create");
          Values.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.value != null && message.value.length)
              for (let i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          }, "encode");
          Values.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Values.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Values.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Values.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (let i = 0; i < message.value.length; ++i)
                if (!$util.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          }, "verify");
          Values.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (let j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          }, "toObject");
          Values.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return Values;
        }();
        HTTP.Method = function() {
          const valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace2.Location = function() {
        function Location(properties) {
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Location, "Location");
        Location.prototype.line = 0;
        Location.prototype.column = 0;
        Location.create = /* @__PURE__ */ __name(function create(properties) {
          return new Location(properties);
        }, "create");
        Location.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        }, "encode");
        Location.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Location.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Location();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Location.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Location.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        }, "verify");
        Location.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        }, "toObject");
        Location.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
        }, "toJSON");
        return Location;
      }();
      Trace2.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Node, "Node");
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util.emptyArray;
        Node.prototype.child = $util.emptyArray;
        let $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        Node.create = /* @__PURE__ */ __name(function create(properties) {
          return new Node(properties);
        }, "create");
        Node.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (let i = 0; i < message.error.length; ++i)
              $root.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (let i = 0; i < message.child.length; ++i)
              $root.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        }, "encode");
        Node.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Node.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.Node();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Node.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Node.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          let properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            let error3 = $root.Trace.CachePolicy.verify(message.cachePolicy);
            if (error3)
              return "cachePolicy." + error3;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (let i = 0; i < message.error.length; ++i) {
              let error3 = $root.Trace.Error.verify(message.error[i]);
              if (error3)
                return "error." + error3;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (let i = 0; i < message.child.length; ++i) {
              let error3 = $root.Trace.Node.verify(message.child[i]);
              if (error3)
                return "child." + error3;
            }
          }
          return null;
        }, "verify");
        Node.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (let j = 0; j < message.error.length; ++j)
              object.error[j] = $root.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (let j = 0; j < message.child.length; ++j)
              object.child[j] = $root.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        }, "toObject");
        Node.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
        }, "toJSON");
        return Node;
      }();
      Trace2.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(QueryPlanNode, "QueryPlanNode");
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        let $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = /* @__PURE__ */ __name(function create(properties) {
          return new QueryPlanNode(properties);
        }, "create");
        QueryPlanNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        }, "encode");
        QueryPlanNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        QueryPlanNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();
          while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        QueryPlanNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        QueryPlanNode.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          let properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              let error3 = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error3)
                return "sequence." + error3;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              let error3 = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error3)
                return "parallel." + error3;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              let error3 = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error3)
                return "fetch." + error3;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              let error3 = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error3)
                return "flatten." + error3;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              let error3 = $root.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error3)
                return "defer." + error3;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              let error3 = $root.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error3)
                return "condition." + error3;
            }
          }
          return null;
        }, "verify");
        QueryPlanNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          let object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        }, "toObject");
        QueryPlanNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
        }, "toJSON");
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(SequenceNode, "SequenceNode");
          SequenceNode.prototype.nodes = $util.emptyArray;
          SequenceNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new SequenceNode(properties);
          }, "create");
          SequenceNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (let i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          SequenceNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          SequenceNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          SequenceNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          SequenceNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (let i = 0; i < message.nodes.length; ++i) {
                let error3 = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          SequenceNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (let j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          SequenceNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ParallelNode, "ParallelNode");
          ParallelNode.prototype.nodes = $util.emptyArray;
          ParallelNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ParallelNode(properties);
          }, "create");
          ParallelNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
              for (let i = 0; i < message.nodes.length; ++i)
                $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          ParallelNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ParallelNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ParallelNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ParallelNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (let i = 0; i < message.nodes.length; ++i) {
                let error3 = $root.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          ParallelNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (let j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          ParallelNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FetchNode, "FetchNode");
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FetchNode(properties);
          }, "create");
          FetchNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FetchNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FetchNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FetchNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FetchNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              let error3 = $root.Trace.verify(message.trace);
              if (error3)
                return "trace." + error3;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              let error3 = $root.google.protobuf.Timestamp.verify(message.sentTime);
              if (error3)
                return "sentTime." + error3;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              let error3 = $root.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error3)
                return "receivedTime." + error3;
            }
            return null;
          }, "verify");
          FetchNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          }, "toObject");
          FetchNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FlattenNode, "FlattenNode");
          FlattenNode.prototype.responsePath = $util.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FlattenNode(properties);
          }, "create");
          FlattenNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.responsePath != null && message.responsePath.length)
              for (let i = 0; i < message.responsePath.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FlattenNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FlattenNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FlattenNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FlattenNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (let i = 0; i < message.responsePath.length; ++i) {
                let error3 = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error3)
                  return "responsePath." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              let error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          FlattenNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (let j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          FlattenNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNode, "DeferNode");
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util.emptyArray;
          DeferNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNode(properties);
          }, "create");
          DeferNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (let i = 0; i < message.deferred.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              let error3 = $root.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error3)
                return "primary." + error3;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (let i = 0; i < message.deferred.length; ++i) {
                let error3 = $root.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error3)
                  return "deferred." + error3;
              }
            }
            return null;
          }, "verify");
          DeferNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (let j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          }, "toObject");
          DeferNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ConditionNode, "ConditionNode");
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ConditionNode(properties);
          }, "create");
          ConditionNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          }, "encode");
          ConditionNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ConditionNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ConditionNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ConditionNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              let error3 = $root.Trace.QueryPlanNode.verify(message.ifClause);
              if (error3)
                return "ifClause." + error3;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              let error3 = $root.Trace.QueryPlanNode.verify(message.elseClause);
              if (error3)
                return "elseClause." + error3;
            }
            return null;
          }, "verify");
          ConditionNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          }, "toObject");
          ConditionNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNodePrimary, "DeferNodePrimary");
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNodePrimary(properties);
          }, "create");
          DeferNodePrimary.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNodePrimary.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNodePrimary.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNodePrimary.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNodePrimary.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              let error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferNodePrimary.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferNodePrimary.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNode, "DeferredNode");
          DeferredNode.prototype.depends = $util.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNode(properties);
          }, "create");
          DeferredNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.depends != null && message.depends.length)
              for (let i = 0; i < message.depends.length; ++i)
                $root.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (let i = 0; i < message.path.length; ++i)
                $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferredNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (let i = 0; i < message.depends.length; ++i) {
                let error3 = $root.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error3)
                  return "depends." + error3;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (let i = 0; i < message.path.length; ++i) {
                let error3 = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error3)
                  return "path." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              let error3 = $root.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferredNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (let j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (let j = 0; j < message.path.length; ++j)
                object.path[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferredNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNodeDepends, "DeferredNodeDepends");
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNodeDepends(properties);
          }, "create");
          DeferredNodeDepends.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          }, "encode");
          DeferredNodeDepends.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNodeDepends.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNodeDepends.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNodeDepends.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          }, "verify");
          DeferredNodeDepends.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          }, "toObject");
          DeferredNodeDepends.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ResponsePathElement, "ResponsePathElement");
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          let $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = /* @__PURE__ */ __name(function create(properties) {
            return new ResponsePathElement(properties);
          }, "create");
          ResponsePathElement.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          }, "encode");
          ResponsePathElement.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ResponsePathElement.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ResponsePathElement.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ResponsePathElement.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          }, "verify");
          ResponsePathElement.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          }, "toObject");
          ResponsePathElement.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace2;
    })();
    ReportHeader = $root.ReportHeader = (() => {
      function ReportHeader2(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReportHeader2, "ReportHeader");
      ReportHeader2.prototype.graphRef = "";
      ReportHeader2.prototype.hostname = "";
      ReportHeader2.prototype.agentVersion = "";
      ReportHeader2.prototype.serviceVersion = "";
      ReportHeader2.prototype.runtimeVersion = "";
      ReportHeader2.prototype.uname = "";
      ReportHeader2.prototype.executableSchemaId = "";
      ReportHeader2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReportHeader2(properties);
      }, "create");
      ReportHeader2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      }, "encode");
      ReportHeader2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReportHeader2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReportHeader();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReportHeader2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReportHeader2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      }, "verify");
      ReportHeader2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      }, "toObject");
      ReportHeader2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return ReportHeader2;
    })();
    PathErrorStats = $root.PathErrorStats = (() => {
      function PathErrorStats2(properties) {
        this.children = {};
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(PathErrorStats2, "PathErrorStats");
      PathErrorStats2.prototype.children = $util.emptyObject;
      PathErrorStats2.prototype.errorsCount = 0;
      PathErrorStats2.prototype.requestsWithErrorsCount = 0;
      PathErrorStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new PathErrorStats2(properties);
      }, "create");
      PathErrorStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (let keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      }, "encode");
      PathErrorStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      PathErrorStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      PathErrorStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      PathErrorStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util.isObject(message.children))
            return "children: object expected";
          let key = Object.keys(message.children);
          for (let i = 0; i < key.length; ++i) {
            let error3 = $root.PathErrorStats.verify(message.children[key[i]]);
            if (error3)
              return "children." + error3;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      }, "verify");
      PathErrorStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        let keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (let j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      }, "toObject");
      PathErrorStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return PathErrorStats2;
    })();
    QueryLatencyStats = $root.QueryLatencyStats = (() => {
      function QueryLatencyStats2(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(QueryLatencyStats2, "QueryLatencyStats");
      QueryLatencyStats2.prototype.latencyCount = $util.emptyArray;
      QueryLatencyStats2.prototype.requestCount = 0;
      QueryLatencyStats2.prototype.cacheHits = 0;
      QueryLatencyStats2.prototype.persistedQueryHits = 0;
      QueryLatencyStats2.prototype.persistedQueryMisses = 0;
      QueryLatencyStats2.prototype.cacheLatencyCount = $util.emptyArray;
      QueryLatencyStats2.prototype.rootErrorStats = null;
      QueryLatencyStats2.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats2.prototype.publicCacheTtlCount = $util.emptyArray;
      QueryLatencyStats2.prototype.privateCacheTtlCount = $util.emptyArray;
      QueryLatencyStats2.prototype.registeredOperationCount = 0;
      QueryLatencyStats2.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats2.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new QueryLatencyStats2(properties);
      }, "create");
      QueryLatencyStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        let array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (let i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        let array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (let i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        let array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (let i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        let array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (let i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      }, "encode");
      QueryLatencyStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      QueryLatencyStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      QueryLatencyStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      QueryLatencyStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          let array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (let i = 0; i < array13.length; ++i)
            if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          let array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (let i = 0; i < array14.length; ++i)
            if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          let error3 = $root.PathErrorStats.verify(message.rootErrorStats);
          if (error3)
            return "rootErrorStats." + error3;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          let array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (let i = 0; i < array15.length; ++i)
            if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          let array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (let i = 0; i < array16.length; ++i)
            if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      }, "verify");
      QueryLatencyStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (let j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (let j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (let j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (let j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      }, "toObject");
      QueryLatencyStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return QueryLatencyStats2;
    })();
    StatsContext = $root.StatsContext = (() => {
      function StatsContext2(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(StatsContext2, "StatsContext");
      StatsContext2.prototype.clientName = "";
      StatsContext2.prototype.clientVersion = "";
      StatsContext2.create = /* @__PURE__ */ __name(function create(properties) {
        return new StatsContext2(properties);
      }, "create");
      StatsContext2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      }, "encode");
      StatsContext2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      StatsContext2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.StatsContext();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      StatsContext2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      StatsContext2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      }, "verify");
      StatsContext2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      }, "toObject");
      StatsContext2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return StatsContext2;
    })();
    ContextualizedQueryLatencyStats = $root.ContextualizedQueryLatencyStats = (() => {
      function ContextualizedQueryLatencyStats2(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedQueryLatencyStats2, "ContextualizedQueryLatencyStats");
      ContextualizedQueryLatencyStats2.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats2.prototype.context = null;
      ContextualizedQueryLatencyStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedQueryLatencyStats2(properties);
      }, "create");
      ContextualizedQueryLatencyStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      }, "encode");
      ContextualizedQueryLatencyStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedQueryLatencyStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedQueryLatencyStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedQueryLatencyStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          let error3 = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          let error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        return null;
      }, "verify");
      ContextualizedQueryLatencyStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        return object;
      }, "toObject");
      ContextualizedQueryLatencyStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedQueryLatencyStats2;
    })();
    ContextualizedTypeStats = $root.ContextualizedTypeStats = (() => {
      function ContextualizedTypeStats2(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedTypeStats2, "ContextualizedTypeStats");
      ContextualizedTypeStats2.prototype.context = null;
      ContextualizedTypeStats2.prototype.perTypeStat = $util.emptyObject;
      ContextualizedTypeStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedTypeStats2(properties);
      }, "create");
      ContextualizedTypeStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (let keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedTypeStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedTypeStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedTypeStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedTypeStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          let error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          let key = Object.keys(message.perTypeStat);
          for (let i = 0; i < key.length; ++i) {
            let error3 = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedTypeStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        let keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (let j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedTypeStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedTypeStats2;
    })();
    FieldStat = $root.FieldStat = (() => {
      function FieldStat2(properties) {
        this.latencyCount = [];
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(FieldStat2, "FieldStat");
      FieldStat2.prototype.returnType = "";
      FieldStat2.prototype.errorsCount = 0;
      FieldStat2.prototype.observedExecutionCount = 0;
      FieldStat2.prototype.estimatedExecutionCount = 0;
      FieldStat2.prototype.requestsWithErrorsCount = 0;
      FieldStat2.prototype.latencyCount = $util.emptyArray;
      FieldStat2.create = /* @__PURE__ */ __name(function create(properties) {
        return new FieldStat2(properties);
      }, "create");
      FieldStat2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        let array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (let i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      }, "encode");
      FieldStat2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      FieldStat2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.FieldStat();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                let end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      FieldStat2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      FieldStat2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util.isInteger(message.observedExecutionCount.low) && $util.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util.isInteger(message.estimatedExecutionCount.low) && $util.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          let array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (let i = 0; i < array9.length; ++i)
            if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      }, "verify");
      FieldStat2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (let j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      }, "toObject");
      FieldStat2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return FieldStat2;
    })();
    TypeStat = $root.TypeStat = (() => {
      function TypeStat2(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TypeStat2, "TypeStat");
      TypeStat2.prototype.perFieldStat = $util.emptyObject;
      TypeStat2.create = /* @__PURE__ */ __name(function create(properties) {
        return new TypeStat2(properties);
      }, "create");
      TypeStat2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (let keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TypeStat2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TypeStat2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TypeStat2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TypeStat2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          let key = Object.keys(message.perFieldStat);
          for (let i = 0; i < key.length; ++i) {
            let error3 = $root.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error3)
              return "perFieldStat." + error3;
          }
        }
        return null;
      }, "verify");
      TypeStat2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        let keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (let j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TypeStat2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return TypeStat2;
    })();
    ReferencedFieldsForType = $root.ReferencedFieldsForType = (() => {
      function ReferencedFieldsForType2(properties) {
        this.fieldNames = [];
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReferencedFieldsForType2, "ReferencedFieldsForType");
      ReferencedFieldsForType2.prototype.fieldNames = $util.emptyArray;
      ReferencedFieldsForType2.prototype.isInterface = false;
      ReferencedFieldsForType2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReferencedFieldsForType2(properties);
      }, "create");
      ReferencedFieldsForType2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (let i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      }, "encode");
      ReferencedFieldsForType2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReferencedFieldsForType2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ReferencedFieldsForType();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReferencedFieldsForType2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReferencedFieldsForType2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (let i = 0; i < message.fieldNames.length; ++i)
            if (!$util.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      }, "verify");
      ReferencedFieldsForType2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (let j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      }, "toObject");
      ReferencedFieldsForType2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return ReferencedFieldsForType2;
    })();
    Report = $root.Report = (() => {
      function Report2(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Report2, "Report");
      Report2.prototype.header = null;
      Report2.prototype.tracesPerQuery = $util.emptyObject;
      Report2.prototype.endTime = null;
      Report2.prototype.operationCount = 0;
      Report2.prototype.tracesPreAggregated = false;
      Report2.create = /* @__PURE__ */ __name(function create(properties) {
        return new Report2(properties);
      }, "create");
      Report2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (let keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      }, "encode");
      Report2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Report2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Report(), key;
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Report2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Report2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          let error3 = $root.ReportHeader.verify(message.header);
          if (error3)
            return "header." + error3;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          let key = Object.keys(message.tracesPerQuery);
          for (let i = 0; i < key.length; ++i) {
            let error3 = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error3)
              return "tracesPerQuery." + error3;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          let error3 = $root.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util.isInteger(message.operationCount) && !(message.operationCount && $util.isInteger(message.operationCount.low) && $util.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      }, "verify");
      Report2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
        let keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (let j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      }, "toObject");
      Report2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return Report2;
    })();
    ContextualizedStats = $root.ContextualizedStats = (() => {
      function ContextualizedStats2(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedStats2, "ContextualizedStats");
      ContextualizedStats2.prototype.context = null;
      ContextualizedStats2.prototype.queryLatencyStats = null;
      ContextualizedStats2.prototype.perTypeStat = $util.emptyObject;
      ContextualizedStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedStats2(properties);
      }, "create");
      ContextualizedStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (let keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          let error3 = $root.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          let error3 = $root.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          let key = Object.keys(message.perTypeStat);
          for (let i = 0; i < key.length; ++i) {
            let error3 = $root.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        let keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (let j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedStats2;
    })();
    TracesAndStats = $root.TracesAndStats = (() => {
      function TracesAndStats2(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TracesAndStats2, "TracesAndStats");
      TracesAndStats2.prototype.trace = $util.emptyArray;
      TracesAndStats2.prototype.statsWithContext = $util.emptyArray;
      TracesAndStats2.prototype.referencedFieldsByType = $util.emptyObject;
      TracesAndStats2.prototype.internalTracesContributingToStats = $util.emptyArray;
      TracesAndStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new TracesAndStats2(properties);
      }, "create");
      TracesAndStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.trace != null && message.trace.length)
          for (let i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        let array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (let i = 0; i < array2.length; ++i)
            $root.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (let i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (let keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TracesAndStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TracesAndStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.TracesAndStats(), key;
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TracesAndStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TracesAndStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (let i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              let error3 = $root.Trace.verify(message.trace[i]);
              if (error3)
                return "trace." + error3;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          let array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (let i = 0; i < array2.length; ++i) {
            let error3 = $root.ContextualizedStats.verify(array2[i]);
            if (error3)
              return "statsWithContext." + error3;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          let key = Object.keys(message.referencedFieldsByType);
          for (let i = 0; i < key.length; ++i) {
            let error3 = $root.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error3)
              return "referencedFieldsByType." + error3;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (let i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              let error3 = $root.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error3)
                return "internalTracesContributingToStats." + error3;
            }
        }
        return null;
      }, "verify");
      TracesAndStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (let j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (let j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (let j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        let keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (let j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TracesAndStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      }, "toJSON");
      return TracesAndStats2;
    })();
    google = $root.google = (() => {
      const google2 = {};
      google2.protobuf = function() {
        const protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Timestamp, "Timestamp");
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = /* @__PURE__ */ __name(function create(properties) {
            return new Timestamp(properties);
          }, "create");
          Timestamp.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          }, "encode");
          Timestamp.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Timestamp.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Timestamp.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Timestamp.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          }, "verify");
          Timestamp.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            let object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          }, "toObject");
          Timestamp.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
          }, "toJSON");
          return Timestamp;
        }();
        return protobuf;
      }();
      return google2;
    })();
  }
});

// ../node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js
var require_protobuf = __commonJS({
  "../node_modules/@apollo/usage-reporting-protobuf/generated/cjs/protobuf.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var $protobuf2 = require_minimal2();
    var $Reader2 = $protobuf2.Reader;
    var $Writer2 = $protobuf2.Writer;
    var $util2 = $protobuf2.util;
    var $root2 = $protobuf2.roots["default"] || ($protobuf2.roots["default"] = {});
    $root2.Trace = function() {
      function Trace2(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Trace2, "Trace");
      Trace2.prototype.startTime = null;
      Trace2.prototype.endTime = null;
      Trace2.prototype.durationNs = 0;
      Trace2.prototype.root = null;
      Trace2.prototype.isIncomplete = false;
      Trace2.prototype.signature = "";
      Trace2.prototype.unexecutedOperationBody = "";
      Trace2.prototype.unexecutedOperationName = "";
      Trace2.prototype.details = null;
      Trace2.prototype.clientName = "";
      Trace2.prototype.clientVersion = "";
      Trace2.prototype.http = null;
      Trace2.prototype.cachePolicy = null;
      Trace2.prototype.queryPlan = null;
      Trace2.prototype.fullQueryCacheHit = false;
      Trace2.prototype.persistedQueryHit = false;
      Trace2.prototype.persistedQueryRegister = false;
      Trace2.prototype.registeredOperation = false;
      Trace2.prototype.forbiddenOperation = false;
      Trace2.prototype.fieldExecutionWeight = 0;
      Trace2.create = /* @__PURE__ */ __name(function create(properties) {
        return new Trace2(properties);
      }, "create");
      Trace2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root2.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
          $root2.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
        if (message.details != null && Object.hasOwnProperty.call(message, "details"))
          $root2.Trace.Details.encode(message.details, writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).fork()).ldelim();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.clientVersion);
        if (message.http != null && Object.hasOwnProperty.call(message, "http"))
          $root2.Trace.HTTP.encode(message.http, writer.uint32(
            /* id 10, wireType 2 =*/
            82
          ).fork()).ldelim();
        if (message.durationNs != null && Object.hasOwnProperty.call(message, "durationNs"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.durationNs);
        if (message.root != null && Object.hasOwnProperty.call(message, "root"))
          $root2.Trace.Node.encode(message.root, writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork()).ldelim();
        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
          $root2.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
            /* id 18, wireType 2 =*/
            146
          ).fork()).ldelim();
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
          writer.uint32(
            /* id 19, wireType 2 =*/
            154
          ).string(message.signature);
        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, "fullQueryCacheHit"))
          writer.uint32(
            /* id 20, wireType 0 =*/
            160
          ).bool(message.fullQueryCacheHit);
        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, "persistedQueryHit"))
          writer.uint32(
            /* id 21, wireType 0 =*/
            168
          ).bool(message.persistedQueryHit);
        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, "persistedQueryRegister"))
          writer.uint32(
            /* id 22, wireType 0 =*/
            176
          ).bool(message.persistedQueryRegister);
        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, "registeredOperation"))
          writer.uint32(
            /* id 24, wireType 0 =*/
            192
          ).bool(message.registeredOperation);
        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, "forbiddenOperation"))
          writer.uint32(
            /* id 25, wireType 0 =*/
            200
          ).bool(message.forbiddenOperation);
        if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
          $root2.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(
            /* id 26, wireType 2 =*/
            210
          ).fork()).ldelim();
        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, "unexecutedOperationBody"))
          writer.uint32(
            /* id 27, wireType 2 =*/
            218
          ).string(message.unexecutedOperationBody);
        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, "unexecutedOperationName"))
          writer.uint32(
            /* id 28, wireType 2 =*/
            226
          ).string(message.unexecutedOperationName);
        if (message.fieldExecutionWeight != null && Object.hasOwnProperty.call(message, "fieldExecutionWeight"))
          writer.uint32(
            /* id 31, wireType 1 =*/
            249
          ).double(message.fieldExecutionWeight);
        if (message.isIncomplete != null && Object.hasOwnProperty.call(message, "isIncomplete"))
          writer.uint32(
            /* id 33, wireType 0 =*/
            264
          ).bool(message.isIncomplete);
        return writer;
      }, "encode");
      Trace2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Trace2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 4:
              message.startTime = $root2.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.endTime = $root2.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.durationNs = reader.uint64();
              break;
            case 14:
              message.root = $root2.Trace.Node.decode(reader, reader.uint32());
              break;
            case 33:
              message.isIncomplete = reader.bool();
              break;
            case 19:
              message.signature = reader.string();
              break;
            case 27:
              message.unexecutedOperationBody = reader.string();
              break;
            case 28:
              message.unexecutedOperationName = reader.string();
              break;
            case 6:
              message.details = $root2.Trace.Details.decode(reader, reader.uint32());
              break;
            case 7:
              message.clientName = reader.string();
              break;
            case 8:
              message.clientVersion = reader.string();
              break;
            case 10:
              message.http = $root2.Trace.HTTP.decode(reader, reader.uint32());
              break;
            case 18:
              message.cachePolicy = $root2.Trace.CachePolicy.decode(reader, reader.uint32());
              break;
            case 26:
              message.queryPlan = $root2.Trace.QueryPlanNode.decode(reader, reader.uint32());
              break;
            case 20:
              message.fullQueryCacheHit = reader.bool();
              break;
            case 21:
              message.persistedQueryHit = reader.bool();
              break;
            case 22:
              message.persistedQueryRegister = reader.bool();
              break;
            case 24:
              message.registeredOperation = reader.bool();
              break;
            case 25:
              message.forbiddenOperation = reader.bool();
              break;
            case 31:
              message.fieldExecutionWeight = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Trace2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Trace2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.startTime != null && message.hasOwnProperty("startTime")) {
          var error3 = $root2.google.protobuf.Timestamp.verify(message.startTime);
          if (error3)
            return "startTime." + error3;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error3 = $root2.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.durationNs != null && message.hasOwnProperty("durationNs")) {
          if (!$util2.isInteger(message.durationNs) && !(message.durationNs && $util2.isInteger(message.durationNs.low) && $util2.isInteger(message.durationNs.high)))
            return "durationNs: integer|Long expected";
        }
        if (message.root != null && message.hasOwnProperty("root")) {
          var error3 = $root2.Trace.Node.verify(message.root);
          if (error3)
            return "root." + error3;
        }
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete")) {
          if (typeof message.isIncomplete !== "boolean")
            return "isIncomplete: boolean expected";
        }
        if (message.signature != null && message.hasOwnProperty("signature")) {
          if (!$util2.isString(message.signature))
            return "signature: string expected";
        }
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody")) {
          if (!$util2.isString(message.unexecutedOperationBody))
            return "unexecutedOperationBody: string expected";
        }
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName")) {
          if (!$util2.isString(message.unexecutedOperationName))
            return "unexecutedOperationName: string expected";
        }
        if (message.details != null && message.hasOwnProperty("details")) {
          var error3 = $root2.Trace.Details.verify(message.details);
          if (error3)
            return "details." + error3;
        }
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util2.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util2.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        if (message.http != null && message.hasOwnProperty("http")) {
          var error3 = $root2.Trace.HTTP.verify(message.http);
          if (error3)
            return "http." + error3;
        }
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
          var error3 = $root2.Trace.CachePolicy.verify(message.cachePolicy);
          if (error3)
            return "cachePolicy." + error3;
        }
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan")) {
          var error3 = $root2.Trace.QueryPlanNode.verify(message.queryPlan);
          if (error3)
            return "queryPlan." + error3;
        }
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit")) {
          if (typeof message.fullQueryCacheHit !== "boolean")
            return "fullQueryCacheHit: boolean expected";
        }
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit")) {
          if (typeof message.persistedQueryHit !== "boolean")
            return "persistedQueryHit: boolean expected";
        }
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister")) {
          if (typeof message.persistedQueryRegister !== "boolean")
            return "persistedQueryRegister: boolean expected";
        }
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation")) {
          if (typeof message.registeredOperation !== "boolean")
            return "registeredOperation: boolean expected";
        }
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation")) {
          if (typeof message.forbiddenOperation !== "boolean")
            return "forbiddenOperation: boolean expected";
        }
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight")) {
          if (typeof message.fieldExecutionWeight !== "number")
            return "fieldExecutionWeight: number expected";
        }
        return null;
      }, "verify");
      Trace2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.endTime = null;
          object.startTime = null;
          object.details = null;
          object.clientName = "";
          object.clientVersion = "";
          object.http = null;
          object.durationNs = 0;
          object.root = null;
          object.cachePolicy = null;
          object.signature = "";
          object.fullQueryCacheHit = false;
          object.persistedQueryHit = false;
          object.persistedQueryRegister = false;
          object.registeredOperation = false;
          object.forbiddenOperation = false;
          object.queryPlan = null;
          object.unexecutedOperationBody = "";
          object.unexecutedOperationName = "";
          object.fieldExecutionWeight = 0;
          object.isIncomplete = false;
        }
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root2.google.protobuf.Timestamp.toObject(message.endTime, options);
        if (message.startTime != null && message.hasOwnProperty("startTime"))
          object.startTime = $root2.google.protobuf.Timestamp.toObject(message.startTime, options);
        if (message.details != null && message.hasOwnProperty("details"))
          object.details = $root2.Trace.Details.toObject(message.details, options);
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        if (message.http != null && message.hasOwnProperty("http"))
          object.http = $root2.Trace.HTTP.toObject(message.http, options);
        if (message.durationNs != null && message.hasOwnProperty("durationNs"))
          if (typeof message.durationNs === "number")
            object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;
          else
            object.durationNs = options.longs === String ? $util2.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util2.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;
        if (message.root != null && message.hasOwnProperty("root"))
          object.root = $root2.Trace.Node.toObject(message.root, options);
        if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
          object.cachePolicy = $root2.Trace.CachePolicy.toObject(message.cachePolicy, options);
        if (message.signature != null && message.hasOwnProperty("signature"))
          object.signature = message.signature;
        if (message.fullQueryCacheHit != null && message.hasOwnProperty("fullQueryCacheHit"))
          object.fullQueryCacheHit = message.fullQueryCacheHit;
        if (message.persistedQueryHit != null && message.hasOwnProperty("persistedQueryHit"))
          object.persistedQueryHit = message.persistedQueryHit;
        if (message.persistedQueryRegister != null && message.hasOwnProperty("persistedQueryRegister"))
          object.persistedQueryRegister = message.persistedQueryRegister;
        if (message.registeredOperation != null && message.hasOwnProperty("registeredOperation"))
          object.registeredOperation = message.registeredOperation;
        if (message.forbiddenOperation != null && message.hasOwnProperty("forbiddenOperation"))
          object.forbiddenOperation = message.forbiddenOperation;
        if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
          object.queryPlan = $root2.Trace.QueryPlanNode.toObject(message.queryPlan, options);
        if (message.unexecutedOperationBody != null && message.hasOwnProperty("unexecutedOperationBody"))
          object.unexecutedOperationBody = message.unexecutedOperationBody;
        if (message.unexecutedOperationName != null && message.hasOwnProperty("unexecutedOperationName"))
          object.unexecutedOperationName = message.unexecutedOperationName;
        if (message.fieldExecutionWeight != null && message.hasOwnProperty("fieldExecutionWeight"))
          object.fieldExecutionWeight = options.json && !isFinite(message.fieldExecutionWeight) ? String(message.fieldExecutionWeight) : message.fieldExecutionWeight;
        if (message.isIncomplete != null && message.hasOwnProperty("isIncomplete"))
          object.isIncomplete = message.isIncomplete;
        return object;
      }, "toObject");
      Trace2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      Trace2.CachePolicy = function() {
        function CachePolicy(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(CachePolicy, "CachePolicy");
        CachePolicy.prototype.scope = 0;
        CachePolicy.prototype.maxAgeNs = 0;
        CachePolicy.create = /* @__PURE__ */ __name(function create(properties) {
          return new CachePolicy(properties);
        }, "create");
        CachePolicy.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer2.create();
          if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.scope);
          if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, "maxAgeNs"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.maxAgeNs);
          return writer;
        }, "encode");
        CachePolicy.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        CachePolicy.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader2))
            reader = $Reader2.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.CachePolicy();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.scope = reader.int32();
                break;
              case 2:
                message.maxAgeNs = reader.int64();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        CachePolicy.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader2))
            reader = new $Reader2(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        CachePolicy.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.scope != null && message.hasOwnProperty("scope"))
            switch (message.scope) {
              default:
                return "scope: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs")) {
            if (!$util2.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util2.isInteger(message.maxAgeNs.low) && $util2.isInteger(message.maxAgeNs.high)))
              return "maxAgeNs: integer|Long expected";
          }
          return null;
        }, "verify");
        CachePolicy.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.scope = options.enums === String ? "UNKNOWN" : 0;
            object.maxAgeNs = 0;
          }
          if (message.scope != null && message.hasOwnProperty("scope"))
            object.scope = options.enums === String ? $root2.Trace.CachePolicy.Scope[message.scope] : message.scope;
          if (message.maxAgeNs != null && message.hasOwnProperty("maxAgeNs"))
            if (typeof message.maxAgeNs === "number")
              object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;
            else
              object.maxAgeNs = options.longs === String ? $util2.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util2.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;
          return object;
        }, "toObject");
        CachePolicy.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        }, "toJSON");
        CachePolicy.Scope = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "PUBLIC"] = 1;
          values[valuesById[2] = "PRIVATE"] = 2;
          return values;
        }();
        return CachePolicy;
      }();
      Trace2.Details = function() {
        function Details(properties) {
          this.variablesJson = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Details, "Details");
        Details.prototype.variablesJson = $util2.emptyObject;
        Details.prototype.operationName = "";
        Details.create = /* @__PURE__ */ __name(function create(properties) {
          return new Details(properties);
        }, "create");
        Details.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer2.create();
          if (message.operationName != null && Object.hasOwnProperty.call(message, "operationName"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.operationName);
          if (message.variablesJson != null && Object.hasOwnProperty.call(message, "variablesJson"))
            for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]).uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.variablesJson[keys[i]]).ldelim();
          return writer;
        }, "encode");
        Details.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Details.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader2))
            reader = $Reader2.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.Details(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 4:
                reader.skip().pos++;
                if (message.variablesJson === $util2.emptyObject)
                  message.variablesJson = {};
                key = reader.string();
                reader.pos++;
                message.variablesJson[key] = reader.string();
                break;
              case 3:
                message.operationName = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Details.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader2))
            reader = new $Reader2(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Details.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.variablesJson != null && message.hasOwnProperty("variablesJson")) {
            if (!$util2.isObject(message.variablesJson))
              return "variablesJson: object expected";
            var key = Object.keys(message.variablesJson);
            for (var i = 0; i < key.length; ++i)
              if (!$util2.isString(message.variablesJson[key[i]]))
                return "variablesJson: string{k:string} expected";
          }
          if (message.operationName != null && message.hasOwnProperty("operationName")) {
            if (!$util2.isString(message.operationName))
              return "operationName: string expected";
          }
          return null;
        }, "verify");
        Details.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults)
            object.variablesJson = {};
          if (options.defaults)
            object.operationName = "";
          if (message.operationName != null && message.hasOwnProperty("operationName"))
            object.operationName = message.operationName;
          var keys2;
          if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {
            object.variablesJson = {};
            for (var j = 0; j < keys2.length; ++j)
              object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];
          }
          return object;
        }, "toObject");
        Details.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        }, "toJSON");
        return Details;
      }();
      Trace2.Error = function() {
        function Error2(properties) {
          this.location = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Error2, "Error");
        Error2.prototype.message = "";
        Error2.prototype.location = $util2.emptyArray;
        Error2.prototype.timeNs = 0;
        Error2.prototype.json = "";
        Error2.create = /* @__PURE__ */ __name(function create(properties) {
          return new Error2(properties);
        }, "create");
        Error2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer2.create();
          if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.message);
          if (message.location != null && message.location.length)
            for (var i = 0; i < message.location.length; ++i)
              $root2.Trace.Location.encode(message.location[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.timeNs != null && Object.hasOwnProperty.call(message, "timeNs"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timeNs);
          if (message.json != null && Object.hasOwnProperty.call(message, "json"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.json);
          return writer;
        }, "encode");
        Error2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Error2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader2))
            reader = $Reader2.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.Error();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.message = reader.string();
                break;
              case 2:
                if (!(message.location && message.location.length))
                  message.location = [];
                message.location.push($root2.Trace.Location.decode(reader, reader.uint32()));
                break;
              case 3:
                message.timeNs = reader.uint64();
                break;
              case 4:
                message.json = reader.string();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Error2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader2))
            reader = new $Reader2(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Error2.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.message != null && message.hasOwnProperty("message")) {
            if (!$util2.isString(message.message))
              return "message: string expected";
          }
          if (message.location != null && message.hasOwnProperty("location")) {
            if (!Array.isArray(message.location))
              return "location: array expected";
            for (var i = 0; i < message.location.length; ++i) {
              var error3 = $root2.Trace.Location.verify(message.location[i]);
              if (error3)
                return "location." + error3;
            }
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs")) {
            if (!$util2.isInteger(message.timeNs) && !(message.timeNs && $util2.isInteger(message.timeNs.low) && $util2.isInteger(message.timeNs.high)))
              return "timeNs: integer|Long expected";
          }
          if (message.json != null && message.hasOwnProperty("json")) {
            if (!$util2.isString(message.json))
              return "json: string expected";
          }
          return null;
        }, "verify");
        Error2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.location = [];
          if (options.defaults) {
            object.message = "";
            object.timeNs = 0;
            object.json = "";
          }
          if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
          if (message.location && message.location.length) {
            object.location = [];
            for (var j = 0; j < message.location.length; ++j)
              object.location[j] = $root2.Trace.Location.toObject(message.location[j], options);
          }
          if (message.timeNs != null && message.hasOwnProperty("timeNs"))
            if (typeof message.timeNs === "number")
              object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;
            else
              object.timeNs = options.longs === String ? $util2.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util2.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;
          if (message.json != null && message.hasOwnProperty("json"))
            object.json = message.json;
          return object;
        }, "toObject");
        Error2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        }, "toJSON");
        return Error2;
      }();
      Trace2.HTTP = function() {
        function HTTP(properties) {
          this.requestHeaders = {};
          this.responseHeaders = {};
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(HTTP, "HTTP");
        HTTP.prototype.method = 0;
        HTTP.prototype.requestHeaders = $util2.emptyObject;
        HTTP.prototype.responseHeaders = $util2.emptyObject;
        HTTP.prototype.statusCode = 0;
        HTTP.create = /* @__PURE__ */ __name(function create(properties) {
          return new HTTP(properties);
        }, "create");
        HTTP.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer2.create();
          if (message.method != null && Object.hasOwnProperty.call(message, "method"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int32(message.method);
          if (message.requestHeaders != null && Object.hasOwnProperty.call(message, "requestHeaders"))
            for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root2.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.responseHeaders != null && Object.hasOwnProperty.call(message, "responseHeaders"))
            for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork().uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(keys[i]);
              $root2.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim().ldelim();
            }
          if (message.statusCode != null && Object.hasOwnProperty.call(message, "statusCode"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.statusCode);
          return writer;
        }, "encode");
        HTTP.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        HTTP.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader2))
            reader = $Reader2.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.HTTP(), key;
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.method = reader.int32();
                break;
              case 4:
                reader.skip().pos++;
                if (message.requestHeaders === $util2.emptyObject)
                  message.requestHeaders = {};
                key = reader.string();
                reader.pos++;
                message.requestHeaders[key] = $root2.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 5:
                reader.skip().pos++;
                if (message.responseHeaders === $util2.emptyObject)
                  message.responseHeaders = {};
                key = reader.string();
                reader.pos++;
                message.responseHeaders[key] = $root2.Trace.HTTP.Values.decode(reader, reader.uint32());
                break;
              case 6:
                message.statusCode = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        HTTP.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader2))
            reader = new $Reader2(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        HTTP.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.method != null && message.hasOwnProperty("method"))
            switch (message.method) {
              default:
                return "method: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
                break;
            }
          if (message.requestHeaders != null && message.hasOwnProperty("requestHeaders")) {
            if (!$util2.isObject(message.requestHeaders))
              return "requestHeaders: object expected";
            var key = Object.keys(message.requestHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error3 = $root2.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);
              if (error3)
                return "requestHeaders." + error3;
            }
          }
          if (message.responseHeaders != null && message.hasOwnProperty("responseHeaders")) {
            if (!$util2.isObject(message.responseHeaders))
              return "responseHeaders: object expected";
            var key = Object.keys(message.responseHeaders);
            for (var i = 0; i < key.length; ++i) {
              var error3 = $root2.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);
              if (error3)
                return "responseHeaders." + error3;
            }
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode")) {
            if (!$util2.isInteger(message.statusCode))
              return "statusCode: integer expected";
          }
          return null;
        }, "verify");
        HTTP.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.objects || options.defaults) {
            object.requestHeaders = {};
            object.responseHeaders = {};
          }
          if (options.defaults) {
            object.method = options.enums === String ? "UNKNOWN" : 0;
            object.statusCode = 0;
          }
          if (message.method != null && message.hasOwnProperty("method"))
            object.method = options.enums === String ? $root2.Trace.HTTP.Method[message.method] : message.method;
          var keys2;
          if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {
            object.requestHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.requestHeaders[keys2[j]] = $root2.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);
          }
          if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {
            object.responseHeaders = {};
            for (var j = 0; j < keys2.length; ++j)
              object.responseHeaders[keys2[j]] = $root2.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);
          }
          if (message.statusCode != null && message.hasOwnProperty("statusCode"))
            object.statusCode = message.statusCode;
          return object;
        }, "toObject");
        HTTP.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        }, "toJSON");
        HTTP.Values = function() {
          function Values(properties) {
            this.value = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Values, "Values");
          Values.prototype.value = $util2.emptyArray;
          Values.create = /* @__PURE__ */ __name(function create(properties) {
            return new Values(properties);
          }, "create");
          Values.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.value != null && message.value.length)
              for (var i = 0; i < message.value.length; ++i)
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.value[i]);
            return writer;
          }, "encode");
          Values.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Values.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.HTTP.Values();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.value && message.value.length))
                    message.value = [];
                  message.value.push(reader.string());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Values.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Values.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value")) {
              if (!Array.isArray(message.value))
                return "value: array expected";
              for (var i = 0; i < message.value.length; ++i)
                if (!$util2.isString(message.value[i]))
                  return "value: string[] expected";
            }
            return null;
          }, "verify");
          Values.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.value = [];
            if (message.value && message.value.length) {
              object.value = [];
              for (var j = 0; j < message.value.length; ++j)
                object.value[j] = message.value[j];
            }
            return object;
          }, "toObject");
          Values.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return Values;
        }();
        HTTP.Method = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN"] = 0;
          values[valuesById[1] = "OPTIONS"] = 1;
          values[valuesById[2] = "GET"] = 2;
          values[valuesById[3] = "HEAD"] = 3;
          values[valuesById[4] = "POST"] = 4;
          values[valuesById[5] = "PUT"] = 5;
          values[valuesById[6] = "DELETE"] = 6;
          values[valuesById[7] = "TRACE"] = 7;
          values[valuesById[8] = "CONNECT"] = 8;
          values[valuesById[9] = "PATCH"] = 9;
          return values;
        }();
        return HTTP;
      }();
      Trace2.Location = function() {
        function Location(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Location, "Location");
        Location.prototype.line = 0;
        Location.prototype.column = 0;
        Location.create = /* @__PURE__ */ __name(function create(properties) {
          return new Location(properties);
        }, "create");
        Location.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer2.create();
          if (message.line != null && Object.hasOwnProperty.call(message, "line"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint32(message.line);
          if (message.column != null && Object.hasOwnProperty.call(message, "column"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.column);
          return writer;
        }, "encode");
        Location.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Location.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader2))
            reader = $Reader2.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.Location();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.line = reader.uint32();
                break;
              case 2:
                message.column = reader.uint32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Location.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader2))
            reader = new $Reader2(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Location.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.line != null && message.hasOwnProperty("line")) {
            if (!$util2.isInteger(message.line))
              return "line: integer expected";
          }
          if (message.column != null && message.hasOwnProperty("column")) {
            if (!$util2.isInteger(message.column))
              return "column: integer expected";
          }
          return null;
        }, "verify");
        Location.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.line = 0;
            object.column = 0;
          }
          if (message.line != null && message.hasOwnProperty("line"))
            object.line = message.line;
          if (message.column != null && message.hasOwnProperty("column"))
            object.column = message.column;
          return object;
        }, "toObject");
        Location.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        }, "toJSON");
        return Location;
      }();
      Trace2.Node = function() {
        function Node(properties) {
          this.error = [];
          this.child = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(Node, "Node");
        Node.prototype.responseName = "";
        Node.prototype.index = 0;
        Node.prototype.originalFieldName = "";
        Node.prototype.type = "";
        Node.prototype.parentType = "";
        Node.prototype.cachePolicy = null;
        Node.prototype.startTime = 0;
        Node.prototype.endTime = 0;
        Node.prototype.error = $util2.emptyArray;
        Node.prototype.child = $util2.emptyArray;
        var $oneOfFields;
        Object.defineProperty(Node.prototype, "id", {
          get: $util2.oneOfGetter($oneOfFields = ["responseName", "index"]),
          set: $util2.oneOfSetter($oneOfFields)
        });
        Node.create = /* @__PURE__ */ __name(function create(properties) {
          return new Node(properties);
        }, "create");
        Node.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer2.create();
          if (message.responseName != null && Object.hasOwnProperty.call(message, "responseName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.responseName);
          if (message.index != null && Object.hasOwnProperty.call(message, "index"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint32(message.index);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.type);
          if (message.cachePolicy != null && Object.hasOwnProperty.call(message, "cachePolicy"))
            $root2.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 8, wireType 0 =*/
              64
            ).uint64(message.startTime);
          if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).uint64(message.endTime);
          if (message.error != null && message.error.length)
            for (var i = 0; i < message.error.length; ++i)
              $root2.Trace.Error.encode(message.error[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.child != null && message.child.length)
            for (var i = 0; i < message.child.length; ++i)
              $root2.Trace.Node.encode(message.child[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.parentType != null && Object.hasOwnProperty.call(message, "parentType"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.parentType);
          if (message.originalFieldName != null && Object.hasOwnProperty.call(message, "originalFieldName"))
            writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).string(message.originalFieldName);
          return writer;
        }, "encode");
        Node.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        Node.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader2))
            reader = $Reader2.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.Node();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.responseName = reader.string();
                break;
              case 2:
                message.index = reader.uint32();
                break;
              case 14:
                message.originalFieldName = reader.string();
                break;
              case 3:
                message.type = reader.string();
                break;
              case 13:
                message.parentType = reader.string();
                break;
              case 5:
                message.cachePolicy = $root2.Trace.CachePolicy.decode(reader, reader.uint32());
                break;
              case 8:
                message.startTime = reader.uint64();
                break;
              case 9:
                message.endTime = reader.uint64();
                break;
              case 11:
                if (!(message.error && message.error.length))
                  message.error = [];
                message.error.push($root2.Trace.Error.decode(reader, reader.uint32()));
                break;
              case 12:
                if (!(message.child && message.child.length))
                  message.child = [];
                message.child.push($root2.Trace.Node.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        Node.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader2))
            reader = new $Reader2(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        Node.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            properties.id = 1;
            if (!$util2.isString(message.responseName))
              return "responseName: string expected";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            if (properties.id === 1)
              return "id: multiple values";
            properties.id = 1;
            if (!$util2.isInteger(message.index))
              return "index: integer expected";
          }
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName")) {
            if (!$util2.isString(message.originalFieldName))
              return "originalFieldName: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            if (!$util2.isString(message.type))
              return "type: string expected";
          }
          if (message.parentType != null && message.hasOwnProperty("parentType")) {
            if (!$util2.isString(message.parentType))
              return "parentType: string expected";
          }
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy")) {
            var error3 = $root2.Trace.CachePolicy.verify(message.cachePolicy);
            if (error3)
              return "cachePolicy." + error3;
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util2.isInteger(message.startTime) && !(message.startTime && $util2.isInteger(message.startTime.low) && $util2.isInteger(message.startTime.high)))
              return "startTime: integer|Long expected";
          }
          if (message.endTime != null && message.hasOwnProperty("endTime")) {
            if (!$util2.isInteger(message.endTime) && !(message.endTime && $util2.isInteger(message.endTime.low) && $util2.isInteger(message.endTime.high)))
              return "endTime: integer|Long expected";
          }
          if (message.error != null && message.hasOwnProperty("error")) {
            if (!Array.isArray(message.error))
              return "error: array expected";
            for (var i = 0; i < message.error.length; ++i) {
              var error3 = $root2.Trace.Error.verify(message.error[i]);
              if (error3)
                return "error." + error3;
            }
          }
          if (message.child != null && message.hasOwnProperty("child")) {
            if (!Array.isArray(message.child))
              return "child: array expected";
            for (var i = 0; i < message.child.length; ++i) {
              var error3 = $root2.Trace.Node.verify(message.child[i]);
              if (error3)
                return "child." + error3;
            }
          }
          return null;
        }, "verify");
        Node.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.error = [];
            object.child = [];
          }
          if (options.defaults) {
            object.type = "";
            object.cachePolicy = null;
            object.startTime = 0;
            object.endTime = 0;
            object.parentType = "";
            object.originalFieldName = "";
          }
          if (message.responseName != null && message.hasOwnProperty("responseName")) {
            object.responseName = message.responseName;
            if (options.oneofs)
              object.id = "responseName";
          }
          if (message.index != null && message.hasOwnProperty("index")) {
            object.index = message.index;
            if (options.oneofs)
              object.id = "index";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
          if (message.cachePolicy != null && message.hasOwnProperty("cachePolicy"))
            object.cachePolicy = $root2.Trace.CachePolicy.toObject(message.cachePolicy, options);
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            if (typeof message.startTime === "number")
              object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
            else
              object.startTime = options.longs === String ? $util2.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util2.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
          if (message.endTime != null && message.hasOwnProperty("endTime"))
            if (typeof message.endTime === "number")
              object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
            else
              object.endTime = options.longs === String ? $util2.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util2.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
          if (message.error && message.error.length) {
            object.error = [];
            for (var j = 0; j < message.error.length; ++j)
              object.error[j] = $root2.Trace.Error.toObject(message.error[j], options);
          }
          if (message.child && message.child.length) {
            object.child = [];
            for (var j = 0; j < message.child.length; ++j)
              object.child[j] = $root2.Trace.Node.toObject(message.child[j], options);
          }
          if (message.parentType != null && message.hasOwnProperty("parentType"))
            object.parentType = message.parentType;
          if (message.originalFieldName != null && message.hasOwnProperty("originalFieldName"))
            object.originalFieldName = message.originalFieldName;
          return object;
        }, "toObject");
        Node.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        }, "toJSON");
        return Node;
      }();
      Trace2.QueryPlanNode = function() {
        function QueryPlanNode(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        __name(QueryPlanNode, "QueryPlanNode");
        QueryPlanNode.prototype.sequence = null;
        QueryPlanNode.prototype.parallel = null;
        QueryPlanNode.prototype.fetch = null;
        QueryPlanNode.prototype.flatten = null;
        QueryPlanNode.prototype.defer = null;
        QueryPlanNode.prototype.condition = null;
        var $oneOfFields;
        Object.defineProperty(QueryPlanNode.prototype, "node", {
          get: $util2.oneOfGetter($oneOfFields = ["sequence", "parallel", "fetch", "flatten", "defer", "condition"]),
          set: $util2.oneOfSetter($oneOfFields)
        });
        QueryPlanNode.create = /* @__PURE__ */ __name(function create(properties) {
          return new QueryPlanNode(properties);
        }, "create");
        QueryPlanNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
          if (!writer)
            writer = $Writer2.create();
          if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
            $root2.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.parallel != null && Object.hasOwnProperty.call(message, "parallel"))
            $root2.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.fetch != null && Object.hasOwnProperty.call(message, "fetch"))
            $root2.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.flatten != null && Object.hasOwnProperty.call(message, "flatten"))
            $root2.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.defer != null && Object.hasOwnProperty.call(message, "defer"))
            $root2.Trace.QueryPlanNode.DeferNode.encode(message.defer, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
            $root2.Trace.QueryPlanNode.ConditionNode.encode(message.condition, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        }, "encode");
        QueryPlanNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        }, "encodeDelimited");
        QueryPlanNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
          if (!(reader instanceof $Reader2))
            reader = $Reader2.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.sequence = $root2.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());
                break;
              case 2:
                message.parallel = $root2.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());
                break;
              case 3:
                message.fetch = $root2.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());
                break;
              case 4:
                message.flatten = $root2.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());
                break;
              case 5:
                message.defer = $root2.Trace.QueryPlanNode.DeferNode.decode(reader, reader.uint32());
                break;
              case 6:
                message.condition = $root2.Trace.QueryPlanNode.ConditionNode.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        }, "decode");
        QueryPlanNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
          if (!(reader instanceof $Reader2))
            reader = new $Reader2(reader);
          return this.decode(reader, reader.uint32());
        }, "decodeDelimited");
        QueryPlanNode.verify = /* @__PURE__ */ __name(function verify3(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            properties.node = 1;
            {
              var error3 = $root2.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);
              if (error3)
                return "sequence." + error3;
            }
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root2.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);
              if (error3)
                return "parallel." + error3;
            }
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root2.Trace.QueryPlanNode.FetchNode.verify(message.fetch);
              if (error3)
                return "fetch." + error3;
            }
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root2.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);
              if (error3)
                return "flatten." + error3;
            }
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root2.Trace.QueryPlanNode.DeferNode.verify(message.defer);
              if (error3)
                return "defer." + error3;
            }
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            if (properties.node === 1)
              return "node: multiple values";
            properties.node = 1;
            {
              var error3 = $root2.Trace.QueryPlanNode.ConditionNode.verify(message.condition);
              if (error3)
                return "condition." + error3;
            }
          }
          return null;
        }, "verify");
        QueryPlanNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.sequence != null && message.hasOwnProperty("sequence")) {
            object.sequence = $root2.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);
            if (options.oneofs)
              object.node = "sequence";
          }
          if (message.parallel != null && message.hasOwnProperty("parallel")) {
            object.parallel = $root2.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);
            if (options.oneofs)
              object.node = "parallel";
          }
          if (message.fetch != null && message.hasOwnProperty("fetch")) {
            object.fetch = $root2.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);
            if (options.oneofs)
              object.node = "fetch";
          }
          if (message.flatten != null && message.hasOwnProperty("flatten")) {
            object.flatten = $root2.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);
            if (options.oneofs)
              object.node = "flatten";
          }
          if (message.defer != null && message.hasOwnProperty("defer")) {
            object.defer = $root2.Trace.QueryPlanNode.DeferNode.toObject(message.defer, options);
            if (options.oneofs)
              object.node = "defer";
          }
          if (message.condition != null && message.hasOwnProperty("condition")) {
            object.condition = $root2.Trace.QueryPlanNode.ConditionNode.toObject(message.condition, options);
            if (options.oneofs)
              object.node = "condition";
          }
          return object;
        }, "toObject");
        QueryPlanNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
          return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
        }, "toJSON");
        QueryPlanNode.SequenceNode = function() {
          function SequenceNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(SequenceNode, "SequenceNode");
          SequenceNode.prototype.nodes = $util2.emptyArray;
          SequenceNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new SequenceNode(properties);
          }, "create");
          SequenceNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root2.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          SequenceNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          SequenceNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.SequenceNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root2.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          SequenceNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          SequenceNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error3 = $root2.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          SequenceNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root2.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          SequenceNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return SequenceNode;
        }();
        QueryPlanNode.ParallelNode = function() {
          function ParallelNode(properties) {
            this.nodes = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ParallelNode, "ParallelNode");
          ParallelNode.prototype.nodes = $util2.emptyArray;
          ParallelNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ParallelNode(properties);
          }, "create");
          ParallelNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.nodes != null && message.nodes.length)
              for (var i = 0; i < message.nodes.length; ++i)
                $root2.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            return writer;
          }, "encode");
          ParallelNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ParallelNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.ParallelNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.nodes && message.nodes.length))
                    message.nodes = [];
                  message.nodes.push($root2.Trace.QueryPlanNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ParallelNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ParallelNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
              if (!Array.isArray(message.nodes))
                return "nodes: array expected";
              for (var i = 0; i < message.nodes.length; ++i) {
                var error3 = $root2.Trace.QueryPlanNode.verify(message.nodes[i]);
                if (error3)
                  return "nodes." + error3;
              }
            }
            return null;
          }, "verify");
          ParallelNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.nodes = [];
            if (message.nodes && message.nodes.length) {
              object.nodes = [];
              for (var j = 0; j < message.nodes.length; ++j)
                object.nodes[j] = $root2.Trace.QueryPlanNode.toObject(message.nodes[j], options);
            }
            return object;
          }, "toObject");
          ParallelNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return ParallelNode;
        }();
        QueryPlanNode.FetchNode = function() {
          function FetchNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FetchNode, "FetchNode");
          FetchNode.prototype.serviceName = "";
          FetchNode.prototype.traceParsingFailed = false;
          FetchNode.prototype.trace = null;
          FetchNode.prototype.sentTimeOffset = 0;
          FetchNode.prototype.sentTime = null;
          FetchNode.prototype.receivedTime = null;
          FetchNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FetchNode(properties);
          }, "create");
          FetchNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.serviceName != null && Object.hasOwnProperty.call(message, "serviceName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.serviceName);
            if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, "traceParsingFailed"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).bool(message.traceParsingFailed);
            if (message.trace != null && Object.hasOwnProperty.call(message, "trace"))
              $root2.Trace.encode(message.trace, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, "sentTimeOffset"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).uint64(message.sentTimeOffset);
            if (message.sentTime != null && Object.hasOwnProperty.call(message, "sentTime"))
              $root2.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
            if (message.receivedTime != null && Object.hasOwnProperty.call(message, "receivedTime"))
              $root2.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FetchNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FetchNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.FetchNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.serviceName = reader.string();
                  break;
                case 2:
                  message.traceParsingFailed = reader.bool();
                  break;
                case 3:
                  message.trace = $root2.Trace.decode(reader, reader.uint32());
                  break;
                case 4:
                  message.sentTimeOffset = reader.uint64();
                  break;
                case 5:
                  message.sentTime = $root2.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                case 6:
                  message.receivedTime = $root2.google.protobuf.Timestamp.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FetchNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FetchNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName")) {
              if (!$util2.isString(message.serviceName))
                return "serviceName: string expected";
            }
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed")) {
              if (typeof message.traceParsingFailed !== "boolean")
                return "traceParsingFailed: boolean expected";
            }
            if (message.trace != null && message.hasOwnProperty("trace")) {
              var error3 = $root2.Trace.verify(message.trace);
              if (error3)
                return "trace." + error3;
            }
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset")) {
              if (!$util2.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util2.isInteger(message.sentTimeOffset.low) && $util2.isInteger(message.sentTimeOffset.high)))
                return "sentTimeOffset: integer|Long expected";
            }
            if (message.sentTime != null && message.hasOwnProperty("sentTime")) {
              var error3 = $root2.google.protobuf.Timestamp.verify(message.sentTime);
              if (error3)
                return "sentTime." + error3;
            }
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime")) {
              var error3 = $root2.google.protobuf.Timestamp.verify(message.receivedTime);
              if (error3)
                return "receivedTime." + error3;
            }
            return null;
          }, "verify");
          FetchNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.serviceName = "";
              object.traceParsingFailed = false;
              object.trace = null;
              object.sentTimeOffset = 0;
              object.sentTime = null;
              object.receivedTime = null;
            }
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
              object.serviceName = message.serviceName;
            if (message.traceParsingFailed != null && message.hasOwnProperty("traceParsingFailed"))
              object.traceParsingFailed = message.traceParsingFailed;
            if (message.trace != null && message.hasOwnProperty("trace"))
              object.trace = $root2.Trace.toObject(message.trace, options);
            if (message.sentTimeOffset != null && message.hasOwnProperty("sentTimeOffset"))
              if (typeof message.sentTimeOffset === "number")
                object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;
              else
                object.sentTimeOffset = options.longs === String ? $util2.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util2.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;
            if (message.sentTime != null && message.hasOwnProperty("sentTime"))
              object.sentTime = $root2.google.protobuf.Timestamp.toObject(message.sentTime, options);
            if (message.receivedTime != null && message.hasOwnProperty("receivedTime"))
              object.receivedTime = $root2.google.protobuf.Timestamp.toObject(message.receivedTime, options);
            return object;
          }, "toObject");
          FetchNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return FetchNode;
        }();
        QueryPlanNode.FlattenNode = function() {
          function FlattenNode(properties) {
            this.responsePath = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(FlattenNode, "FlattenNode");
          FlattenNode.prototype.responsePath = $util2.emptyArray;
          FlattenNode.prototype.node = null;
          FlattenNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new FlattenNode(properties);
          }, "create");
          FlattenNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.responsePath != null && message.responsePath.length)
              for (var i = 0; i < message.responsePath.length; ++i)
                $root2.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root2.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          }, "encode");
          FlattenNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          FlattenNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.FlattenNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.responsePath && message.responsePath.length))
                    message.responsePath = [];
                  message.responsePath.push($root2.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.node = $root2.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          FlattenNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          FlattenNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.responsePath != null && message.hasOwnProperty("responsePath")) {
              if (!Array.isArray(message.responsePath))
                return "responsePath: array expected";
              for (var i = 0; i < message.responsePath.length; ++i) {
                var error3 = $root2.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);
                if (error3)
                  return "responsePath." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root2.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          FlattenNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.responsePath = [];
            if (options.defaults)
              object.node = null;
            if (message.responsePath && message.responsePath.length) {
              object.responsePath = [];
              for (var j = 0; j < message.responsePath.length; ++j)
                object.responsePath[j] = $root2.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root2.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          FlattenNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return FlattenNode;
        }();
        QueryPlanNode.DeferNode = function() {
          function DeferNode(properties) {
            this.deferred = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNode, "DeferNode");
          DeferNode.prototype.primary = null;
          DeferNode.prototype.deferred = $util2.emptyArray;
          DeferNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNode(properties);
          }, "create");
          DeferNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.primary != null && Object.hasOwnProperty.call(message, "primary"))
              $root2.Trace.QueryPlanNode.DeferNodePrimary.encode(message.primary, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            if (message.deferred != null && message.deferred.length)
              for (var i = 0; i < message.deferred.length; ++i)
                $root2.Trace.QueryPlanNode.DeferredNode.encode(message.deferred[i], writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.DeferNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.primary = $root2.Trace.QueryPlanNode.DeferNodePrimary.decode(reader, reader.uint32());
                  break;
                case 2:
                  if (!(message.deferred && message.deferred.length))
                    message.deferred = [];
                  message.deferred.push($root2.Trace.QueryPlanNode.DeferredNode.decode(reader, reader.uint32()));
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.primary != null && message.hasOwnProperty("primary")) {
              var error3 = $root2.Trace.QueryPlanNode.DeferNodePrimary.verify(message.primary);
              if (error3)
                return "primary." + error3;
            }
            if (message.deferred != null && message.hasOwnProperty("deferred")) {
              if (!Array.isArray(message.deferred))
                return "deferred: array expected";
              for (var i = 0; i < message.deferred.length; ++i) {
                var error3 = $root2.Trace.QueryPlanNode.DeferredNode.verify(message.deferred[i]);
                if (error3)
                  return "deferred." + error3;
              }
            }
            return null;
          }, "verify");
          DeferNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults)
              object.deferred = [];
            if (options.defaults)
              object.primary = null;
            if (message.primary != null && message.hasOwnProperty("primary"))
              object.primary = $root2.Trace.QueryPlanNode.DeferNodePrimary.toObject(message.primary, options);
            if (message.deferred && message.deferred.length) {
              object.deferred = [];
              for (var j = 0; j < message.deferred.length; ++j)
                object.deferred[j] = $root2.Trace.QueryPlanNode.DeferredNode.toObject(message.deferred[j], options);
            }
            return object;
          }, "toObject");
          DeferNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return DeferNode;
        }();
        QueryPlanNode.ConditionNode = function() {
          function ConditionNode(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ConditionNode, "ConditionNode");
          ConditionNode.prototype.condition = "";
          ConditionNode.prototype.ifClause = null;
          ConditionNode.prototype.elseClause = null;
          ConditionNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new ConditionNode(properties);
          }, "create");
          ConditionNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.condition != null && Object.hasOwnProperty.call(message, "condition"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.condition);
            if (message.ifClause != null && Object.hasOwnProperty.call(message, "ifClause"))
              $root2.Trace.QueryPlanNode.encode(message.ifClause, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.elseClause != null && Object.hasOwnProperty.call(message, "elseClause"))
              $root2.Trace.QueryPlanNode.encode(message.elseClause, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            return writer;
          }, "encode");
          ConditionNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ConditionNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.ConditionNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.condition = reader.string();
                  break;
                case 2:
                  message.ifClause = $root2.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                case 3:
                  message.elseClause = $root2.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ConditionNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ConditionNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.condition != null && message.hasOwnProperty("condition")) {
              if (!$util2.isString(message.condition))
                return "condition: string expected";
            }
            if (message.ifClause != null && message.hasOwnProperty("ifClause")) {
              var error3 = $root2.Trace.QueryPlanNode.verify(message.ifClause);
              if (error3)
                return "ifClause." + error3;
            }
            if (message.elseClause != null && message.hasOwnProperty("elseClause")) {
              var error3 = $root2.Trace.QueryPlanNode.verify(message.elseClause);
              if (error3)
                return "elseClause." + error3;
            }
            return null;
          }, "verify");
          ConditionNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.condition = "";
              object.ifClause = null;
              object.elseClause = null;
            }
            if (message.condition != null && message.hasOwnProperty("condition"))
              object.condition = message.condition;
            if (message.ifClause != null && message.hasOwnProperty("ifClause"))
              object.ifClause = $root2.Trace.QueryPlanNode.toObject(message.ifClause, options);
            if (message.elseClause != null && message.hasOwnProperty("elseClause"))
              object.elseClause = $root2.Trace.QueryPlanNode.toObject(message.elseClause, options);
            return object;
          }, "toObject");
          ConditionNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return ConditionNode;
        }();
        QueryPlanNode.DeferNodePrimary = function() {
          function DeferNodePrimary(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferNodePrimary, "DeferNodePrimary");
          DeferNodePrimary.prototype.node = null;
          DeferNodePrimary.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferNodePrimary(properties);
          }, "create");
          DeferNodePrimary.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root2.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferNodePrimary.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferNodePrimary.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.DeferNodePrimary();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.node = $root2.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferNodePrimary.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferNodePrimary.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root2.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferNodePrimary.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.node = null;
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root2.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferNodePrimary.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return DeferNodePrimary;
        }();
        QueryPlanNode.DeferredNode = function() {
          function DeferredNode(properties) {
            this.depends = [];
            this.path = [];
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNode, "DeferredNode");
          DeferredNode.prototype.depends = $util2.emptyArray;
          DeferredNode.prototype.label = "";
          DeferredNode.prototype.path = $util2.emptyArray;
          DeferredNode.prototype.node = null;
          DeferredNode.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNode(properties);
          }, "create");
          DeferredNode.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.depends != null && message.depends.length)
              for (var i = 0; i < message.depends.length; ++i)
                $root2.Trace.QueryPlanNode.DeferredNodeDepends.encode(message.depends[i], writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.path != null && message.path.length)
              for (var i = 0; i < message.path.length; ++i)
                $root2.Trace.QueryPlanNode.ResponsePathElement.encode(message.path[i], writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).fork()).ldelim();
            if (message.node != null && Object.hasOwnProperty.call(message, "node"))
              $root2.Trace.QueryPlanNode.encode(message.node, writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
            return writer;
          }, "encode");
          DeferredNode.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNode.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.DeferredNode();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  if (!(message.depends && message.depends.length))
                    message.depends = [];
                  message.depends.push($root2.Trace.QueryPlanNode.DeferredNodeDepends.decode(reader, reader.uint32()));
                  break;
                case 2:
                  message.label = reader.string();
                  break;
                case 3:
                  if (!(message.path && message.path.length))
                    message.path = [];
                  message.path.push($root2.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));
                  break;
                case 4:
                  message.node = $root2.Trace.QueryPlanNode.decode(reader, reader.uint32());
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNode.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNode.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.depends != null && message.hasOwnProperty("depends")) {
              if (!Array.isArray(message.depends))
                return "depends: array expected";
              for (var i = 0; i < message.depends.length; ++i) {
                var error3 = $root2.Trace.QueryPlanNode.DeferredNodeDepends.verify(message.depends[i]);
                if (error3)
                  return "depends." + error3;
              }
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util2.isString(message.label))
                return "label: string expected";
            }
            if (message.path != null && message.hasOwnProperty("path")) {
              if (!Array.isArray(message.path))
                return "path: array expected";
              for (var i = 0; i < message.path.length; ++i) {
                var error3 = $root2.Trace.QueryPlanNode.ResponsePathElement.verify(message.path[i]);
                if (error3)
                  return "path." + error3;
              }
            }
            if (message.node != null && message.hasOwnProperty("node")) {
              var error3 = $root2.Trace.QueryPlanNode.verify(message.node);
              if (error3)
                return "node." + error3;
            }
            return null;
          }, "verify");
          DeferredNode.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.arrays || options.defaults) {
              object.depends = [];
              object.path = [];
            }
            if (options.defaults) {
              object.label = "";
              object.node = null;
            }
            if (message.depends && message.depends.length) {
              object.depends = [];
              for (var j = 0; j < message.depends.length; ++j)
                object.depends[j] = $root2.Trace.QueryPlanNode.DeferredNodeDepends.toObject(message.depends[j], options);
            }
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.path && message.path.length) {
              object.path = [];
              for (var j = 0; j < message.path.length; ++j)
                object.path[j] = $root2.Trace.QueryPlanNode.ResponsePathElement.toObject(message.path[j], options);
            }
            if (message.node != null && message.hasOwnProperty("node"))
              object.node = $root2.Trace.QueryPlanNode.toObject(message.node, options);
            return object;
          }, "toObject");
          DeferredNode.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return DeferredNode;
        }();
        QueryPlanNode.DeferredNodeDepends = function() {
          function DeferredNodeDepends(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(DeferredNodeDepends, "DeferredNodeDepends");
          DeferredNodeDepends.prototype.id = "";
          DeferredNodeDepends.prototype.deferLabel = "";
          DeferredNodeDepends.create = /* @__PURE__ */ __name(function create(properties) {
            return new DeferredNodeDepends(properties);
          }, "create");
          DeferredNodeDepends.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.deferLabel != null && Object.hasOwnProperty.call(message, "deferLabel"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.deferLabel);
            return writer;
          }, "encode");
          DeferredNodeDepends.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          DeferredNodeDepends.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.DeferredNodeDepends();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.id = reader.string();
                  break;
                case 2:
                  message.deferLabel = reader.string();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          DeferredNodeDepends.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          DeferredNodeDepends.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util2.isString(message.id))
                return "id: string expected";
            }
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel")) {
              if (!$util2.isString(message.deferLabel))
                return "deferLabel: string expected";
            }
            return null;
          }, "verify");
          DeferredNodeDepends.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.deferLabel = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.deferLabel != null && message.hasOwnProperty("deferLabel"))
              object.deferLabel = message.deferLabel;
            return object;
          }, "toObject");
          DeferredNodeDepends.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return DeferredNodeDepends;
        }();
        QueryPlanNode.ResponsePathElement = function() {
          function ResponsePathElement(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(ResponsePathElement, "ResponsePathElement");
          ResponsePathElement.prototype.fieldName = "";
          ResponsePathElement.prototype.index = 0;
          var $oneOfFields2;
          Object.defineProperty(ResponsePathElement.prototype, "id", {
            get: $util2.oneOfGetter($oneOfFields2 = ["fieldName", "index"]),
            set: $util2.oneOfSetter($oneOfFields2)
          });
          ResponsePathElement.create = /* @__PURE__ */ __name(function create(properties) {
            return new ResponsePathElement(properties);
          }, "create");
          ResponsePathElement.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.fieldName != null && Object.hasOwnProperty.call(message, "fieldName"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.fieldName);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).uint32(message.index);
            return writer;
          }, "encode");
          ResponsePathElement.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          ResponsePathElement.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Trace.QueryPlanNode.ResponsePathElement();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.fieldName = reader.string();
                  break;
                case 2:
                  message.index = reader.uint32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          ResponsePathElement.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          ResponsePathElement.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              properties.id = 1;
              if (!$util2.isString(message.fieldName))
                return "fieldName: string expected";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              if (properties.id === 1)
                return "id: multiple values";
              properties.id = 1;
              if (!$util2.isInteger(message.index))
                return "index: integer expected";
            }
            return null;
          }, "verify");
          ResponsePathElement.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (message.fieldName != null && message.hasOwnProperty("fieldName")) {
              object.fieldName = message.fieldName;
              if (options.oneofs)
                object.id = "fieldName";
            }
            if (message.index != null && message.hasOwnProperty("index")) {
              object.index = message.index;
              if (options.oneofs)
                object.id = "index";
            }
            return object;
          }, "toObject");
          ResponsePathElement.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return ResponsePathElement;
        }();
        return QueryPlanNode;
      }();
      return Trace2;
    }();
    $root2.ReportHeader = function() {
      function ReportHeader2(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReportHeader2, "ReportHeader");
      ReportHeader2.prototype.graphRef = "";
      ReportHeader2.prototype.hostname = "";
      ReportHeader2.prototype.agentVersion = "";
      ReportHeader2.prototype.serviceVersion = "";
      ReportHeader2.prototype.runtimeVersion = "";
      ReportHeader2.prototype.uname = "";
      ReportHeader2.prototype.executableSchemaId = "";
      ReportHeader2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReportHeader2(properties);
      }, "create");
      ReportHeader2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.hostname != null && Object.hasOwnProperty.call(message, "hostname"))
          writer.uint32(
            /* id 5, wireType 2 =*/
            42
          ).string(message.hostname);
        if (message.agentVersion != null && Object.hasOwnProperty.call(message, "agentVersion"))
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.agentVersion);
        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, "serviceVersion"))
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.serviceVersion);
        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, "runtimeVersion"))
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.runtimeVersion);
        if (message.uname != null && Object.hasOwnProperty.call(message, "uname"))
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).string(message.uname);
        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, "executableSchemaId"))
          writer.uint32(
            /* id 11, wireType 2 =*/
            90
          ).string(message.executableSchemaId);
        if (message.graphRef != null && Object.hasOwnProperty.call(message, "graphRef"))
          writer.uint32(
            /* id 12, wireType 2 =*/
            98
          ).string(message.graphRef);
        return writer;
      }, "encode");
      ReportHeader2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReportHeader2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.ReportHeader();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 12:
              message.graphRef = reader.string();
              break;
            case 5:
              message.hostname = reader.string();
              break;
            case 6:
              message.agentVersion = reader.string();
              break;
            case 7:
              message.serviceVersion = reader.string();
              break;
            case 8:
              message.runtimeVersion = reader.string();
              break;
            case 9:
              message.uname = reader.string();
              break;
            case 11:
              message.executableSchemaId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReportHeader2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReportHeader2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.graphRef != null && message.hasOwnProperty("graphRef")) {
          if (!$util2.isString(message.graphRef))
            return "graphRef: string expected";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname")) {
          if (!$util2.isString(message.hostname))
            return "hostname: string expected";
        }
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion")) {
          if (!$util2.isString(message.agentVersion))
            return "agentVersion: string expected";
        }
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion")) {
          if (!$util2.isString(message.serviceVersion))
            return "serviceVersion: string expected";
        }
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion")) {
          if (!$util2.isString(message.runtimeVersion))
            return "runtimeVersion: string expected";
        }
        if (message.uname != null && message.hasOwnProperty("uname")) {
          if (!$util2.isString(message.uname))
            return "uname: string expected";
        }
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId")) {
          if (!$util2.isString(message.executableSchemaId))
            return "executableSchemaId: string expected";
        }
        return null;
      }, "verify");
      ReportHeader2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.hostname = "";
          object.agentVersion = "";
          object.serviceVersion = "";
          object.runtimeVersion = "";
          object.uname = "";
          object.executableSchemaId = "";
          object.graphRef = "";
        }
        if (message.hostname != null && message.hasOwnProperty("hostname"))
          object.hostname = message.hostname;
        if (message.agentVersion != null && message.hasOwnProperty("agentVersion"))
          object.agentVersion = message.agentVersion;
        if (message.serviceVersion != null && message.hasOwnProperty("serviceVersion"))
          object.serviceVersion = message.serviceVersion;
        if (message.runtimeVersion != null && message.hasOwnProperty("runtimeVersion"))
          object.runtimeVersion = message.runtimeVersion;
        if (message.uname != null && message.hasOwnProperty("uname"))
          object.uname = message.uname;
        if (message.executableSchemaId != null && message.hasOwnProperty("executableSchemaId"))
          object.executableSchemaId = message.executableSchemaId;
        if (message.graphRef != null && message.hasOwnProperty("graphRef"))
          object.graphRef = message.graphRef;
        return object;
      }, "toObject");
      ReportHeader2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return ReportHeader2;
    }();
    $root2.PathErrorStats = function() {
      function PathErrorStats2(properties) {
        this.children = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(PathErrorStats2, "PathErrorStats");
      PathErrorStats2.prototype.children = $util2.emptyObject;
      PathErrorStats2.prototype.errorsCount = 0;
      PathErrorStats2.prototype.requestsWithErrorsCount = 0;
      PathErrorStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new PathErrorStats2(properties);
      }, "create");
      PathErrorStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.children != null && Object.hasOwnProperty.call(message, "children"))
          for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root2.PathErrorStats.encode(message.children[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.requestsWithErrorsCount);
        return writer;
      }, "encode");
      PathErrorStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      PathErrorStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.PathErrorStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              reader.skip().pos++;
              if (message.children === $util2.emptyObject)
                message.children = {};
              key = reader.string();
              reader.pos++;
              message.children[key] = $root2.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      PathErrorStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      PathErrorStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.children != null && message.hasOwnProperty("children")) {
          if (!$util2.isObject(message.children))
            return "children: object expected";
          var key = Object.keys(message.children);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root2.PathErrorStats.verify(message.children[key[i]]);
            if (error3)
              return "children." + error3;
          }
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util2.isInteger(message.errorsCount) && !(message.errorsCount && $util2.isInteger(message.errorsCount.low) && $util2.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util2.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util2.isInteger(message.requestsWithErrorsCount.low) && $util2.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        return null;
      }, "verify");
      PathErrorStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.children = {};
        if (options.defaults) {
          object.errorsCount = 0;
          object.requestsWithErrorsCount = 0;
        }
        var keys2;
        if (message.children && (keys2 = Object.keys(message.children)).length) {
          object.children = {};
          for (var j = 0; j < keys2.length; ++j)
            object.children[keys2[j]] = $root2.PathErrorStats.toObject(message.children[keys2[j]], options);
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util2.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util2.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util2.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util2.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        return object;
      }, "toObject");
      PathErrorStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return PathErrorStats2;
    }();
    $root2.QueryLatencyStats = function() {
      function QueryLatencyStats2(properties) {
        this.latencyCount = [];
        this.cacheLatencyCount = [];
        this.publicCacheTtlCount = [];
        this.privateCacheTtlCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(QueryLatencyStats2, "QueryLatencyStats");
      QueryLatencyStats2.prototype.latencyCount = $util2.emptyArray;
      QueryLatencyStats2.prototype.requestCount = 0;
      QueryLatencyStats2.prototype.cacheHits = 0;
      QueryLatencyStats2.prototype.persistedQueryHits = 0;
      QueryLatencyStats2.prototype.persistedQueryMisses = 0;
      QueryLatencyStats2.prototype.cacheLatencyCount = $util2.emptyArray;
      QueryLatencyStats2.prototype.rootErrorStats = null;
      QueryLatencyStats2.prototype.requestsWithErrorsCount = 0;
      QueryLatencyStats2.prototype.publicCacheTtlCount = $util2.emptyArray;
      QueryLatencyStats2.prototype.privateCacheTtlCount = $util2.emptyArray;
      QueryLatencyStats2.prototype.registeredOperationCount = 0;
      QueryLatencyStats2.prototype.forbiddenOperationCount = 0;
      QueryLatencyStats2.prototype.requestsWithoutFieldInstrumentation = 0;
      QueryLatencyStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new QueryLatencyStats2(properties);
      }, "create");
      QueryLatencyStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.requestCount != null && Object.hasOwnProperty.call(message, "requestCount"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).uint64(message.requestCount);
        if (message.cacheHits != null && Object.hasOwnProperty.call(message, "cacheHits"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).uint64(message.cacheHits);
        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, "persistedQueryHits"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.persistedQueryHits);
        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, "persistedQueryMisses"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.persistedQueryMisses);
        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, "rootErrorStats"))
          $root2.PathErrorStats.encode(message.rootErrorStats, writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 8, wireType 0 =*/
            64
          ).uint64(message.requestsWithErrorsCount);
        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, "registeredOperationCount"))
          writer.uint32(
            /* id 11, wireType 0 =*/
            88
          ).uint64(message.registeredOperationCount);
        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, "forbiddenOperationCount"))
          writer.uint32(
            /* id 12, wireType 0 =*/
            96
          ).uint64(message.forbiddenOperationCount);
        var array13;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array13 = message.latencyCount.toArray();
        else
          array13 = message.latencyCount;
        if (array13 != null && array13.length) {
          writer.uint32(
            /* id 13, wireType 2 =*/
            106
          ).fork();
          for (var i = 0; i < array13.length; ++i)
            writer.sint64(array13[i]);
          writer.ldelim();
        }
        var array14;
        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
          array14 = message.cacheLatencyCount.toArray();
        else
          array14 = message.cacheLatencyCount;
        if (array14 != null && array14.length) {
          writer.uint32(
            /* id 14, wireType 2 =*/
            114
          ).fork();
          for (var i = 0; i < array14.length; ++i)
            writer.sint64(array14[i]);
          writer.ldelim();
        }
        var array15;
        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
          array15 = message.publicCacheTtlCount.toArray();
        else
          array15 = message.publicCacheTtlCount;
        if (array15 != null && array15.length) {
          writer.uint32(
            /* id 15, wireType 2 =*/
            122
          ).fork();
          for (var i = 0; i < array15.length; ++i)
            writer.sint64(array15[i]);
          writer.ldelim();
        }
        var array16;
        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
          array16 = message.privateCacheTtlCount.toArray();
        else
          array16 = message.privateCacheTtlCount;
        if (array16 != null && array16.length) {
          writer.uint32(
            /* id 16, wireType 2 =*/
            130
          ).fork();
          for (var i = 0; i < array16.length; ++i)
            writer.sint64(array16[i]);
          writer.ldelim();
        }
        if (message.requestsWithoutFieldInstrumentation != null && Object.hasOwnProperty.call(message, "requestsWithoutFieldInstrumentation"))
          writer.uint32(
            /* id 17, wireType 0 =*/
            136
          ).uint64(message.requestsWithoutFieldInstrumentation);
        return writer;
      }, "encode");
      QueryLatencyStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      QueryLatencyStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.QueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 13:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            case 2:
              message.requestCount = reader.uint64();
              break;
            case 3:
              message.cacheHits = reader.uint64();
              break;
            case 4:
              message.persistedQueryHits = reader.uint64();
              break;
            case 5:
              message.persistedQueryMisses = reader.uint64();
              break;
            case 14:
              if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))
                message.cacheLatencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.cacheLatencyCount.push(reader.sint64());
              } else
                message.cacheLatencyCount.push(reader.sint64());
              break;
            case 7:
              message.rootErrorStats = $root2.PathErrorStats.decode(reader, reader.uint32());
              break;
            case 8:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 15:
              if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))
                message.publicCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.publicCacheTtlCount.push(reader.sint64());
              } else
                message.publicCacheTtlCount.push(reader.sint64());
              break;
            case 16:
              if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))
                message.privateCacheTtlCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.privateCacheTtlCount.push(reader.sint64());
              } else
                message.privateCacheTtlCount.push(reader.sint64());
              break;
            case 11:
              message.registeredOperationCount = reader.uint64();
              break;
            case 12:
              message.forbiddenOperationCount = reader.uint64();
              break;
            case 17:
              message.requestsWithoutFieldInstrumentation = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      QueryLatencyStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      QueryLatencyStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array13;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array13 = message.latencyCount.toArray();
          else
            array13 = message.latencyCount;
          if (!Array.isArray(array13))
            return "latencyCount: array expected";
          for (var i = 0; i < array13.length; ++i)
            if (!$util2.isInteger(array13[i]) && !(array13[i] && $util2.isInteger(array13[i].low) && $util2.isInteger(array13[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount")) {
          if (!$util2.isInteger(message.requestCount) && !(message.requestCount && $util2.isInteger(message.requestCount.low) && $util2.isInteger(message.requestCount.high)))
            return "requestCount: integer|Long expected";
        }
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits")) {
          if (!$util2.isInteger(message.cacheHits) && !(message.cacheHits && $util2.isInteger(message.cacheHits.low) && $util2.isInteger(message.cacheHits.high)))
            return "cacheHits: integer|Long expected";
        }
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits")) {
          if (!$util2.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util2.isInteger(message.persistedQueryHits.low) && $util2.isInteger(message.persistedQueryHits.high)))
            return "persistedQueryHits: integer|Long expected";
        }
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses")) {
          if (!$util2.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util2.isInteger(message.persistedQueryMisses.low) && $util2.isInteger(message.persistedQueryMisses.high)))
            return "persistedQueryMisses: integer|Long expected";
        }
        if (message.cacheLatencyCount != null && message.hasOwnProperty("cacheLatencyCount")) {
          var array14;
          if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)
            array14 = message.cacheLatencyCount.toArray();
          else
            array14 = message.cacheLatencyCount;
          if (!Array.isArray(array14))
            return "cacheLatencyCount: array expected";
          for (var i = 0; i < array14.length; ++i)
            if (!$util2.isInteger(array14[i]) && !(array14[i] && $util2.isInteger(array14[i].low) && $util2.isInteger(array14[i].high)))
              return "cacheLatencyCount: integer|Long[] expected";
        }
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats")) {
          var error3 = $root2.PathErrorStats.verify(message.rootErrorStats);
          if (error3)
            return "rootErrorStats." + error3;
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util2.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util2.isInteger(message.requestsWithErrorsCount.low) && $util2.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.publicCacheTtlCount != null && message.hasOwnProperty("publicCacheTtlCount")) {
          var array15;
          if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)
            array15 = message.publicCacheTtlCount.toArray();
          else
            array15 = message.publicCacheTtlCount;
          if (!Array.isArray(array15))
            return "publicCacheTtlCount: array expected";
          for (var i = 0; i < array15.length; ++i)
            if (!$util2.isInteger(array15[i]) && !(array15[i] && $util2.isInteger(array15[i].low) && $util2.isInteger(array15[i].high)))
              return "publicCacheTtlCount: integer|Long[] expected";
        }
        if (message.privateCacheTtlCount != null && message.hasOwnProperty("privateCacheTtlCount")) {
          var array16;
          if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)
            array16 = message.privateCacheTtlCount.toArray();
          else
            array16 = message.privateCacheTtlCount;
          if (!Array.isArray(array16))
            return "privateCacheTtlCount: array expected";
          for (var i = 0; i < array16.length; ++i)
            if (!$util2.isInteger(array16[i]) && !(array16[i] && $util2.isInteger(array16[i].low) && $util2.isInteger(array16[i].high)))
              return "privateCacheTtlCount: integer|Long[] expected";
        }
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount")) {
          if (!$util2.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util2.isInteger(message.registeredOperationCount.low) && $util2.isInteger(message.registeredOperationCount.high)))
            return "registeredOperationCount: integer|Long expected";
        }
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount")) {
          if (!$util2.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util2.isInteger(message.forbiddenOperationCount.low) && $util2.isInteger(message.forbiddenOperationCount.high)))
            return "forbiddenOperationCount: integer|Long expected";
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation")) {
          if (!$util2.isInteger(message.requestsWithoutFieldInstrumentation) && !(message.requestsWithoutFieldInstrumentation && $util2.isInteger(message.requestsWithoutFieldInstrumentation.low) && $util2.isInteger(message.requestsWithoutFieldInstrumentation.high)))
            return "requestsWithoutFieldInstrumentation: integer|Long expected";
        }
        return null;
      }, "verify");
      QueryLatencyStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.latencyCount = [];
          object.cacheLatencyCount = [];
          object.publicCacheTtlCount = [];
          object.privateCacheTtlCount = [];
        }
        if (options.defaults) {
          object.requestCount = 0;
          object.cacheHits = 0;
          object.persistedQueryHits = 0;
          object.persistedQueryMisses = 0;
          object.rootErrorStats = null;
          object.requestsWithErrorsCount = 0;
          object.registeredOperationCount = 0;
          object.forbiddenOperationCount = 0;
          object.requestsWithoutFieldInstrumentation = 0;
        }
        if (message.requestCount != null && message.hasOwnProperty("requestCount"))
          if (typeof message.requestCount === "number")
            object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;
          else
            object.requestCount = options.longs === String ? $util2.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util2.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;
        if (message.cacheHits != null && message.hasOwnProperty("cacheHits"))
          if (typeof message.cacheHits === "number")
            object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;
          else
            object.cacheHits = options.longs === String ? $util2.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util2.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;
        if (message.persistedQueryHits != null && message.hasOwnProperty("persistedQueryHits"))
          if (typeof message.persistedQueryHits === "number")
            object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;
          else
            object.persistedQueryHits = options.longs === String ? $util2.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util2.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;
        if (message.persistedQueryMisses != null && message.hasOwnProperty("persistedQueryMisses"))
          if (typeof message.persistedQueryMisses === "number")
            object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;
          else
            object.persistedQueryMisses = options.longs === String ? $util2.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util2.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;
        if (message.rootErrorStats != null && message.hasOwnProperty("rootErrorStats"))
          object.rootErrorStats = $root2.PathErrorStats.toObject(message.rootErrorStats, options);
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util2.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util2.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.registeredOperationCount != null && message.hasOwnProperty("registeredOperationCount"))
          if (typeof message.registeredOperationCount === "number")
            object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;
          else
            object.registeredOperationCount = options.longs === String ? $util2.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util2.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;
        if (message.forbiddenOperationCount != null && message.hasOwnProperty("forbiddenOperationCount"))
          if (typeof message.forbiddenOperationCount === "number")
            object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;
          else
            object.forbiddenOperationCount = options.longs === String ? $util2.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util2.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util2.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util2.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {
          object.cacheLatencyCount = [];
          for (var j = 0; j < message.cacheLatencyCount.length; ++j)
            if (typeof message.cacheLatencyCount[j] === "number")
              object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];
            else
              object.cacheLatencyCount[j] = options.longs === String ? $util2.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util2.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];
        }
        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {
          object.publicCacheTtlCount = [];
          for (var j = 0; j < message.publicCacheTtlCount.length; ++j)
            if (typeof message.publicCacheTtlCount[j] === "number")
              object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];
            else
              object.publicCacheTtlCount[j] = options.longs === String ? $util2.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util2.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];
        }
        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {
          object.privateCacheTtlCount = [];
          for (var j = 0; j < message.privateCacheTtlCount.length; ++j)
            if (typeof message.privateCacheTtlCount[j] === "number")
              object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];
            else
              object.privateCacheTtlCount[j] = options.longs === String ? $util2.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util2.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];
        }
        if (message.requestsWithoutFieldInstrumentation != null && message.hasOwnProperty("requestsWithoutFieldInstrumentation"))
          if (typeof message.requestsWithoutFieldInstrumentation === "number")
            object.requestsWithoutFieldInstrumentation = options.longs === String ? String(message.requestsWithoutFieldInstrumentation) : message.requestsWithoutFieldInstrumentation;
          else
            object.requestsWithoutFieldInstrumentation = options.longs === String ? $util2.Long.prototype.toString.call(message.requestsWithoutFieldInstrumentation) : options.longs === Number ? new $util2.LongBits(message.requestsWithoutFieldInstrumentation.low >>> 0, message.requestsWithoutFieldInstrumentation.high >>> 0).toNumber(true) : message.requestsWithoutFieldInstrumentation;
        return object;
      }, "toObject");
      QueryLatencyStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return QueryLatencyStats2;
    }();
    $root2.StatsContext = function() {
      function StatsContext2(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(StatsContext2, "StatsContext");
      StatsContext2.prototype.clientName = "";
      StatsContext2.prototype.clientVersion = "";
      StatsContext2.create = /* @__PURE__ */ __name(function create(properties) {
        return new StatsContext2(properties);
      }, "create");
      StatsContext2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.clientName != null && Object.hasOwnProperty.call(message, "clientName"))
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).string(message.clientName);
        if (message.clientVersion != null && Object.hasOwnProperty.call(message, "clientVersion"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.clientVersion);
        return writer;
      }, "encode");
      StatsContext2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      StatsContext2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.StatsContext();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.clientName = reader.string();
              break;
            case 3:
              message.clientVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      StatsContext2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      StatsContext2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.clientName != null && message.hasOwnProperty("clientName")) {
          if (!$util2.isString(message.clientName))
            return "clientName: string expected";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
          if (!$util2.isString(message.clientVersion))
            return "clientVersion: string expected";
        }
        return null;
      }, "verify");
      StatsContext2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.clientName = "";
          object.clientVersion = "";
        }
        if (message.clientName != null && message.hasOwnProperty("clientName"))
          object.clientName = message.clientName;
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
          object.clientVersion = message.clientVersion;
        return object;
      }, "toObject");
      StatsContext2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return StatsContext2;
    }();
    $root2.ContextualizedQueryLatencyStats = function() {
      function ContextualizedQueryLatencyStats2(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedQueryLatencyStats2, "ContextualizedQueryLatencyStats");
      ContextualizedQueryLatencyStats2.prototype.queryLatencyStats = null;
      ContextualizedQueryLatencyStats2.prototype.context = null;
      ContextualizedQueryLatencyStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedQueryLatencyStats2(properties);
      }, "create");
      ContextualizedQueryLatencyStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root2.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root2.StatsContext.encode(message.context, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        return writer;
      }, "encode");
      ContextualizedQueryLatencyStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedQueryLatencyStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.ContextualizedQueryLatencyStats();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.queryLatencyStats = $root2.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.context = $root2.StatsContext.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedQueryLatencyStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedQueryLatencyStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error3 = $root2.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root2.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        return null;
      }, "verify");
      ContextualizedQueryLatencyStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.queryLatencyStats = null;
          object.context = null;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root2.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root2.StatsContext.toObject(message.context, options);
        return object;
      }, "toObject");
      ContextualizedQueryLatencyStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedQueryLatencyStats2;
    }();
    $root2.ContextualizedTypeStats = function() {
      function ContextualizedTypeStats2(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedTypeStats2, "ContextualizedTypeStats");
      ContextualizedTypeStats2.prototype.context = null;
      ContextualizedTypeStats2.prototype.perTypeStat = $util2.emptyObject;
      ContextualizedTypeStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedTypeStats2(properties);
      }, "create");
      ContextualizedTypeStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root2.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root2.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedTypeStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedTypeStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.ContextualizedTypeStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root2.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              reader.skip().pos++;
              if (message.perTypeStat === $util2.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root2.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedTypeStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedTypeStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root2.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util2.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root2.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedTypeStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults)
          object.context = null;
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root2.StatsContext.toObject(message.context, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root2.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedTypeStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedTypeStats2;
    }();
    $root2.FieldStat = function() {
      function FieldStat2(properties) {
        this.latencyCount = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(FieldStat2, "FieldStat");
      FieldStat2.prototype.returnType = "";
      FieldStat2.prototype.errorsCount = 0;
      FieldStat2.prototype.observedExecutionCount = 0;
      FieldStat2.prototype.estimatedExecutionCount = 0;
      FieldStat2.prototype.requestsWithErrorsCount = 0;
      FieldStat2.prototype.latencyCount = $util2.emptyArray;
      FieldStat2.create = /* @__PURE__ */ __name(function create(properties) {
        return new FieldStat2(properties);
      }, "create");
      FieldStat2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.returnType != null && Object.hasOwnProperty.call(message, "returnType"))
          writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).string(message.returnType);
        if (message.errorsCount != null && Object.hasOwnProperty.call(message, "errorsCount"))
          writer.uint32(
            /* id 4, wireType 0 =*/
            32
          ).uint64(message.errorsCount);
        if (message.observedExecutionCount != null && Object.hasOwnProperty.call(message, "observedExecutionCount"))
          writer.uint32(
            /* id 5, wireType 0 =*/
            40
          ).uint64(message.observedExecutionCount);
        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, "requestsWithErrorsCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.requestsWithErrorsCount);
        var array9;
        if (message.latencyCount != null && message.latencyCount.toArray)
          array9 = message.latencyCount.toArray();
        else
          array9 = message.latencyCount;
        if (array9 != null && array9.length) {
          writer.uint32(
            /* id 9, wireType 2 =*/
            74
          ).fork();
          for (var i = 0; i < array9.length; ++i)
            writer.sint64(array9[i]);
          writer.ldelim();
        }
        if (message.estimatedExecutionCount != null && Object.hasOwnProperty.call(message, "estimatedExecutionCount"))
          writer.uint32(
            /* id 10, wireType 0 =*/
            80
          ).uint64(message.estimatedExecutionCount);
        return writer;
      }, "encode");
      FieldStat2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      FieldStat2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.FieldStat();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.returnType = reader.string();
              break;
            case 4:
              message.errorsCount = reader.uint64();
              break;
            case 5:
              message.observedExecutionCount = reader.uint64();
              break;
            case 10:
              message.estimatedExecutionCount = reader.uint64();
              break;
            case 6:
              message.requestsWithErrorsCount = reader.uint64();
              break;
            case 9:
              if (!(message.latencyCount && message.latencyCount.length))
                message.latencyCount = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.latencyCount.push(reader.sint64());
              } else
                message.latencyCount.push(reader.sint64());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      FieldStat2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      FieldStat2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.returnType != null && message.hasOwnProperty("returnType")) {
          if (!$util2.isString(message.returnType))
            return "returnType: string expected";
        }
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount")) {
          if (!$util2.isInteger(message.errorsCount) && !(message.errorsCount && $util2.isInteger(message.errorsCount.low) && $util2.isInteger(message.errorsCount.high)))
            return "errorsCount: integer|Long expected";
        }
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount")) {
          if (!$util2.isInteger(message.observedExecutionCount) && !(message.observedExecutionCount && $util2.isInteger(message.observedExecutionCount.low) && $util2.isInteger(message.observedExecutionCount.high)))
            return "observedExecutionCount: integer|Long expected";
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount")) {
          if (!$util2.isInteger(message.estimatedExecutionCount) && !(message.estimatedExecutionCount && $util2.isInteger(message.estimatedExecutionCount.low) && $util2.isInteger(message.estimatedExecutionCount.high)))
            return "estimatedExecutionCount: integer|Long expected";
        }
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount")) {
          if (!$util2.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util2.isInteger(message.requestsWithErrorsCount.low) && $util2.isInteger(message.requestsWithErrorsCount.high)))
            return "requestsWithErrorsCount: integer|Long expected";
        }
        if (message.latencyCount != null && message.hasOwnProperty("latencyCount")) {
          var array9;
          if (message.latencyCount != null && message.latencyCount.toArray)
            array9 = message.latencyCount.toArray();
          else
            array9 = message.latencyCount;
          if (!Array.isArray(array9))
            return "latencyCount: array expected";
          for (var i = 0; i < array9.length; ++i)
            if (!$util2.isInteger(array9[i]) && !(array9[i] && $util2.isInteger(array9[i].low) && $util2.isInteger(array9[i].high)))
              return "latencyCount: integer|Long[] expected";
        }
        return null;
      }, "verify");
      FieldStat2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.latencyCount = [];
        if (options.defaults) {
          object.returnType = "";
          object.errorsCount = 0;
          object.observedExecutionCount = 0;
          object.requestsWithErrorsCount = 0;
          object.estimatedExecutionCount = 0;
        }
        if (message.returnType != null && message.hasOwnProperty("returnType"))
          object.returnType = message.returnType;
        if (message.errorsCount != null && message.hasOwnProperty("errorsCount"))
          if (typeof message.errorsCount === "number")
            object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;
          else
            object.errorsCount = options.longs === String ? $util2.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util2.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;
        if (message.observedExecutionCount != null && message.hasOwnProperty("observedExecutionCount"))
          if (typeof message.observedExecutionCount === "number")
            object.observedExecutionCount = options.longs === String ? String(message.observedExecutionCount) : message.observedExecutionCount;
          else
            object.observedExecutionCount = options.longs === String ? $util2.Long.prototype.toString.call(message.observedExecutionCount) : options.longs === Number ? new $util2.LongBits(message.observedExecutionCount.low >>> 0, message.observedExecutionCount.high >>> 0).toNumber(true) : message.observedExecutionCount;
        if (message.requestsWithErrorsCount != null && message.hasOwnProperty("requestsWithErrorsCount"))
          if (typeof message.requestsWithErrorsCount === "number")
            object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;
          else
            object.requestsWithErrorsCount = options.longs === String ? $util2.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util2.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;
        if (message.latencyCount && message.latencyCount.length) {
          object.latencyCount = [];
          for (var j = 0; j < message.latencyCount.length; ++j)
            if (typeof message.latencyCount[j] === "number")
              object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];
            else
              object.latencyCount[j] = options.longs === String ? $util2.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util2.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];
        }
        if (message.estimatedExecutionCount != null && message.hasOwnProperty("estimatedExecutionCount"))
          if (typeof message.estimatedExecutionCount === "number")
            object.estimatedExecutionCount = options.longs === String ? String(message.estimatedExecutionCount) : message.estimatedExecutionCount;
          else
            object.estimatedExecutionCount = options.longs === String ? $util2.Long.prototype.toString.call(message.estimatedExecutionCount) : options.longs === Number ? new $util2.LongBits(message.estimatedExecutionCount.low >>> 0, message.estimatedExecutionCount.high >>> 0).toNumber(true) : message.estimatedExecutionCount;
        return object;
      }, "toObject");
      FieldStat2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return FieldStat2;
    }();
    $root2.TypeStat = function() {
      function TypeStat2(properties) {
        this.perFieldStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TypeStat2, "TypeStat");
      TypeStat2.prototype.perFieldStat = $util2.emptyObject;
      TypeStat2.create = /* @__PURE__ */ __name(function create(properties) {
        return new TypeStat2(properties);
      }, "create");
      TypeStat2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, "perFieldStat"))
          for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root2.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TypeStat2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TypeStat2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.TypeStat(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              reader.skip().pos++;
              if (message.perFieldStat === $util2.emptyObject)
                message.perFieldStat = {};
              key = reader.string();
              reader.pos++;
              message.perFieldStat[key] = $root2.FieldStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TypeStat2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TypeStat2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.perFieldStat != null && message.hasOwnProperty("perFieldStat")) {
          if (!$util2.isObject(message.perFieldStat))
            return "perFieldStat: object expected";
          var key = Object.keys(message.perFieldStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root2.FieldStat.verify(message.perFieldStat[key[i]]);
            if (error3)
              return "perFieldStat." + error3;
          }
        }
        return null;
      }, "verify");
      TypeStat2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perFieldStat = {};
        var keys2;
        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {
          object.perFieldStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perFieldStat[keys2[j]] = $root2.FieldStat.toObject(message.perFieldStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TypeStat2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return TypeStat2;
    }();
    $root2.ReferencedFieldsForType = function() {
      function ReferencedFieldsForType2(properties) {
        this.fieldNames = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ReferencedFieldsForType2, "ReferencedFieldsForType");
      ReferencedFieldsForType2.prototype.fieldNames = $util2.emptyArray;
      ReferencedFieldsForType2.prototype.isInterface = false;
      ReferencedFieldsForType2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ReferencedFieldsForType2(properties);
      }, "create");
      ReferencedFieldsForType2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.fieldNames != null && message.fieldNames.length)
          for (var i = 0; i < message.fieldNames.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.fieldNames[i]);
        if (message.isInterface != null && Object.hasOwnProperty.call(message, "isInterface"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.isInterface);
        return writer;
      }, "encode");
      ReferencedFieldsForType2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ReferencedFieldsForType2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.ReferencedFieldsForType();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.fieldNames && message.fieldNames.length))
                message.fieldNames = [];
              message.fieldNames.push(reader.string());
              break;
            case 2:
              message.isInterface = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ReferencedFieldsForType2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ReferencedFieldsForType2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
          if (!Array.isArray(message.fieldNames))
            return "fieldNames: array expected";
          for (var i = 0; i < message.fieldNames.length; ++i)
            if (!$util2.isString(message.fieldNames[i]))
              return "fieldNames: string[] expected";
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface")) {
          if (typeof message.isInterface !== "boolean")
            return "isInterface: boolean expected";
        }
        return null;
      }, "verify");
      ReferencedFieldsForType2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.fieldNames = [];
        if (options.defaults)
          object.isInterface = false;
        if (message.fieldNames && message.fieldNames.length) {
          object.fieldNames = [];
          for (var j = 0; j < message.fieldNames.length; ++j)
            object.fieldNames[j] = message.fieldNames[j];
        }
        if (message.isInterface != null && message.hasOwnProperty("isInterface"))
          object.isInterface = message.isInterface;
        return object;
      }, "toObject");
      ReferencedFieldsForType2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return ReferencedFieldsForType2;
    }();
    $root2.Report = function() {
      function Report2(properties) {
        this.tracesPerQuery = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(Report2, "Report");
      Report2.prototype.header = null;
      Report2.prototype.tracesPerQuery = $util2.emptyObject;
      Report2.prototype.endTime = null;
      Report2.prototype.operationCount = 0;
      Report2.prototype.tracesPreAggregated = false;
      Report2.create = /* @__PURE__ */ __name(function create(properties) {
        return new Report2(properties);
      }, "create");
      Report2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
          $root2.ReportHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.endTime != null && Object.hasOwnProperty.call(message, "endTime"))
          $root2.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, "tracesPerQuery"))
          for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root2.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        if (message.operationCount != null && Object.hasOwnProperty.call(message, "operationCount"))
          writer.uint32(
            /* id 6, wireType 0 =*/
            48
          ).uint64(message.operationCount);
        if (message.tracesPreAggregated != null && Object.hasOwnProperty.call(message, "tracesPreAggregated"))
          writer.uint32(
            /* id 7, wireType 0 =*/
            56
          ).bool(message.tracesPreAggregated);
        return writer;
      }, "encode");
      Report2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      Report2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.Report(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = $root2.ReportHeader.decode(reader, reader.uint32());
              break;
            case 5:
              reader.skip().pos++;
              if (message.tracesPerQuery === $util2.emptyObject)
                message.tracesPerQuery = {};
              key = reader.string();
              reader.pos++;
              message.tracesPerQuery[key] = $root2.TracesAndStats.decode(reader, reader.uint32());
              break;
            case 2:
              message.endTime = $root2.google.protobuf.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.operationCount = reader.uint64();
              break;
            case 7:
              message.tracesPreAggregated = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      Report2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      Report2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.header != null && message.hasOwnProperty("header")) {
          var error3 = $root2.ReportHeader.verify(message.header);
          if (error3)
            return "header." + error3;
        }
        if (message.tracesPerQuery != null && message.hasOwnProperty("tracesPerQuery")) {
          if (!$util2.isObject(message.tracesPerQuery))
            return "tracesPerQuery: object expected";
          var key = Object.keys(message.tracesPerQuery);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root2.TracesAndStats.verify(message.tracesPerQuery[key[i]]);
            if (error3)
              return "tracesPerQuery." + error3;
          }
        }
        if (message.endTime != null && message.hasOwnProperty("endTime")) {
          var error3 = $root2.google.protobuf.Timestamp.verify(message.endTime);
          if (error3)
            return "endTime." + error3;
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount")) {
          if (!$util2.isInteger(message.operationCount) && !(message.operationCount && $util2.isInteger(message.operationCount.low) && $util2.isInteger(message.operationCount.high)))
            return "operationCount: integer|Long expected";
        }
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated")) {
          if (typeof message.tracesPreAggregated !== "boolean")
            return "tracesPreAggregated: boolean expected";
        }
        return null;
      }, "verify");
      Report2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.tracesPerQuery = {};
        if (options.defaults) {
          object.header = null;
          object.endTime = null;
          object.operationCount = 0;
          object.tracesPreAggregated = false;
        }
        if (message.header != null && message.hasOwnProperty("header"))
          object.header = $root2.ReportHeader.toObject(message.header, options);
        if (message.endTime != null && message.hasOwnProperty("endTime"))
          object.endTime = $root2.google.protobuf.Timestamp.toObject(message.endTime, options);
        var keys2;
        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {
          object.tracesPerQuery = {};
          for (var j = 0; j < keys2.length; ++j)
            object.tracesPerQuery[keys2[j]] = $root2.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);
        }
        if (message.operationCount != null && message.hasOwnProperty("operationCount"))
          if (typeof message.operationCount === "number")
            object.operationCount = options.longs === String ? String(message.operationCount) : message.operationCount;
          else
            object.operationCount = options.longs === String ? $util2.Long.prototype.toString.call(message.operationCount) : options.longs === Number ? new $util2.LongBits(message.operationCount.low >>> 0, message.operationCount.high >>> 0).toNumber(true) : message.operationCount;
        if (message.tracesPreAggregated != null && message.hasOwnProperty("tracesPreAggregated"))
          object.tracesPreAggregated = message.tracesPreAggregated;
        return object;
      }, "toObject");
      Report2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return Report2;
    }();
    $root2.ContextualizedStats = function() {
      function ContextualizedStats2(properties) {
        this.perTypeStat = {};
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(ContextualizedStats2, "ContextualizedStats");
      ContextualizedStats2.prototype.context = null;
      ContextualizedStats2.prototype.queryLatencyStats = null;
      ContextualizedStats2.prototype.perTypeStat = $util2.emptyObject;
      ContextualizedStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new ContextualizedStats2(properties);
      }, "create");
      ContextualizedStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.context != null && Object.hasOwnProperty.call(message, "context"))
          $root2.StatsContext.encode(message.context, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, "queryLatencyStats"))
          $root2.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, "perTypeStat"))
          for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root2.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      ContextualizedStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      ContextualizedStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.ContextualizedStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.context = $root2.StatsContext.decode(reader, reader.uint32());
              break;
            case 2:
              message.queryLatencyStats = $root2.QueryLatencyStats.decode(reader, reader.uint32());
              break;
            case 3:
              reader.skip().pos++;
              if (message.perTypeStat === $util2.emptyObject)
                message.perTypeStat = {};
              key = reader.string();
              reader.pos++;
              message.perTypeStat[key] = $root2.TypeStat.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      ContextualizedStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      ContextualizedStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.context != null && message.hasOwnProperty("context")) {
          var error3 = $root2.StatsContext.verify(message.context);
          if (error3)
            return "context." + error3;
        }
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats")) {
          var error3 = $root2.QueryLatencyStats.verify(message.queryLatencyStats);
          if (error3)
            return "queryLatencyStats." + error3;
        }
        if (message.perTypeStat != null && message.hasOwnProperty("perTypeStat")) {
          if (!$util2.isObject(message.perTypeStat))
            return "perTypeStat: object expected";
          var key = Object.keys(message.perTypeStat);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root2.TypeStat.verify(message.perTypeStat[key[i]]);
            if (error3)
              return "perTypeStat." + error3;
          }
        }
        return null;
      }, "verify");
      ContextualizedStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.objects || options.defaults)
          object.perTypeStat = {};
        if (options.defaults) {
          object.context = null;
          object.queryLatencyStats = null;
        }
        if (message.context != null && message.hasOwnProperty("context"))
          object.context = $root2.StatsContext.toObject(message.context, options);
        if (message.queryLatencyStats != null && message.hasOwnProperty("queryLatencyStats"))
          object.queryLatencyStats = $root2.QueryLatencyStats.toObject(message.queryLatencyStats, options);
        var keys2;
        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {
          object.perTypeStat = {};
          for (var j = 0; j < keys2.length; ++j)
            object.perTypeStat[keys2[j]] = $root2.TypeStat.toObject(message.perTypeStat[keys2[j]], options);
        }
        return object;
      }, "toObject");
      ContextualizedStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return ContextualizedStats2;
    }();
    $root2.TracesAndStats = function() {
      function TracesAndStats2(properties) {
        this.trace = [];
        this.statsWithContext = [];
        this.referencedFieldsByType = {};
        this.internalTracesContributingToStats = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      __name(TracesAndStats2, "TracesAndStats");
      TracesAndStats2.prototype.trace = $util2.emptyArray;
      TracesAndStats2.prototype.statsWithContext = $util2.emptyArray;
      TracesAndStats2.prototype.referencedFieldsByType = $util2.emptyObject;
      TracesAndStats2.prototype.internalTracesContributingToStats = $util2.emptyArray;
      TracesAndStats2.create = /* @__PURE__ */ __name(function create(properties) {
        return new TracesAndStats2(properties);
      }, "create");
      TracesAndStats2.encode = /* @__PURE__ */ __name(function encode(message, writer) {
        if (!writer)
          writer = $Writer2.create();
        if (message.trace != null && message.trace.length)
          for (var i = 0; i < message.trace.length; ++i)
            if (message.trace[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              );
              writer.bytes(message.trace[i]);
            } else
              $root2.Trace.encode(message.trace[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
        var array2;
        if (message.statsWithContext != null && message.statsWithContext.toArray)
          array2 = message.statsWithContext.toArray();
        else
          array2 = message.statsWithContext;
        if (array2 != null && array2.length)
          for (var i = 0; i < array2.length; ++i)
            $root2.ContextualizedStats.encode(array2[i], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              );
              writer.bytes(message.internalTracesContributingToStats[i]);
            } else
              $root2.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
        if (message.referencedFieldsByType != null && Object.hasOwnProperty.call(message, "referencedFieldsByType"))
          for (var keys = Object.keys(message.referencedFieldsByType), i = 0; i < keys.length; ++i) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork().uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(keys[i]);
            $root2.ReferencedFieldsForType.encode(message.referencedFieldsByType[keys[i]], writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim().ldelim();
          }
        return writer;
      }, "encode");
      TracesAndStats2.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      }, "encodeDelimited");
      TracesAndStats2.decode = /* @__PURE__ */ __name(function decode(reader, length) {
        if (!(reader instanceof $Reader2))
          reader = $Reader2.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.TracesAndStats(), key;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (!(message.trace && message.trace.length))
                message.trace = [];
              message.trace.push($root2.Trace.decode(reader, reader.uint32()));
              break;
            case 2:
              if (!(message.statsWithContext && message.statsWithContext.length))
                message.statsWithContext = [];
              message.statsWithContext.push($root2.ContextualizedStats.decode(reader, reader.uint32()));
              break;
            case 4:
              reader.skip().pos++;
              if (message.referencedFieldsByType === $util2.emptyObject)
                message.referencedFieldsByType = {};
              key = reader.string();
              reader.pos++;
              message.referencedFieldsByType[key] = $root2.ReferencedFieldsForType.decode(reader, reader.uint32());
              break;
            case 3:
              if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))
                message.internalTracesContributingToStats = [];
              message.internalTracesContributingToStats.push($root2.Trace.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      }, "decode");
      TracesAndStats2.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
        if (!(reader instanceof $Reader2))
          reader = new $Reader2(reader);
        return this.decode(reader, reader.uint32());
      }, "decodeDelimited");
      TracesAndStats2.verify = /* @__PURE__ */ __name(function verify3(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.trace != null && message.hasOwnProperty("trace")) {
          if (!Array.isArray(message.trace))
            return "trace: array expected";
          for (var i = 0; i < message.trace.length; ++i)
            if (!(message.trace[i] instanceof Uint8Array)) {
              var error3 = $root2.Trace.verify(message.trace[i]);
              if (error3)
                return "trace." + error3;
            }
        }
        if (message.statsWithContext != null && message.hasOwnProperty("statsWithContext")) {
          var array2;
          if (message.statsWithContext != null && message.statsWithContext.toArray)
            array2 = message.statsWithContext.toArray();
          else
            array2 = message.statsWithContext;
          if (!Array.isArray(array2))
            return "statsWithContext: array expected";
          for (var i = 0; i < array2.length; ++i) {
            var error3 = $root2.ContextualizedStats.verify(array2[i]);
            if (error3)
              return "statsWithContext." + error3;
          }
        }
        if (message.referencedFieldsByType != null && message.hasOwnProperty("referencedFieldsByType")) {
          if (!$util2.isObject(message.referencedFieldsByType))
            return "referencedFieldsByType: object expected";
          var key = Object.keys(message.referencedFieldsByType);
          for (var i = 0; i < key.length; ++i) {
            var error3 = $root2.ReferencedFieldsForType.verify(message.referencedFieldsByType[key[i]]);
            if (error3)
              return "referencedFieldsByType." + error3;
          }
        }
        if (message.internalTracesContributingToStats != null && message.hasOwnProperty("internalTracesContributingToStats")) {
          if (!Array.isArray(message.internalTracesContributingToStats))
            return "internalTracesContributingToStats: array expected";
          for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)
            if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {
              var error3 = $root2.Trace.verify(message.internalTracesContributingToStats[i]);
              if (error3)
                return "internalTracesContributingToStats." + error3;
            }
        }
        return null;
      }, "verify");
      TracesAndStats2.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults) {
          object.trace = [];
          object.statsWithContext = [];
          object.internalTracesContributingToStats = [];
        }
        if (options.objects || options.defaults)
          object.referencedFieldsByType = {};
        if (message.trace && message.trace.length) {
          object.trace = [];
          for (var j = 0; j < message.trace.length; ++j)
            object.trace[j] = $root2.Trace.toObject(message.trace[j], options);
        }
        if (message.statsWithContext && message.statsWithContext.length) {
          object.statsWithContext = [];
          for (var j = 0; j < message.statsWithContext.length; ++j)
            object.statsWithContext[j] = $root2.ContextualizedStats.toObject(message.statsWithContext[j], options);
        }
        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {
          object.internalTracesContributingToStats = [];
          for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)
            object.internalTracesContributingToStats[j] = $root2.Trace.toObject(message.internalTracesContributingToStats[j], options);
        }
        var keys2;
        if (message.referencedFieldsByType && (keys2 = Object.keys(message.referencedFieldsByType)).length) {
          object.referencedFieldsByType = {};
          for (var j = 0; j < keys2.length; ++j)
            object.referencedFieldsByType[keys2[j]] = $root2.ReferencedFieldsForType.toObject(message.referencedFieldsByType[keys2[j]], options);
        }
        return object;
      }, "toObject");
      TracesAndStats2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
      }, "toJSON");
      return TracesAndStats2;
    }();
    $root2.google = function() {
      var google2 = {};
      google2.protobuf = function() {
        var protobuf = {};
        protobuf.Timestamp = function() {
          function Timestamp(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          __name(Timestamp, "Timestamp");
          Timestamp.prototype.seconds = 0;
          Timestamp.prototype.nanos = 0;
          Timestamp.create = /* @__PURE__ */ __name(function create(properties) {
            return new Timestamp(properties);
          }, "create");
          Timestamp.encode = /* @__PURE__ */ __name(function encode(message, writer) {
            if (!writer)
              writer = $Writer2.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int32(message.nanos);
            return writer;
          }, "encode");
          Timestamp.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          }, "encodeDelimited");
          Timestamp.decode = /* @__PURE__ */ __name(function decode(reader, length) {
            if (!(reader instanceof $Reader2))
              reader = $Reader2.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root2.google.protobuf.Timestamp();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.seconds = reader.int64();
                  break;
                case 2:
                  message.nanos = reader.int32();
                  break;
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          }, "decode");
          Timestamp.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
            if (!(reader instanceof $Reader2))
              reader = new $Reader2(reader);
            return this.decode(reader, reader.uint32());
          }, "decodeDelimited");
          Timestamp.verify = /* @__PURE__ */ __name(function verify3(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds")) {
              if (!$util2.isInteger(message.seconds) && !(message.seconds && $util2.isInteger(message.seconds.low) && $util2.isInteger(message.seconds.high)))
                return "seconds: integer|Long expected";
            }
            if (message.nanos != null && message.hasOwnProperty("nanos")) {
              if (!$util2.isInteger(message.nanos))
                return "nanos: integer expected";
            }
            return null;
          }, "verify");
          Timestamp.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.seconds = 0;
              object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
              if (typeof message.seconds === "number")
                object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
              else
                object.seconds = options.longs === String ? $util2.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util2.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
              object.nanos = message.nanos;
            return object;
          }, "toObject");
          Timestamp.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
            return this.constructor.toObject(this, $protobuf2.util.toJSONOptions);
          }, "toJSON");
          return Timestamp;
        }();
        return protobuf;
      }();
      return google2;
    }();
    module2.exports = $root2;
  }
});

// ../node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js
var require_calculateReferencedFieldsByType = __commonJS({
  "../node_modules/@apollo/utils.usagereporting/dist/calculateReferencedFieldsByType.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.calculateReferencedFieldsByType = void 0;
    var graphql_1 = require_graphql2();
    var usage_reporting_protobuf_1 = require_protobuf();
    function calculateReferencedFieldsByType2({ document, schema, resolvedOperationName }) {
      const documentSeparatedByOperation = (0, graphql_1.separateOperations)(document);
      const filteredDocument = documentSeparatedByOperation[resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""];
      if (!filteredDocument) {
        throw Error(`shouldn't happen: operation '${resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : ""}' not found`);
      }
      const typeInfo = new graphql_1.TypeInfo(schema);
      const interfaces = /* @__PURE__ */ new Set();
      const referencedFieldSetByType = /* @__PURE__ */ Object.create(null);
      (0, graphql_1.visit)(filteredDocument, (0, graphql_1.visitWithTypeInfo)(typeInfo, {
        Field(field) {
          const fieldName = field.name.value;
          const parentType = typeInfo.getParentType();
          if (!parentType) {
            throw Error(`shouldn't happen: missing parent type for field ${fieldName}`);
          }
          const parentTypeName = parentType.name;
          if (!referencedFieldSetByType[parentTypeName]) {
            referencedFieldSetByType[parentTypeName] = /* @__PURE__ */ new Set();
            if ((0, graphql_1.isInterfaceType)(parentType)) {
              interfaces.add(parentTypeName);
            }
          }
          referencedFieldSetByType[parentTypeName].add(fieldName);
        }
      }));
      const referencedFieldsByType = /* @__PURE__ */ Object.create(null);
      for (const [typeName, fieldNames] of Object.entries(referencedFieldSetByType)) {
        referencedFieldsByType[typeName] = new usage_reporting_protobuf_1.ReferencedFieldsForType({
          fieldNames: [...fieldNames],
          isInterface: interfaces.has(typeName)
        });
      }
      return referencedFieldsByType;
    }
    __name(calculateReferencedFieldsByType2, "calculateReferencedFieldsByType");
    exports2.calculateReferencedFieldsByType = calculateReferencedFieldsByType2;
  }
});

// ../node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js
var require_dist4 = __commonJS({
  "../node_modules/@apollo/utils.dropunuseddefinitions/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dropUnusedDefinitions = void 0;
    var graphql_1 = require_graphql2();
    function dropUnusedDefinitions(ast, operationName) {
      const separated = (0, graphql_1.separateOperations)(ast)[operationName];
      if (!separated) {
        return ast;
      }
      return separated;
    }
    __name(dropUnusedDefinitions, "dropUnusedDefinitions");
    exports2.dropUnusedDefinitions = dropUnusedDefinitions;
  }
});

// ../node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js
var require_dist5 = __commonJS({
  "../node_modules/@apollo/utils.stripsensitiveliterals/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stripSensitiveLiterals = void 0;
    var graphql_1 = require_graphql2();
    function stripSensitiveLiterals(ast, options = {
      hideListAndObjectLiterals: false
    }) {
      const listAndObjectVisitorIfEnabled = options.hideListAndObjectLiterals ? {
        ListValue(node) {
          return { ...node, values: [] };
        },
        ObjectValue(node) {
          return { ...node, fields: [] };
        }
      } : {};
      return (0, graphql_1.visit)(ast, {
        IntValue(node) {
          return { ...node, value: "0" };
        },
        FloatValue(node) {
          return { ...node, value: "0" };
        },
        StringValue(node) {
          return { ...node, value: "", block: false };
        },
        ...listAndObjectVisitorIfEnabled
      });
    }
    __name(stripSensitiveLiterals, "stripSensitiveLiterals");
    exports2.stripSensitiveLiterals = stripSensitiveLiterals;
  }
});

// ../node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js
var require_dist6 = __commonJS({
  "../node_modules/@apollo/utils.printwithreducedwhitespace/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printWithReducedWhitespace = void 0;
    var graphql_1 = require_graphql2();
    function printWithReducedWhitespace(ast) {
      const sanitizedAST = (0, graphql_1.visit)(ast, {
        StringValue(node) {
          return {
            ...node,
            value: Buffer.from(node.value, "utf8").toString("hex"),
            block: false
          };
        }
      });
      const withWhitespace = (0, graphql_1.print)(sanitizedAST);
      const minimizedButStillHex = withWhitespace.replace(/\s+/g, " ").replace(/([^_a-zA-Z0-9]) /g, (_, c) => c).replace(/ ([^_a-zA-Z0-9])/g, (_, c) => c);
      return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
    }
    __name(printWithReducedWhitespace, "printWithReducedWhitespace");
    exports2.printWithReducedWhitespace = printWithReducedWhitespace;
  }
});

// ../node_modules/@apollo/utils.removealiases/dist/index.js
var require_dist7 = __commonJS({
  "../node_modules/@apollo/utils.removealiases/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeAliases = void 0;
    var graphql_1 = require_graphql2();
    function removeAliases(ast) {
      return (0, graphql_1.visit)(ast, {
        Field(node) {
          const { alias, ...rest } = node;
          return rest;
        }
      });
    }
    __name(removeAliases, "removeAliases");
    exports2.removeAliases = removeAliases;
  }
});

// ../node_modules/lodash.sortby/index.js
var require_lodash = __commonJS({
  "../node_modules/lodash.sortby/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    __name(baseSortBy, "baseSortBy");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    __name(baseUnary, "baseUnary");
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    __name(getValue, "getValue");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash2(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash2, "Hash");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    __name(hashClear, "hashClear");
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete, "hashDelete");
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet, "hashGet");
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    __name(hashHas, "hashHas");
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    Hash2.prototype.clear = hashClear;
    Hash2.prototype["delete"] = hashDelete;
    Hash2.prototype.get = hashGet;
    Hash2.prototype.has = hashHas;
    Hash2.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    function listCacheClear() {
      this.__data__ = [];
    }
    __name(listCacheClear, "listCacheClear");
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash2()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    __name(mapCacheDelete, "mapCacheDelete");
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    __name(mapCacheGet, "mapCacheGet");
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    __name(mapCacheHas, "mapCacheHas");
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack2(entries) {
      this.__data__ = new ListCache(entries);
    }
    __name(Stack2, "Stack");
    function stackClear() {
      this.__data__ = new ListCache();
    }
    __name(stackClear, "stackClear");
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    __name(stackDelete, "stackDelete");
    function stackGet(key) {
      return this.__data__.get(key);
    }
    __name(stackGet, "stackGet");
    function stackHas(key) {
      return this.__data__.has(key);
    }
    __name(stackHas, "stackHas");
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    __name(stackSet, "stackSet");
    Stack2.prototype.clear = stackClear;
    Stack2.prototype["delete"] = stackDelete;
    Stack2.prototype.get = stackGet;
    Stack2.prototype.has = stackHas;
    Stack2.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    __name(baseFlatten, "baseFlatten");
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    __name(baseForOwn, "baseForOwn");
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    __name(baseGet, "baseGet");
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    __name(baseGetTag, "baseGetTag");
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    __name(baseHasIn, "baseHasIn");
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject3(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    __name(baseIsEqual, "baseIsEqual");
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack2());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack2());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack2());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    __name(baseIsEqualDeep, "baseIsEqualDeep");
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack2();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    __name(baseIsMatch, "baseIsMatch");
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    __name(baseIsTypedArray, "baseIsTypedArray");
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    __name(baseIteratee, "baseIteratee");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    __name(baseMap, "baseMap");
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    __name(baseMatches, "baseMatches");
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    __name(baseMatchesProperty, "baseMatchesProperty");
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    __name(baseOrderBy, "baseOrderBy");
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    __name(basePropertyDeep, "basePropertyDeep");
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    __name(baseRest, "baseRest");
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol2(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    function castPath(value) {
      return isArray2(value) ? value : stringToPath(value);
    }
    __name(castPath, "castPath");
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    __name(compareAscending, "compareAscending");
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    __name(compareMultiple, "compareMultiple");
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    __name(createBaseEach, "createBaseEach");
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    __name(createBaseFor, "createBaseFor");
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    __name(equalArrays, "equalArrays");
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    __name(equalByTag, "equalByTag");
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    __name(equalObjects, "equalObjects");
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    __name(getMatchData, "getMatchData");
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
    }
    __name(hasPath, "hasPath");
    function isFlattenable(value) {
      return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    __name(isFlattenable, "isFlattenable");
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    function isIterateeCall(value, index, object) {
      if (!isObject3(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    __name(isIterateeCall, "isIterateeCall");
    function isKey(value, object) {
      if (isArray2(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    __name(isKey, "isKey");
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function isStrictComparable(value) {
      return value === value && !isObject3(value);
    }
    __name(isStrictComparable, "isStrictComparable");
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    __name(matchesStrictComparable, "matchesStrictComparable");
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol2(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = /* @__PURE__ */ __name(function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      }, "memoized");
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    __name(memoize, "memoize");
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq, "eq");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString, "toString");
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    __name(get, "get");
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    __name(hasIn, "hasIn");
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    __name(property, "property");
    module2.exports = sortBy;
  }
});

// ../node_modules/@apollo/utils.sortast/dist/index.js
var require_dist8 = __commonJS({
  "../node_modules/@apollo/utils.sortast/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sortAST = void 0;
    var graphql_1 = require_graphql2();
    var lodash_sortby_1 = __importDefault(require_lodash());
    function sortAST(ast) {
      return (0, graphql_1.visit)(ast, {
        Document(node) {
          return {
            ...node,
            definitions: (0, lodash_sortby_1.default)(node.definitions, "kind", "name.value")
          };
        },
        OperationDefinition(node) {
          return sortVariableDefinitions(node);
        },
        SelectionSet(node) {
          return {
            ...node,
            selections: (0, lodash_sortby_1.default)(node.selections, "kind", "name.value")
          };
        },
        Field(node) {
          return sortArguments(node);
        },
        FragmentSpread(node) {
          return sortDirectives(node);
        },
        InlineFragment(node) {
          return sortDirectives(node);
        },
        FragmentDefinition(node) {
          return sortDirectives(sortVariableDefinitions(node));
        },
        Directive(node) {
          return sortArguments(node);
        }
      });
    }
    __name(sortAST, "sortAST");
    exports2.sortAST = sortAST;
    function sortDirectives(node) {
      return "directives" in node ? { ...node, directives: (0, lodash_sortby_1.default)(node.directives, "name.value") } : node;
    }
    __name(sortDirectives, "sortDirectives");
    function sortArguments(node) {
      return "arguments" in node ? { ...node, arguments: (0, lodash_sortby_1.default)(node.arguments, "name.value") } : node;
    }
    __name(sortArguments, "sortArguments");
    function sortVariableDefinitions(node) {
      return "variableDefinitions" in node ? {
        ...node,
        variableDefinitions: (0, lodash_sortby_1.default)(node.variableDefinitions, "variable.name.value")
      } : node;
    }
    __name(sortVariableDefinitions, "sortVariableDefinitions");
  }
});

// ../node_modules/@apollo/utils.usagereporting/dist/signature.js
var require_signature = __commonJS({
  "../node_modules/@apollo/utils.usagereporting/dist/signature.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = void 0;
    var utils_dropunuseddefinitions_1 = require_dist4();
    var utils_stripsensitiveliterals_1 = require_dist5();
    var utils_printwithreducedwhitespace_1 = require_dist6();
    var utils_removealiases_1 = require_dist7();
    var utils_sortast_1 = require_dist8();
    function usageReportingSignature2(ast, operationName) {
      return (0, utils_printwithreducedwhitespace_1.printWithReducedWhitespace)((0, utils_sortast_1.sortAST)((0, utils_removealiases_1.removeAliases)((0, utils_stripsensitiveliterals_1.stripSensitiveLiterals)((0, utils_dropunuseddefinitions_1.dropUnusedDefinitions)(ast, operationName), {
        hideListAndObjectLiterals: true
      }))));
    }
    __name(usageReportingSignature2, "usageReportingSignature");
    exports2.usageReportingSignature = usageReportingSignature2;
  }
});

// ../node_modules/@apollo/utils.usagereporting/dist/index.js
var require_dist9 = __commonJS({
  "../node_modules/@apollo/utils.usagereporting/dist/index.js"(exports2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.usageReportingSignature = exports2.calculateReferencedFieldsByType = void 0;
    var calculateReferencedFieldsByType_1 = require_calculateReferencedFieldsByType();
    Object.defineProperty(exports2, "calculateReferencedFieldsByType", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return calculateReferencedFieldsByType_1.calculateReferencedFieldsByType;
    }, "get") });
    var signature_1 = require_signature();
    Object.defineProperty(exports2, "usageReportingSignature", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return signature_1.usageReportingSignature;
    }, "get") });
  }
});

// ../node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    __name(RetryOperation, "RetryOperation");
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error3 = this._errors[i];
        var message = error3.message;
        var count3 = (counts[message] || 0) + 1;
        counts[message] = count3;
        if (count3 >= mainErrorCount) {
          mainError = error3;
          mainErrorCount = count3;
        }
      }
      return mainError;
    };
  }
});

// ../node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../node_modules/retry/lib/retry.js"(exports2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../node_modules/retry/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = require_retry();
  }
});

// ../node_modules/async-retry/lib/index.js
var require_lib = __commonJS({
  "../node_modules/async-retry/lib/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var retrier = require_retry2();
    function retry2(fn, opts) {
      function run(resolve, reject) {
        var options = opts || {};
        var op;
        if (!("randomize" in options)) {
          options.randomize = true;
        }
        op = retrier.operation(options);
        function bail(err) {
          reject(err || new Error("Aborted"));
        }
        __name(bail, "bail");
        function onError(err, num) {
          if (err.bail) {
            bail(err);
            return;
          }
          if (!op.retry(err)) {
            reject(op.mainError());
          } else if (options.onRetry) {
            options.onRetry(err, num);
          }
        }
        __name(onError, "onError");
        function runAttempt(num) {
          var val;
          try {
            val = fn(bail, num);
          } catch (err) {
            onError(err, num);
            return;
          }
          Promise.resolve(val).then(resolve).catch(/* @__PURE__ */ __name(function catchIt(err) {
            onError(err, num);
          }, "catchIt"));
        }
        __name(runAttempt, "runAttempt");
        op.attempt(runAttempt);
      }
      __name(run, "run");
      return new Promise(run);
    }
    __name(retry2, "retry");
    module2.exports = retry2;
  }
});

// ../node_modules/node-abort-controller/browser.js
var require_browser = __commonJS({
  "../node_modules/node-abort-controller/browser.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    if (!_global) {
      throw new Error(
        `Unable to find global scope. Are you sure this is running in the browser?`
      );
    }
    if (!_global.AbortController) {
      throw new Error(
        `Could not find "AbortController" in the global scope. You need to polyfill it first`
      );
    }
    module2.exports.AbortController = _global.AbortController;
  }
});

// ../node_modules/unenv/dist/runtime/npm/node-fetch.mjs
var fetch2, Headers, Request2, Response2, AbortController3, redirectStatus, isRedirect, node_fetch_default;
var init_node_fetch = __esm({
  "../node_modules/unenv/dist/runtime/npm/node-fetch.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    fetch2 = /* @__PURE__ */ __name((...args) => globalThis.fetch(...args), "fetch");
    Headers = globalThis.Headers;
    Request2 = globalThis.Request;
    Response2 = globalThis.Response;
    AbortController3 = globalThis.AbortController;
    redirectStatus = /* @__PURE__ */ new Set([
      301,
      302,
      303,
      307,
      308
    ]);
    isRedirect = /* @__PURE__ */ __name((code) => redirectStatus.has(code), "isRedirect");
    fetch2.Promise = globalThis.Promise;
    fetch2.isRedirect = isRedirect;
    node_fetch_default = fetch2;
  }
});

// ../node_modules/unenv/dist/runtime/node/internal/os/constants.mjs
var UV_UDP_REUSEADDR, dlopen2, errno, signals, priority;
var init_constants2 = __esm({
  "../node_modules/unenv/dist/runtime/node/internal/os/constants.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_UDP_REUSEADDR = 4;
    dlopen2 = {
      RTLD_LAZY: 1,
      RTLD_NOW: 2,
      RTLD_GLOBAL: 256,
      RTLD_LOCAL: 0,
      RTLD_DEEPBIND: 8
    };
    errno = {
      E2BIG: 7,
      EACCES: 13,
      EADDRINUSE: 98,
      EADDRNOTAVAIL: 99,
      EAFNOSUPPORT: 97,
      EAGAIN: 11,
      EALREADY: 114,
      EBADF: 9,
      EBADMSG: 74,
      EBUSY: 16,
      ECANCELED: 125,
      ECHILD: 10,
      ECONNABORTED: 103,
      ECONNREFUSED: 111,
      ECONNRESET: 104,
      EDEADLK: 35,
      EDESTADDRREQ: 89,
      EDOM: 33,
      EDQUOT: 122,
      EEXIST: 17,
      EFAULT: 14,
      EFBIG: 27,
      EHOSTUNREACH: 113,
      EIDRM: 43,
      EILSEQ: 84,
      EINPROGRESS: 115,
      EINTR: 4,
      EINVAL: 22,
      EIO: 5,
      EISCONN: 106,
      EISDIR: 21,
      ELOOP: 40,
      EMFILE: 24,
      EMLINK: 31,
      EMSGSIZE: 90,
      EMULTIHOP: 72,
      ENAMETOOLONG: 36,
      ENETDOWN: 100,
      ENETRESET: 102,
      ENETUNREACH: 101,
      ENFILE: 23,
      ENOBUFS: 105,
      ENODATA: 61,
      ENODEV: 19,
      ENOENT: 2,
      ENOEXEC: 8,
      ENOLCK: 37,
      ENOLINK: 67,
      ENOMEM: 12,
      ENOMSG: 42,
      ENOPROTOOPT: 92,
      ENOSPC: 28,
      ENOSR: 63,
      ENOSTR: 60,
      ENOSYS: 38,
      ENOTCONN: 107,
      ENOTDIR: 20,
      ENOTEMPTY: 39,
      ENOTSOCK: 88,
      ENOTSUP: 95,
      ENOTTY: 25,
      ENXIO: 6,
      EOPNOTSUPP: 95,
      EOVERFLOW: 75,
      EPERM: 1,
      EPIPE: 32,
      EPROTO: 71,
      EPROTONOSUPPORT: 93,
      EPROTOTYPE: 91,
      ERANGE: 34,
      EROFS: 30,
      ESPIPE: 29,
      ESRCH: 3,
      ESTALE: 116,
      ETIME: 62,
      ETIMEDOUT: 110,
      ETXTBSY: 26,
      EWOULDBLOCK: 11,
      EXDEV: 18
    };
    signals = {
      SIGHUP: 1,
      SIGINT: 2,
      SIGQUIT: 3,
      SIGILL: 4,
      SIGTRAP: 5,
      SIGABRT: 6,
      SIGIOT: 6,
      SIGBUS: 7,
      SIGFPE: 8,
      SIGKILL: 9,
      SIGUSR1: 10,
      SIGSEGV: 11,
      SIGUSR2: 12,
      SIGPIPE: 13,
      SIGALRM: 14,
      SIGTERM: 15,
      SIGCHLD: 17,
      SIGSTKFLT: 16,
      SIGCONT: 18,
      SIGSTOP: 19,
      SIGTSTP: 20,
      SIGTTIN: 21,
      SIGTTOU: 22,
      SIGURG: 23,
      SIGXCPU: 24,
      SIGXFSZ: 25,
      SIGVTALRM: 26,
      SIGPROF: 27,
      SIGWINCH: 28,
      SIGIO: 29,
      SIGPOLL: 29,
      SIGPWR: 30,
      SIGSYS: 31
    };
    priority = {
      PRIORITY_LOW: 19,
      PRIORITY_BELOW_NORMAL: 10,
      PRIORITY_NORMAL: 0,
      PRIORITY_ABOVE_NORMAL: -7,
      PRIORITY_HIGH: -14,
      PRIORITY_HIGHEST: -20
    };
  }
});

// ../node_modules/unenv/dist/runtime/node/os.mjs
var constants2, NUM_CPUS, availableParallelism, arch2, machine, endianness, cpus, getPriority, setPriority, homedir, tmpdir, devNull, freemem, totalmem, loadavg, uptime2, hostname, networkInterfaces, platform2, type, release2, version2, userInfo, EOL, os_default;
var init_os = __esm({
  "../node_modules/unenv/dist/runtime/node/os.mjs"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_constants2();
    constants2 = {
      UV_UDP_REUSEADDR,
      dlopen: dlopen2,
      errno,
      signals,
      priority
    };
    NUM_CPUS = 8;
    availableParallelism = /* @__PURE__ */ __name(() => NUM_CPUS, "availableParallelism");
    arch2 = /* @__PURE__ */ __name(() => "", "arch");
    machine = /* @__PURE__ */ __name(() => "", "machine");
    endianness = /* @__PURE__ */ __name(() => "LE", "endianness");
    cpus = /* @__PURE__ */ __name(() => {
      const info3 = {
        model: "",
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0
        }
      };
      return Array.from({ length: NUM_CPUS }, () => info3);
    }, "cpus");
    getPriority = /* @__PURE__ */ __name(() => 0, "getPriority");
    setPriority = /* @__PURE__ */ notImplemented("os.setPriority");
    homedir = /* @__PURE__ */ __name(() => "/", "homedir");
    tmpdir = /* @__PURE__ */ __name(() => "/tmp", "tmpdir");
    devNull = "/dev/null";
    freemem = /* @__PURE__ */ __name(() => 0, "freemem");
    totalmem = /* @__PURE__ */ __name(() => 0, "totalmem");
    loadavg = /* @__PURE__ */ __name(() => [
      0,
      0,
      0
    ], "loadavg");
    uptime2 = /* @__PURE__ */ __name(() => 0, "uptime");
    hostname = /* @__PURE__ */ __name(() => "", "hostname");
    networkInterfaces = /* @__PURE__ */ __name(() => {
      return { lo0: [
        {
          address: "127.0.0.1",
          netmask: "255.0.0.0",
          family: "IPv4",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "127.0.0.1/8"
        },
        {
          address: "::1",
          netmask: "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "::1/128",
          scopeid: 0
        },
        {
          address: "fe80::1",
          netmask: "ffff:ffff:ffff:ffff::",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "fe80::1/64",
          scopeid: 1
        }
      ] };
    }, "networkInterfaces");
    platform2 = /* @__PURE__ */ __name(() => "linux", "platform");
    type = /* @__PURE__ */ __name(() => "Linux", "type");
    release2 = /* @__PURE__ */ __name(() => "", "release");
    version2 = /* @__PURE__ */ __name(() => "", "version");
    userInfo = /* @__PURE__ */ __name((opts) => {
      const encode = /* @__PURE__ */ __name((str) => {
        if (opts?.encoding) {
          const buff = Buffer.from(str);
          return opts.encoding === "buffer" ? buff : buff.toString(opts.encoding);
        }
        return str;
      }, "encode");
      return {
        gid: 1e3,
        uid: 1e3,
        homedir: encode("/"),
        shell: encode("/bin/sh"),
        username: encode("root")
      };
    }, "userInfo");
    EOL = "\n";
    os_default = {
      arch: arch2,
      availableParallelism,
      constants: constants2,
      cpus,
      EOL,
      endianness,
      devNull,
      freemem,
      getPriority,
      homedir,
      hostname,
      loadavg,
      machine,
      networkInterfaces,
      platform: platform2,
      release: release2,
      setPriority,
      tmpdir,
      totalmem,
      type,
      uptime: uptime2,
      userInfo,
      version: version2
    };
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/traceTreeBuilder.js
function internalError(message) {
  return new Error(`[internal apollo-server error] ${message}`);
}
function durationHrTimeToNanos(hrtime4) {
  return hrtime4[0] * 1e9 + hrtime4[1];
}
function responsePathAsString(p) {
  if (p === void 0) {
    return "";
  }
  let res = String(p.key);
  while ((p = p.prev) !== void 0) {
    res = `${p.key}.${res}`;
  }
  return res;
}
function responsePathFromArray(path, node) {
  let responsePath;
  let nodePtr = node;
  for (const key of path) {
    nodePtr = nodePtr?.child?.find((child) => child.responseName === key);
    responsePath = {
      key,
      prev: responsePath,
      typename: nodePtr?.type ?? void 0
    };
  }
  return responsePath;
}
function errorToProtobufError(error3) {
  return new Trace.Error({
    message: error3.message,
    location: (error3.locations || []).map(({ line, column }) => new Trace.Location({ line, column })),
    json: JSON.stringify(error3)
  });
}
function dateToProtoTimestamp(date) {
  const totalMillis = +date;
  const millis = totalMillis % 1e3;
  return new google.protobuf.Timestamp({
    seconds: (totalMillis - millis) / 1e3,
    nanos: millis * 1e6
  });
}
var import_graphql38, TraceTreeBuilder;
var init_traceTreeBuilder = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/traceTreeBuilder.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_graphql38 = __toESM(require_graphql2(), 1);
    init_protobuf();
    init_UnreachableCaseError();
    __name(internalError, "internalError");
    TraceTreeBuilder = class {
      static {
        __name(this, "TraceTreeBuilder");
      }
      constructor(options) {
        this.rootNode = new Trace.Node();
        this.trace = new Trace({
          root: this.rootNode,
          fieldExecutionWeight: 1
        });
        this.stopped = false;
        this.nodes = /* @__PURE__ */ new Map([
          [responsePathAsString(), this.rootNode]
        ]);
        const { sendErrors, maskedBy } = options;
        if (!sendErrors || "masked" in sendErrors) {
          this.transformError = () => new import_graphql38.GraphQLError("<masked>", {
            extensions: { maskedBy }
          });
        } else if ("transform" in sendErrors) {
          this.transformError = sendErrors.transform;
        } else if ("unmodified" in sendErrors) {
          this.transformError = null;
        } else {
          throw new UnreachableCaseError(sendErrors);
        }
      }
      startTiming() {
        if (this.startHrTime) {
          throw internalError("startTiming called twice!");
        }
        if (this.stopped) {
          throw internalError("startTiming called after stopTiming!");
        }
        this.trace.startTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.startHrTime = process.hrtime();
      }
      stopTiming() {
        if (!this.startHrTime) {
          throw internalError("stopTiming called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("stopTiming called twice!");
        }
        this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        this.trace.endTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        this.stopped = true;
      }
      willResolveField(info3) {
        if (!this.startHrTime) {
          throw internalError("willResolveField called before startTiming!");
        }
        if (this.stopped) {
          return () => {
          };
        }
        const path = info3.path;
        const node = this.newNode(path);
        node.type = info3.returnType.toString();
        node.parentType = info3.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        if (typeof path.key === "string" && path.key !== info3.fieldName) {
          node.originalFieldName = info3.fieldName;
        }
        return () => {
          node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        };
      }
      didEncounterErrors(errors) {
        errors.forEach((err) => {
          if (err.extensions?.serviceName) {
            return;
          }
          const errorForReporting = this.transformAndNormalizeError(err);
          if (errorForReporting === null) {
            return;
          }
          this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
        });
      }
      addProtobufError(path, error3) {
        if (!this.startHrTime) {
          throw internalError("addProtobufError called before startTiming!");
        }
        if (this.stopped) {
          throw internalError("addProtobufError called after stopTiming!");
        }
        let node = this.rootNode;
        if (Array.isArray(path)) {
          const specificNode = this.nodes.get(path.join("."));
          if (specificNode) {
            node = specificNode;
          } else {
            const responsePath = responsePathFromArray(path, this.rootNode);
            if (!responsePath) {
              throw internalError("addProtobufError called with invalid path!");
            }
            node = this.newNode(responsePath);
          }
        }
        node.error.push(error3);
      }
      newNode(path) {
        const node = new Trace.Node();
        const id = path.key;
        if (typeof id === "number") {
          node.index = id;
        } else {
          node.responseName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        const parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
      }
      ensureParentNode(path) {
        const parentPath = responsePathAsString(path.prev);
        const parentNode = this.nodes.get(parentPath);
        if (parentNode) {
          return parentNode;
        }
        return this.newNode(path.prev);
      }
      transformAndNormalizeError(err) {
        if (this.transformError) {
          const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
          const rewrittenError = this.transformError(clonedError);
          if (rewrittenError === null) {
            return null;
          }
          if (!(rewrittenError instanceof import_graphql38.GraphQLError)) {
            return err;
          }
          return new import_graphql38.GraphQLError(rewrittenError.message, {
            nodes: err.nodes,
            source: err.source,
            positions: err.positions,
            path: err.path,
            originalError: err.originalError,
            extensions: rewrittenError.extensions || err.extensions
          });
        }
        return err;
      }
    };
    __name(durationHrTimeToNanos, "durationHrTimeToNanos");
    __name(responsePathAsString, "responsePathAsString");
    __name(responsePathFromArray, "responsePathFromArray");
    __name(errorToProtobufError, "errorToProtobufError");
    __name(dateToProtoTimestamp, "dateToProtoTimestamp");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/iterateOverTrace.js
function iterateOverTrace(trace3, f, includePath) {
  const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;
  if (trace3.root) {
    if (iterateOverTraceNode(trace3.root, rootPath, f))
      return;
  }
  if (trace3.queryPlan) {
    if (iterateOverQueryPlan(trace3.queryPlan, rootPath, f))
      return;
  }
}
function iterateOverQueryPlan(node, rootPath, f) {
  if (!node)
    return false;
  if (node.fetch?.trace?.root && node.fetch.serviceName) {
    return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
  }
  if (node.flatten?.node) {
    return iterateOverQueryPlan(node.flatten.node, rootPath, f);
  }
  if (node.parallel?.nodes) {
    return node.parallel.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
  }
  if (node.sequence?.nodes) {
    return node.sequence.nodes.some((node2) => iterateOverQueryPlan(node2, rootPath, f));
  }
  return false;
}
function iterateOverTraceNode(node, path, f) {
  if (f(node, path)) {
    return true;
  }
  return node.child?.some((child) => {
    const childPath = child.responseName ? path.child(child.responseName) : path;
    return iterateOverTraceNode(child, childPath, f);
  }) ?? false;
}
var notCollectingPathsResponseNamePath, RootCollectingPathsResponseNamePath, ChildCollectingPathsResponseNamePath;
var init_iterateOverTrace = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/iterateOverTrace.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(iterateOverTrace, "iterateOverTrace");
    __name(iterateOverQueryPlan, "iterateOverQueryPlan");
    __name(iterateOverTraceNode, "iterateOverTraceNode");
    notCollectingPathsResponseNamePath = {
      toArray() {
        throw Error("not collecting paths!");
      },
      child() {
        return this;
      }
    };
    RootCollectingPathsResponseNamePath = class {
      static {
        __name(this, "RootCollectingPathsResponseNamePath");
      }
      toArray() {
        return [];
      }
      child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
    ChildCollectingPathsResponseNamePath = class _ChildCollectingPathsResponseNamePath {
      static {
        __name(this, "ChildCollectingPathsResponseNamePath");
      }
      constructor(responseName, prev) {
        this.responseName = responseName;
        this.prev = prev;
      }
      toArray() {
        const out = [];
        let curr = this;
        while (curr instanceof _ChildCollectingPathsResponseNamePath) {
          out.push(curr.responseName);
          curr = curr.prev;
        }
        return out.reverse();
      }
      child(responseName) {
        return new _ChildCollectingPathsResponseNamePath(responseName, this);
      }
    };
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/durationHistogram.js
var DurationHistogram;
var init_durationHistogram = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/durationHistogram.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    DurationHistogram = class _DurationHistogram {
      static {
        __name(this, "DurationHistogram");
      }
      toArray() {
        let bufferedZeroes = 0;
        const outputArray = [];
        for (const value of this.buckets) {
          if (value === 0) {
            bufferedZeroes++;
          } else {
            if (bufferedZeroes === 1) {
              outputArray.push(0);
            } else if (bufferedZeroes !== 0) {
              outputArray.push(-bufferedZeroes);
            }
            outputArray.push(Math.floor(value));
            bufferedZeroes = 0;
          }
        }
        return outputArray;
      }
      static durationToBucket(durationNs) {
        const log4 = Math.log(durationNs / 1e3);
        const unboundedBucket = Math.ceil(log4 / _DurationHistogram.EXPONENT_LOG);
        return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= _DurationHistogram.BUCKET_COUNT ? _DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;
      }
      incrementDuration(durationNs, value = 1) {
        this.incrementBucket(_DurationHistogram.durationToBucket(durationNs), value);
        return this;
      }
      incrementBucket(bucket, value = 1) {
        if (bucket >= _DurationHistogram.BUCKET_COUNT) {
          throw Error("Bucket is out of bounds of the buckets array");
        }
        if (bucket >= this.buckets.length) {
          const oldLength = this.buckets.length;
          this.buckets.length = bucket + 1;
          this.buckets.fill(0, oldLength);
        }
        this.buckets[bucket] += value;
      }
      combine(otherHistogram) {
        for (let i = 0; i < otherHistogram.buckets.length; i++) {
          this.incrementBucket(i, otherHistogram.buckets[i]);
        }
      }
      constructor(options) {
        const initSize = options?.initSize || 74;
        const buckets = options?.buckets;
        const arrayInitSize = Math.max(buckets?.length || 0, initSize);
        this.buckets = Array(arrayInitSize).fill(0);
        if (buckets) {
          buckets.forEach((val, index) => this.buckets[index] = val);
        }
      }
    };
    DurationHistogram.BUCKET_COUNT = 384;
    DurationHistogram.EXPONENT_LOG = Math.log(1.1);
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/defaultSendOperationsAsTrace.js
function defaultSendOperationsAsTrace() {
  const cache = new lru_cache_default({
    maxSize: Math.pow(2, 20),
    sizeCalculation: /* @__PURE__ */ __name((_val, key) => {
      return key && Buffer.byteLength(key) || 0;
    }, "sizeCalculation")
  });
  return (trace3, statsReportKey) => {
    const endTimeSeconds = trace3.endTime?.seconds;
    if (endTimeSeconds == null) {
      throw Error("programming error: endTime not set on trace");
    }
    const hasErrors = traceHasErrors(trace3);
    const cacheKey = JSON.stringify([
      statsReportKey,
      DurationHistogram.durationToBucket(trace3.durationNs),
      Math.floor(endTimeSeconds / 60),
      hasErrors ? Math.floor(endTimeSeconds / 5) : ""
    ]);
    if (cache.get(cacheKey)) {
      return false;
    }
    cache.set(cacheKey, true);
    return true;
  };
}
function traceHasErrors(trace3) {
  let hasErrors = false;
  function traceNodeStats(node) {
    if ((node.error?.length ?? 0) > 0) {
      hasErrors = true;
    }
    return hasErrors;
  }
  __name(traceNodeStats, "traceNodeStats");
  iterateOverTrace(trace3, traceNodeStats, false);
  return hasErrors;
}
var init_defaultSendOperationsAsTrace = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/defaultSendOperationsAsTrace.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_lru_cache();
    init_iterateOverTrace();
    init_durationHistogram();
    __name(defaultSendOperationsAsTrace, "defaultSendOperationsAsTrace");
    __name(traceHasErrors, "traceHasErrors");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/operationDerivedDataCache.js
function createOperationDerivedDataCache({ logger }) {
  let lastWarn;
  let lastDisposals = 0;
  return new lru_cache_default({
    sizeCalculation(obj) {
      return Buffer.byteLength(JSON.stringify(obj), "utf8");
    },
    maxSize: Math.pow(2, 20) * 10,
    dispose() {
      lastDisposals++;
      if (!lastWarn || (/* @__PURE__ */ new Date()).getTime() - lastWarn.getTime() > 6e4) {
        lastWarn = /* @__PURE__ */ new Date();
        logger.warn([
          "This server is processing a high number of unique operations.  ",
          `A total of ${lastDisposals} records have been `,
          "ejected from the ApolloServerPluginUsageReporting signature cache in the past ",
          "interval.  If you see this warning frequently, please open an ",
          "issue on the Apollo Server repository."
        ].join(""));
        lastDisposals = 0;
      }
    }
  });
}
function operationDerivedDataCacheKey(queryHash, operationName) {
  return `${queryHash}${operationName && ":" + operationName}`;
}
var init_operationDerivedDataCache = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/operationDerivedDataCache.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_lru_cache();
    __name(createOperationDerivedDataCache, "createOperationDerivedDataCache");
    __name(operationDerivedDataCacheKey, "operationDerivedDataCacheKey");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/stats.js
function estimatedBytesForString(s) {
  return 2 + Buffer.byteLength(s);
}
var SizeEstimator, OurReport, OurTracesAndStats, StatsByContext, OurContextualizedStats, OurQueryLatencyStats, OurPathErrorStats, OurTypeStat, OurFieldStat;
var init_stats = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/stats.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_protobuf();
    init_durationHistogram();
    init_iterateOverTrace();
    SizeEstimator = class {
      static {
        __name(this, "SizeEstimator");
      }
      constructor() {
        this.bytes = 0;
      }
    };
    OurReport = class {
      static {
        __name(this, "OurReport");
      }
      constructor(header) {
        this.header = header;
        this.tracesPreAggregated = false;
        this.tracesPerQuery = /* @__PURE__ */ Object.create(null);
        this.endTime = null;
        this.operationCount = 0;
        this.sizeEstimator = new SizeEstimator();
      }
      ensureCountsAreIntegers() {
        for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
          tracesAndStats.ensureCountsAreIntegers();
        }
      }
      addTrace({ statsReportKey, trace: trace3, asTrace, referencedFieldsByType, maxTraceBytes = 10 * 1024 * 1024, nonFtv1ErrorPaths }) {
        const tracesAndStats = this.getTracesAndStats({
          statsReportKey,
          referencedFieldsByType
        });
        if (asTrace) {
          const encodedTrace = Trace.encode(trace3).finish();
          if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {
            tracesAndStats.statsWithContext.addTrace(trace3, this.sizeEstimator, nonFtv1ErrorPaths);
          } else {
            tracesAndStats.trace.push(encodedTrace);
            this.sizeEstimator.bytes += 2 + encodedTrace.length;
          }
        } else {
          tracesAndStats.statsWithContext.addTrace(trace3, this.sizeEstimator, nonFtv1ErrorPaths);
        }
      }
      getTracesAndStats({ statsReportKey, referencedFieldsByType }) {
        const existing = this.tracesPerQuery[statsReportKey];
        if (existing) {
          return existing;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
        for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {
          this.sizeEstimator.bytes += 2 + 2;
          if (referencedFieldsForType.isInterface) {
            this.sizeEstimator.bytes += 2;
          }
          this.sizeEstimator.bytes += estimatedBytesForString(typeName);
          for (const fieldName of referencedFieldsForType.fieldNames) {
            this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
          }
        }
        return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);
      }
    };
    OurTracesAndStats = class {
      static {
        __name(this, "OurTracesAndStats");
      }
      constructor(referencedFieldsByType) {
        this.referencedFieldsByType = referencedFieldsByType;
        this.trace = [];
        this.statsWithContext = new StatsByContext();
        this.internalTracesContributingToStats = [];
      }
      ensureCountsAreIntegers() {
        this.statsWithContext.ensureCountsAreIntegers();
      }
    };
    StatsByContext = class {
      static {
        __name(this, "StatsByContext");
      }
      constructor() {
        this.map = /* @__PURE__ */ Object.create(null);
      }
      toArray() {
        return Object.values(this.map);
      }
      ensureCountsAreIntegers() {
        for (const contextualizedStats of Object.values(this.map)) {
          contextualizedStats.ensureCountsAreIntegers();
        }
      }
      addTrace(trace3, sizeEstimator, nonFtv1ErrorPaths) {
        this.getContextualizedStats(trace3, sizeEstimator).addTrace(trace3, sizeEstimator, nonFtv1ErrorPaths);
      }
      getContextualizedStats(trace3, sizeEstimator) {
        const statsContext = {
          clientName: trace3.clientName,
          clientVersion: trace3.clientVersion
        };
        const statsContextKey = JSON.stringify(statsContext);
        const existing = this.map[statsContextKey];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += 20 + estimatedBytesForString(trace3.clientName) + estimatedBytesForString(trace3.clientVersion);
        const contextualizedStats = new OurContextualizedStats(statsContext);
        this.map[statsContextKey] = contextualizedStats;
        return contextualizedStats;
      }
    };
    OurContextualizedStats = class {
      static {
        __name(this, "OurContextualizedStats");
      }
      constructor(context2) {
        this.context = context2;
        this.queryLatencyStats = new OurQueryLatencyStats();
        this.perTypeStat = /* @__PURE__ */ Object.create(null);
      }
      ensureCountsAreIntegers() {
        for (const typeStat of Object.values(this.perTypeStat)) {
          typeStat.ensureCountsAreIntegers();
        }
      }
      addTrace(trace3, sizeEstimator, nonFtv1ErrorPaths = []) {
        const { fieldExecutionWeight } = trace3;
        if (!fieldExecutionWeight) {
          this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
        }
        this.queryLatencyStats.requestCount++;
        if (trace3.fullQueryCacheHit) {
          this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace3.durationNs);
          this.queryLatencyStats.cacheHits++;
        } else {
          this.queryLatencyStats.latencyCount.incrementDuration(trace3.durationNs);
        }
        if (!trace3.fullQueryCacheHit && trace3.cachePolicy?.maxAgeNs != null) {
          switch (trace3.cachePolicy.scope) {
            case Trace.CachePolicy.Scope.PRIVATE:
              this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace3.cachePolicy.maxAgeNs);
              break;
            case Trace.CachePolicy.Scope.PUBLIC:
              this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace3.cachePolicy.maxAgeNs);
              break;
          }
        }
        if (trace3.persistedQueryHit) {
          this.queryLatencyStats.persistedQueryHits++;
        }
        if (trace3.persistedQueryRegister) {
          this.queryLatencyStats.persistedQueryMisses++;
        }
        if (trace3.forbiddenOperation) {
          this.queryLatencyStats.forbiddenOperationCount++;
        }
        if (trace3.registeredOperation) {
          this.queryLatencyStats.registeredOperationCount++;
        }
        let hasError = false;
        const errorPathStats = /* @__PURE__ */ new Set();
        const traceNodeStats = /* @__PURE__ */ __name((node, path) => {
          if (node.error?.length) {
            hasError = true;
            let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
            path.toArray().forEach((subPath) => {
              currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
            });
            errorPathStats.add(currPathErrorStats);
            currPathErrorStats.errorsCount += node.error.length;
          }
          if (fieldExecutionWeight) {
            const fieldName = node.originalFieldName || node.responseName;
            if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {
              const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
              const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
              fieldStat.errorsCount += node.error?.length ?? 0;
              fieldStat.observedExecutionCount++;
              fieldStat.estimatedExecutionCount += fieldExecutionWeight;
              fieldStat.requestsWithErrorsCount += (node.error?.length ?? 0) > 0 ? 1 : 0;
              fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
            }
          }
          return false;
        }, "traceNodeStats");
        iterateOverTrace(trace3, traceNodeStats, true);
        for (const { subgraph, path } of nonFtv1ErrorPaths) {
          hasError = true;
          if (path) {
            let currPathErrorStats = this.queryLatencyStats.rootErrorStats.getChild(`service:${subgraph}`, sizeEstimator);
            path.forEach((subPath) => {
              if (typeof subPath === "string") {
                currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
              }
            });
            errorPathStats.add(currPathErrorStats);
            currPathErrorStats.errorsCount += 1;
          }
        }
        for (const errorPath of errorPathStats) {
          errorPath.requestsWithErrorsCount += 1;
        }
        if (hasError) {
          this.queryLatencyStats.requestsWithErrorsCount++;
        }
      }
      getTypeStat(parentType, sizeEstimator) {
        const existing = this.perTypeStat[parentType];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(parentType);
        const typeStat = new OurTypeStat();
        this.perTypeStat[parentType] = typeStat;
        return typeStat;
      }
    };
    OurQueryLatencyStats = class {
      static {
        __name(this, "OurQueryLatencyStats");
      }
      constructor() {
        this.latencyCount = new DurationHistogram();
        this.requestCount = 0;
        this.requestsWithoutFieldInstrumentation = 0;
        this.cacheHits = 0;
        this.persistedQueryHits = 0;
        this.persistedQueryMisses = 0;
        this.cacheLatencyCount = new DurationHistogram();
        this.rootErrorStats = new OurPathErrorStats();
        this.requestsWithErrorsCount = 0;
        this.publicCacheTtlCount = new DurationHistogram();
        this.privateCacheTtlCount = new DurationHistogram();
        this.registeredOperationCount = 0;
        this.forbiddenOperationCount = 0;
      }
    };
    OurPathErrorStats = class _OurPathErrorStats {
      static {
        __name(this, "OurPathErrorStats");
      }
      constructor() {
        this.children = /* @__PURE__ */ Object.create(null);
        this.errorsCount = 0;
        this.requestsWithErrorsCount = 0;
      }
      getChild(subPath, sizeEstimator) {
        const existing = this.children[subPath];
        if (existing) {
          return existing;
        }
        const child = new _OurPathErrorStats();
        this.children[subPath] = child;
        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
        return child;
      }
    };
    OurTypeStat = class {
      static {
        __name(this, "OurTypeStat");
      }
      constructor() {
        this.perFieldStat = /* @__PURE__ */ Object.create(null);
      }
      getFieldStat(fieldName, returnType, sizeEstimator) {
        const existing = this.perFieldStat[fieldName];
        if (existing) {
          return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;
        const fieldStat = new OurFieldStat(returnType);
        this.perFieldStat[fieldName] = fieldStat;
        return fieldStat;
      }
      ensureCountsAreIntegers() {
        for (const fieldStat of Object.values(this.perFieldStat)) {
          fieldStat.ensureCountsAreIntegers();
        }
      }
    };
    OurFieldStat = class {
      static {
        __name(this, "OurFieldStat");
      }
      constructor(returnType) {
        this.returnType = returnType;
        this.errorsCount = 0;
        this.observedExecutionCount = 0;
        this.estimatedExecutionCount = 0;
        this.requestsWithErrorsCount = 0;
        this.latencyCount = new DurationHistogram();
      }
      ensureCountsAreIntegers() {
        this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
      }
    };
    __name(estimatedBytesForString, "estimatedBytesForString");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/traceDetails.js
function makeTraceDetails(variables, sendVariableValues, operationString) {
  const details = new Trace.Details();
  const variablesToRecord = (() => {
    if (sendVariableValues && "transform" in sendVariableValues) {
      const originalKeys = Object.keys(variables);
      try {
        const modifiedVariables = sendVariableValues.transform({
          variables,
          operationString
        });
        return cleanModifiedVariables(originalKeys, modifiedVariables);
      } catch (e) {
        return handleVariableValueTransformError(originalKeys);
      }
    } else {
      return variables;
    }
  })();
  Object.keys(variablesToRecord).forEach((name) => {
    if (!sendVariableValues || "none" in sendVariableValues && sendVariableValues.none || "all" in sendVariableValues && !sendVariableValues.all || "exceptNames" in sendVariableValues && sendVariableValues.exceptNames.includes(name) || "onlyNames" in sendVariableValues && !sendVariableValues.onlyNames.includes(name)) {
      details.variablesJson[name] = "";
    } else {
      try {
        details.variablesJson[name] = typeof variablesToRecord[name] === "undefined" ? "" : JSON.stringify(variablesToRecord[name]);
      } catch (e) {
        details.variablesJson[name] = JSON.stringify("[Unable to convert value to JSON]");
      }
    }
  });
  return details;
}
function handleVariableValueTransformError(variableNames) {
  const modifiedVariables = /* @__PURE__ */ Object.create(null);
  variableNames.forEach((name) => {
    modifiedVariables[name] = "[PREDICATE_FUNCTION_ERROR]";
  });
  return modifiedVariables;
}
function cleanModifiedVariables(originalKeys, modifiedVariables) {
  const cleanedVariables = /* @__PURE__ */ Object.create(null);
  originalKeys.forEach((name) => {
    cleanedVariables[name] = modifiedVariables[name];
  });
  return cleanedVariables;
}
var init_traceDetails = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/traceDetails.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_protobuf();
    __name(makeTraceDetails, "makeTraceDetails");
    __name(handleVariableValueTransformError, "handleVariableValueTransformError");
    __name(cleanModifiedVariables, "cleanModifiedVariables");
  }
});

// ../node_modules/@apollo/server/dist/esm/generated/packageVersion.js
var packageVersion;
var init_packageVersion = __esm({
  "../node_modules/@apollo/server/dist/esm/generated/packageVersion.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    packageVersion = "4.12.1";
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/schemaIsSubgraph.js
function schemaIsSubgraph(schema) {
  const serviceType = schema.getType("_Service");
  if (!(0, import_graphql39.isObjectType)(serviceType)) {
    return false;
  }
  const sdlField = serviceType.getFields().sdl;
  if (!sdlField) {
    return false;
  }
  let sdlFieldType = sdlField.type;
  if ((0, import_graphql39.isNonNullType)(sdlFieldType)) {
    sdlFieldType = sdlFieldType.ofType;
  }
  if (!(0, import_graphql39.isScalarType)(sdlFieldType)) {
    return false;
  }
  return sdlFieldType.name == "String";
}
var import_graphql39;
var init_schemaIsSubgraph = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/schemaIsSubgraph.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_graphql39 = __toESM(require_graphql2(), 1);
    __name(schemaIsSubgraph, "schemaIsSubgraph");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/plugin.js
import { gzip } from "zlib";
function ApolloServerPluginUsageReporting(options = /* @__PURE__ */ Object.create(null)) {
  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
  const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === "number" ? async () => Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async () => true;
  let requestDidStartHandler = null;
  return internalPlugin({
    __internal_plugin_id__: "UsageReporting",
    __is_disabled_plugin__: false,
    async requestDidStart(requestContext) {
      if (requestDidStartHandler) {
        return requestDidStartHandler(requestContext);
      }
      return {};
    },
    async serverWillStart({ logger: serverLogger, apollo, startedInBackground, schema }) {
      const logger = options.logger ?? serverLogger;
      const { key, graphRef } = apollo;
      if (!(key && graphRef)) {
        throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, but you also need to provide your Apollo API key and graph ref, via the APOLLO_KEY/APOLLO_GRAPH_REF environment variables or via `new ApolloServer({apollo: {key, graphRef})`.");
      }
      if (schemaIsSubgraph(schema)) {
        if (options.__onlyIfSchemaIsNotSubgraph) {
          logger.warn("You have specified an Apollo API key and graph ref but this server appears to be a subgraph. Typically usage reports are sent to Apollo by your Router or Gateway, not directly from your subgraph; usage reporting is disabled. To enable usage reporting anyway, explicitly install `ApolloServerPluginUsageReporting`. To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.");
          return {};
        } else {
          logger.warn("You have installed `ApolloServerPluginUsageReporting` but this server appears to be a subgraph. Typically usage reports are sent to Apollo by your Router or Gateway, not directly from your subgraph. If this was unintentional, remove `ApolloServerPluginUsageReporting` from your server's `plugins` array.");
        }
      }
      logger.info(`Apollo usage reporting starting! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
      const sendReportsImmediately = options.sendReportsImmediately ?? startedInBackground;
      let operationDerivedDataCache = null;
      const reportByExecutableSchemaId = /* @__PURE__ */ new Map();
      const getReportWhichMustBeUsedImmediately = /* @__PURE__ */ __name((executableSchemaId) => {
        const existing = reportByExecutableSchemaId.get(executableSchemaId);
        if (existing) {
          return existing;
        }
        const report2 = new OurReport(new ReportHeader({
          ...reportHeaderDefaults,
          executableSchemaId,
          graphRef
        }));
        reportByExecutableSchemaId.set(executableSchemaId, report2);
        return report2;
      }, "getReportWhichMustBeUsedImmediately");
      const getAndDeleteReport = /* @__PURE__ */ __name((executableSchemaId) => {
        const report2 = reportByExecutableSchemaId.get(executableSchemaId);
        if (report2) {
          reportByExecutableSchemaId.delete(executableSchemaId);
          return report2;
        }
        return null;
      }, "getAndDeleteReport");
      const overriddenExecutableSchemaId = options.overrideReportedSchema ? computeCoreSchemaHash(options.overrideReportedSchema) : void 0;
      let lastSeenExecutableSchemaToId;
      let reportTimer;
      if (!sendReportsImmediately) {
        reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1e3);
      }
      let sendTraces = options.sendTraces ?? true;
      const sendOperationAsTrace = options.experimental_sendOperationAsTrace ?? defaultSendOperationsAsTrace();
      let stopped = false;
      function executableSchemaIdForSchema(schema2) {
        if (lastSeenExecutableSchemaToId?.executableSchema === schema2) {
          return lastSeenExecutableSchemaToId.executableSchemaId;
        }
        const id = computeCoreSchemaHash((0, import_graphql40.printSchema)(schema2));
        lastSeenExecutableSchemaToId = {
          executableSchema: schema2,
          executableSchemaId: id
        };
        return id;
      }
      __name(executableSchemaIdForSchema, "executableSchemaIdForSchema");
      async function sendAllReportsAndReportErrors() {
        await Promise.all([...reportByExecutableSchemaId.keys()].map((executableSchemaId) => sendReportAndReportErrors(executableSchemaId)));
      }
      __name(sendAllReportsAndReportErrors, "sendAllReportsAndReportErrors");
      async function sendReportAndReportErrors(executableSchemaId) {
        return sendReport(executableSchemaId).catch((err) => {
          if (options.reportErrorFunction) {
            options.reportErrorFunction(err);
          } else {
            logger.error(err.message);
          }
        });
      }
      __name(sendReportAndReportErrors, "sendReportAndReportErrors");
      const sendReport = /* @__PURE__ */ __name(async (executableSchemaId) => {
        let report2 = getAndDeleteReport(executableSchemaId);
        if (!report2 || Object.keys(report2.tracesPerQuery).length === 0 && report2.operationCount === 0) {
          return;
        }
        report2.endTime = dateToProtoTimestamp(/* @__PURE__ */ new Date());
        report2.ensureCountsAreIntegers();
        const protobufError = Report.verify(report2);
        if (protobufError) {
          throw new Error(`Error verifying report: ${protobufError}`);
        }
        let message = Report.encode(report2).finish();
        report2 = null;
        if (options.debugPrintReports) {
          const decodedReport = Report.decode(message);
          logger.info(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
        }
        const compressed = await new Promise((resolve, reject) => {
          gzip(message, (error3, result) => {
            error3 ? reject(error3) : resolve(result);
          });
        });
        message = null;
        const fetcher = options.fetcher ?? node_fetch_default;
        const response = await (0, import_async_retry.default)(async () => {
          const controller = new import_node_abort_controller.AbortController();
          const abortTimeout = setTimeout(() => {
            controller.abort();
          }, options.requestTimeoutMs ?? 3e4);
          let curResponse;
          try {
            curResponse = await fetcher((options.endpointUrl || "https://usage-reporting.api.apollographql.com") + "/api/ingress/traces", {
              method: "POST",
              headers: {
                "user-agent": "ApolloServerPluginUsageReporting",
                "x-api-key": key,
                "content-encoding": "gzip",
                accept: "application/json"
              },
              body: compressed,
              signal: controller.signal
            });
          } finally {
            clearTimeout(abortTimeout);
          }
          if (curResponse.status >= 500 && curResponse.status < 600) {
            throw new Error(`HTTP status ${curResponse.status}, ${await curResponse.text() || "(no body)"}`);
          } else {
            return curResponse;
          }
        }, {
          retries: (options.maxAttempts || 5) - 1,
          minTimeout: options.minimumRetryDelayMs || 100,
          factor: 2
        }).catch((err) => {
          throw new Error(`Error sending report to Apollo servers: ${err.message}`);
        });
        if (response.status < 200 || response.status >= 300) {
          throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${await response.text() || "(no body)"}`);
        }
        if (sendTraces && response.status === 200 && response.headers.get("content-type")?.match(/^\s*application\/json\s*(?:;|$)/i)) {
          const body = await response.text();
          let parsedBody;
          try {
            parsedBody = JSON.parse(body);
          } catch (e) {
            throw new Error(`Error parsing response from Apollo servers: ${e}`);
          }
          if (parsedBody.tracesIgnored === true) {
            logger.debug("This graph's organization does not have access to traces; sending all subsequent operations as stats.");
            sendTraces = false;
          }
        }
        if (options.debugPrintReports) {
          logger.info(`Apollo usage report: status ${response.status}`);
        }
      }, "sendReport");
      requestDidStartHandler = /* @__PURE__ */ __name(({ metrics, schema: schema2, request: { http, variables } }) => {
        const treeBuilder = new TraceTreeBuilder({
          maskedBy: "ApolloServerPluginUsageReporting",
          sendErrors: options.sendErrors
        });
        treeBuilder.startTiming();
        metrics.startHrTime = treeBuilder.startHrTime;
        let graphqlValidationFailure = false;
        let graphqlUnknownOperationName = false;
        let includeOperationInUsageReporting = null;
        if (http) {
          treeBuilder.trace.http = new Trace.HTTP({
            method: Trace.HTTP.Method[http.method] || Trace.HTTP.Method.UNKNOWN
          });
          if (options.sendHeaders) {
            makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
          }
        }
        async function maybeCallIncludeRequestHook(requestContext) {
          if (includeOperationInUsageReporting !== null)
            return;
          if (typeof options.includeRequest !== "function") {
            includeOperationInUsageReporting = true;
            return;
          }
          includeOperationInUsageReporting = await options.includeRequest(requestContext);
          if (typeof includeOperationInUsageReporting !== "boolean") {
            logger.warn("The 'includeRequest' async predicate function must return a boolean value.");
            includeOperationInUsageReporting = true;
          }
        }
        __name(maybeCallIncludeRequestHook, "maybeCallIncludeRequestHook");
        let didResolveSource = false;
        return {
          async didResolveSource(requestContext) {
            didResolveSource = true;
            if (metrics.persistedQueryHit) {
              treeBuilder.trace.persistedQueryHit = true;
            }
            if (metrics.persistedQueryRegister) {
              treeBuilder.trace.persistedQueryRegister = true;
            }
            if (variables) {
              treeBuilder.trace.details = makeTraceDetails(variables, options.sendVariableValues, requestContext.source);
            }
            const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
            if (clientInfo) {
              const { clientName, clientVersion } = clientInfo;
              treeBuilder.trace.clientVersion = clientVersion || "";
              treeBuilder.trace.clientName = clientName || "";
            }
          },
          async validationDidStart() {
            return async (validationErrors) => {
              graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;
            };
          },
          async didResolveOperation(requestContext) {
            graphqlUnknownOperationName = requestContext.operation === void 0;
            await maybeCallIncludeRequestHook(requestContext);
            if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {
              if (metrics.captureTraces === void 0) {
                const rawWeight = await fieldLevelInstrumentation(requestContext);
                treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === "number" ? rawWeight : rawWeight ? 1 : 0;
                metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;
              }
            }
          },
          async executionDidStart() {
            if (!metrics.captureTraces)
              return;
            return {
              willResolveField({ info: info3 }) {
                return treeBuilder.willResolveField(info3);
              }
            };
          },
          async didEncounterSubsequentErrors(_requestContext, errors) {
            treeBuilder.didEncounterErrors(errors);
          },
          async willSendSubsequentPayload(requestContext, payload) {
            if (!payload.hasNext) {
              await operationFinished(requestContext);
            }
          },
          async willSendResponse(requestContext) {
            if (!didResolveSource)
              return;
            if (requestContext.errors) {
              treeBuilder.didEncounterErrors(requestContext.errors);
            }
            if (requestContext.response.body.kind === "single") {
              await operationFinished(requestContext);
            }
          }
        };
        async function operationFinished(requestContext) {
          const resolvedOperation = !!requestContext.operation;
          await maybeCallIncludeRequestHook(requestContext);
          treeBuilder.stopTiming();
          const executableSchemaId = overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema2);
          if (includeOperationInUsageReporting === false) {
            if (resolvedOperation) {
              getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;
            }
            return;
          }
          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
          const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
          if (policyIfCacheable) {
            treeBuilder.trace.cachePolicy = new Trace.CachePolicy({
              scope: policyIfCacheable.scope === "PRIVATE" ? Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === "PUBLIC" ? Trace.CachePolicy.Scope.PUBLIC : Trace.CachePolicy.Scope.UNKNOWN,
              maxAgeNs: policyIfCacheable.maxAge * 1e9
            });
          }
          if (metrics.queryPlanTrace) {
            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
          }
          addTrace().catch(logger.error);
          async function addTrace() {
            if (stopped) {
              return;
            }
            await new Promise((res) => setImmediate(res));
            const executableSchemaId2 = overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema2);
            const { trace: trace3 } = treeBuilder;
            let statsReportKey = void 0;
            let referencedFieldsByType;
            if (!requestContext.document) {
              statsReportKey = `## GraphQLParseFailure
`;
            } else if (graphqlValidationFailure) {
              statsReportKey = `## GraphQLValidationFailure
`;
            } else if (graphqlUnknownOperationName) {
              statsReportKey = `## GraphQLUnknownOperationName
`;
            }
            const isExecutable = statsReportKey === void 0;
            if (statsReportKey) {
              if (options.sendUnexecutableOperationDocuments) {
                trace3.unexecutedOperationBody = requestContext.source;
                trace3.unexecutedOperationName = requestContext.request.operationName || "";
              }
              referencedFieldsByType = /* @__PURE__ */ Object.create(null);
            } else {
              const operationDerivedData = getOperationDerivedData();
              statsReportKey = `# ${requestContext.operationName || "-"}
${operationDerivedData.signature}`;
              referencedFieldsByType = operationDerivedData.referencedFieldsByType;
            }
            const protobufError = Trace.verify(trace3);
            if (protobufError) {
              throw new Error(`Error encoding trace: ${protobufError}`);
            }
            if (resolvedOperation) {
              getReportWhichMustBeUsedImmediately(executableSchemaId2).operationCount++;
            }
            getReportWhichMustBeUsedImmediately(executableSchemaId2).addTrace({
              statsReportKey,
              trace: trace3,
              asTrace: sendTraces && (!isExecutable || !!metrics.captureTraces) && !metrics.nonFtv1ErrorPaths?.length && sendOperationAsTrace(trace3, statsReportKey),
              referencedFieldsByType,
              nonFtv1ErrorPaths: metrics.nonFtv1ErrorPaths ?? []
            });
            if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId2).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
              await sendReportAndReportErrors(executableSchemaId2);
            }
          }
          __name(addTrace, "addTrace");
          function getOperationDerivedData() {
            if (!requestContext.document) {
              throw new Error("No document?");
            }
            const cacheKey = operationDerivedDataCacheKey(requestContext.queryHash, requestContext.operationName || "");
            if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema2) {
              operationDerivedDataCache = {
                forSchema: schema2,
                cache: createOperationDerivedDataCache({ logger })
              };
            }
            const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
            if (cachedOperationDerivedData) {
              return cachedOperationDerivedData;
            }
            const generatedSignature = (options.calculateSignature || import_utils25.usageReportingSignature)(requestContext.document, requestContext.operationName || "");
            const generatedOperationDerivedData = {
              signature: generatedSignature,
              referencedFieldsByType: (0, import_utils25.calculateReferencedFieldsByType)({
                document: requestContext.document,
                schema: schema2,
                resolvedOperationName: requestContext.operationName ?? null
              })
            };
            operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
            return generatedOperationDerivedData;
          }
          __name(getOperationDerivedData, "getOperationDerivedData");
        }
        __name(operationFinished, "operationFinished");
      }, "requestDidStartHandler");
      return {
        async serverWillStop() {
          if (reportTimer) {
            clearInterval(reportTimer);
            reportTimer = void 0;
          }
          stopped = true;
          await sendAllReportsAndReportErrors();
        }
      };
    }
  });
}
function makeHTTPRequestHeaders(http, headers, sendHeaders) {
  if (!sendHeaders || "none" in sendHeaders && sendHeaders.none || "all" in sendHeaders && !sendHeaders.all) {
    return;
  }
  for (const [key, value] of headers) {
    if ("exceptNames" in sendHeaders && sendHeaders.exceptNames.some((exceptHeader) => {
      return exceptHeader.toLowerCase() === key;
    }) || "onlyNames" in sendHeaders && !sendHeaders.onlyNames.some((header) => {
      return header.toLowerCase() === key;
    })) {
      continue;
    }
    switch (key) {
      case "authorization":
      case "cookie":
      case "set-cookie":
        break;
      default:
        http.requestHeaders[key] = new Trace.HTTP.Values({
          value: [value]
        });
    }
  }
}
function defaultGenerateClientInfo({ request }) {
  const clientNameHeaderKey = "apollographql-client-name";
  const clientVersionHeaderKey = "apollographql-client-version";
  if (request.http?.headers?.get(clientNameHeaderKey) || request.http?.headers?.get(clientVersionHeaderKey)) {
    return {
      clientName: request.http?.headers?.get(clientNameHeaderKey),
      clientVersion: request.http?.headers?.get(clientVersionHeaderKey)
    };
  } else if (request.extensions?.clientInfo) {
    return request.extensions.clientInfo;
  } else {
    return {};
  }
}
var import_utils25, import_async_retry, import_graphql40, import_node_abort_controller, reportHeaderDefaults;
var init_plugin = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/plugin.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_protobuf();
    import_utils25 = __toESM(require_dist9(), 1);
    import_async_retry = __toESM(require_lib(), 1);
    import_graphql40 = __toESM(require_graphql2(), 1);
    import_node_abort_controller = __toESM(require_browser(), 1);
    init_node_fetch();
    init_os();
    init_internalPlugin();
    init_traceTreeBuilder();
    init_defaultSendOperationsAsTrace();
    init_operationDerivedDataCache();
    init_stats();
    init_traceDetails();
    init_packageVersion();
    init_computeCoreSchemaHash();
    init_schemaIsSubgraph();
    reportHeaderDefaults = {
      hostname: os_default.hostname(),
      agentVersion: `@apollo/server@${packageVersion}`,
      runtimeVersion: `node ${process.version}`,
      uname: `${os_default.platform()}, ${os_default.type()}, ${os_default.release()}, ${os_default.arch()})`
    };
    __name(ApolloServerPluginUsageReporting, "ApolloServerPluginUsageReporting");
    __name(makeHTTPRequestHeaders, "makeHTTPRequestHeaders");
    __name(defaultGenerateClientInfo, "defaultGenerateClientInfo");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/usageReporting/index.js
var usageReporting_exports = {};
__export(usageReporting_exports, {
  ApolloServerPluginUsageReporting: () => ApolloServerPluginUsageReporting
});
var init_usageReporting = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/usageReporting/index.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_plugin();
  }
});

// ../node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues2) {
    getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues2(rnds8);
}
var getRandomValues2, rnds8;
var init_rng = __esm({
  "../node_modules/uuid/dist/esm-browser/rng.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    rnds8 = new Uint8Array(16);
    __name(rng, "rng");
  }
});

// ../node_modules/uuid/dist/esm-browser/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
var byteToHex;
var init_stringify = __esm({
  "../node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    __name(unsafeStringify, "unsafeStringify");
  }
});

// ../node_modules/uuid/dist/esm-browser/native.js
var randomUUID2, native_default;
var init_native = __esm({
  "../node_modules/uuid/dist/esm-browser/native.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    native_default = {
      randomUUID: randomUUID2
    };
  }
});

// ../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../node_modules/uuid/dist/esm-browser/v4.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_native();
    init_rng();
    init_stringify();
    __name(v4, "v4");
    v4_default = v4;
  }
});

// ../node_modules/uuid/dist/esm-browser/index.js
var init_esm_browser = __esm({
  "../node_modules/uuid/dist/esm-browser/index.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_v4();
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/schemaReporting/schemaReporter.js
var schemaReportGql, SchemaReporter;
var init_schemaReporter = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/schemaReporting/schemaReporter.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_node_fetch();
    init_packageVersion();
    schemaReportGql = `#graphql
  mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
    reportSchema(report: $report, coreSchema: $coreSchema) {
      __typename
      ... on ReportSchemaError {
        message
        code
      }
      ... on ReportSchemaResponse {
        inSeconds
        withCoreSchema
      }
    }
  }
`;
    SchemaReporter = class {
      static {
        __name(this, "SchemaReporter");
      }
      constructor(options) {
        this.headers = {
          "Content-Type": "application/json",
          "x-api-key": options.apiKey,
          "apollographql-client-name": "ApolloServerPluginSchemaReporting",
          "apollographql-client-version": packageVersion
        };
        this.endpointUrl = options.endpointUrl || "https://schema-reporting.api.apollographql.com/api/graphql";
        this.schemaReport = options.schemaReport;
        this.coreSchema = options.coreSchema;
        this.isStopped = false;
        this.logger = options.logger;
        this.initialReportingDelayInMs = options.initialReportingDelayInMs;
        this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
        this.fetcher = options.fetcher ?? node_fetch_default;
      }
      stopped() {
        return this.isStopped;
      }
      start() {
        this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
      }
      stop() {
        this.isStopped = true;
        if (this.pollTimer) {
          clearTimeout(this.pollTimer);
          this.pollTimer = void 0;
        }
      }
      async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
        this.pollTimer = void 0;
        if (this.stopped())
          return;
        try {
          const result = await this.reportSchema(sendNextWithCoreSchema);
          if (!result) {
            return;
          }
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1e3);
          }
          return;
        } catch (error3) {
          this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error3}`);
          if (!this.stopped()) {
            this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
          }
        }
      }
      async reportSchema(withCoreSchema) {
        const { data, errors } = await this.apolloQuery({
          report: this.schemaReport,
          coreSchema: withCoreSchema ? this.coreSchema : null
        });
        if (errors) {
          throw new Error(errors.map((x) => x.message).join("\n"));
        }
        function msgForUnexpectedResponse(data2) {
          return [
            "Unexpected response shape from Apollo when",
            "reporting schema. If this continues, please reach",
            "out to support@apollographql.com.",
            "Received response:",
            JSON.stringify(data2)
          ].join(" ");
        }
        __name(msgForUnexpectedResponse, "msgForUnexpectedResponse");
        if (!data || !data.reportSchema) {
          throw new Error(msgForUnexpectedResponse(data));
        }
        if (data.reportSchema.__typename === "ReportSchemaResponse") {
          return data.reportSchema;
        } else if (data.reportSchema.__typename === "ReportSchemaError") {
          this.logger.error([
            "Received input validation error from Apollo:",
            data.reportSchema.message,
            "Stopping reporting. Please fix the input errors."
          ].join(" "));
          this.stop();
          return null;
        }
        throw new Error(msgForUnexpectedResponse(data));
      }
      async apolloQuery(variables) {
        const request = {
          query: schemaReportGql,
          variables
        };
        const httpResponse = await this.fetcher(this.endpointUrl, {
          method: "POST",
          headers: this.headers,
          body: JSON.stringify(request)
        });
        if (!httpResponse.ok) {
          throw new Error([
            `An unexpected HTTP status code (${httpResponse.status}) was`,
            "encountered during schema reporting."
          ].join(" "));
        }
        try {
          return await httpResponse.json();
        } catch (error3) {
          throw new Error([
            "Couldn't report schema to Apollo.",
            "Parsing response as JSON failed.",
            "If this continues please reach out to support@apollographql.com",
            error3
          ].join(" "));
        }
      }
    };
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/schemaReporting/index.js
var schemaReporting_exports = {};
__export(schemaReporting_exports, {
  ApolloServerPluginSchemaReporting: () => ApolloServerPluginSchemaReporting
});
function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher } = /* @__PURE__ */ Object.create(null)) {
  const bootId = v4_default();
  return internalPlugin({
    __internal_plugin_id__: "SchemaReporting",
    __is_disabled_plugin__: false,
    async serverWillStart({ apollo, schema, logger }) {
      const { key, graphRef } = apollo;
      if (!key) {
        throw Error("To use ApolloServerPluginSchemaReporting, you must provide an Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`");
      }
      if (!graphRef) {
        throw Error("To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, 'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment variable or passing `new ApolloServer({apollo: {graphRef}})`.");
      }
      if (overrideReportedSchema) {
        try {
          const validationErrors = (0, import_graphql41.validateSchema)((0, import_graphql41.buildSchema)(overrideReportedSchema, { noLocation: true }));
          if (validationErrors.length) {
            throw new Error(validationErrors.map((error3) => error3.message).join("\n"));
          }
        } catch (err) {
          throw new Error(`The schema provided to overrideReportedSchema failed to parse or validate: ${err.message}`);
        }
      }
      if (schemaIsSubgraph(schema)) {
        throw Error([
          "Schema reporting is not yet compatible with Apollo Federation subgraphs.",
          "If you're interested in using schema reporting with subgraphs,",
          "please contact Apollo support. To set up managed federation, see",
          "https://go.apollo.dev/s/managed-federation"
        ].join(" "));
      }
      if (endpointUrl !== void 0) {
        logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
      }
      const baseSchemaReport = {
        bootId,
        graphRef,
        platform: process.env.APOLLO_SERVER_PLATFORM || "local",
        runtimeVersion: `node ${process.version}`,
        userVersion: process.env.APOLLO_SERVER_USER_VERSION,
        serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os_default.hostname(),
        libraryVersion: `@apollo/server@${packageVersion}`
      };
      let currentSchemaReporter;
      return {
        schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }) {
          if (overrideReportedSchema !== void 0) {
            if (currentSchemaReporter) {
              return;
            } else {
              logger.info("Apollo schema reporting: schema to report has been overridden");
            }
          }
          const coreSchema = overrideReportedSchema ?? coreSupergraphSdl ?? (0, import_graphql41.printSchema)(apiSchema);
          const coreSchemaHash = computeCoreSchemaHash(coreSchema);
          const schemaReport = {
            ...baseSchemaReport,
            coreSchemaHash
          };
          currentSchemaReporter?.stop();
          currentSchemaReporter = new SchemaReporter({
            schemaReport,
            coreSchema,
            apiKey: key,
            endpointUrl,
            logger,
            initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs ?? 1e4)),
            fallbackReportingDelayInMs: 2e4,
            fetcher
          });
          currentSchemaReporter.start();
          logger.info(`Apollo schema reporting: reporting a new schema to Studio! See your graph at https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
        },
        async serverWillStop() {
          currentSchemaReporter?.stop();
        }
      };
    }
  });
}
var import_graphql41;
var init_schemaReporting = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/schemaReporting/index.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_os();
    init_internalPlugin();
    init_esm_browser();
    import_graphql41 = __toESM(require_graphql2(), 1);
    init_schemaReporter();
    init_schemaIsSubgraph();
    init_packageVersion();
    init_computeCoreSchemaHash();
    __name(ApolloServerPluginSchemaReporting, "ApolloServerPluginSchemaReporting");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/inlineTrace/index.js
var inlineTrace_exports = {};
__export(inlineTrace_exports, {
  ApolloServerPluginInlineTrace: () => ApolloServerPluginInlineTrace
});
function ApolloServerPluginInlineTrace(options = /* @__PURE__ */ Object.create(null)) {
  let enabled = options.__onlyIfSchemaIsSubgraph ? null : true;
  return internalPlugin({
    __internal_plugin_id__: "InlineTrace",
    __is_disabled_plugin__: false,
    async serverWillStart({ schema, logger }) {
      if (enabled === null) {
        enabled = schemaIsSubgraph(schema);
        if (enabled) {
          logger.info("Enabling inline tracing for this subgraph. To disable, use ApolloServerPluginInlineTraceDisabled.");
        }
      }
    },
    async requestDidStart({ request: { http }, metrics }) {
      if (!enabled) {
        return;
      }
      const treeBuilder = new TraceTreeBuilder({
        maskedBy: "ApolloServerPluginInlineTrace",
        sendErrors: options.includeErrors
      });
      if (http?.headers.get("apollo-federation-include-trace") !== "ftv1") {
        return;
      }
      if (metrics.captureTraces === false) {
        return;
      }
      metrics.captureTraces = true;
      treeBuilder.startTiming();
      return {
        async executionDidStart() {
          return {
            willResolveField({ info: info3 }) {
              return treeBuilder.willResolveField(info3);
            }
          };
        },
        async didEncounterErrors({ errors }) {
          treeBuilder.didEncounterErrors(errors);
        },
        async willSendResponse({ response }) {
          treeBuilder.stopTiming();
          if (response.body.kind === "incremental") {
            return;
          }
          if (metrics.queryPlanTrace) {
            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
          }
          const encodedUint8Array = Trace.encode(treeBuilder.trace).finish();
          const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
          const extensions = response.body.singleResult.extensions || (response.body.singleResult.extensions = /* @__PURE__ */ Object.create(null));
          if (typeof extensions.ftv1 !== "undefined") {
            throw new Error("The `ftv1` extension was already present.");
          }
          extensions.ftv1 = encodedBuffer.toString("base64");
        }
      };
    }
  });
}
var init_inlineTrace = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/inlineTrace/index.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_protobuf();
    init_traceTreeBuilder();
    init_internalPlugin();
    init_schemaIsSubgraph();
    __name(ApolloServerPluginInlineTrace, "ApolloServerPluginInlineTrace");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/landingPage/default/getEmbeddedHTML.js
function getConfigStringForHtml(config2) {
  return JSON.stringify(config2).replace("<", "\\u003c").replace(">", "\\u003e").replace("&", "\\u0026").replace("'", "\\u0027");
}
var getEmbeddedExplorerHTML, getEmbeddedSandboxHTML;
var init_getEmbeddedHTML = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/landingPage/default/getEmbeddedHTML.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(getConfigStringForHtml, "getConfigStringForHtml");
    getEmbeddedExplorerHTML = /* @__PURE__ */ __name((explorerCdnVersion, config2, apolloServerVersion, nonce) => {
      const productionLandingPageEmbedConfigOrDefault = {
        displayOptions: {},
        persistExplorerState: false,
        runTelemetry: true,
        ...typeof config2.embed === "boolean" ? {} : config2.embed
      };
      const embeddedExplorerParams = {
        graphRef: config2.graphRef,
        target: "#embeddableExplorer",
        initialState: {
          ..."document" in config2 || "headers" in config2 || "variables" in config2 ? {
            document: config2.document,
            headers: config2.headers,
            variables: config2.variables
          } : {},
          ..."collectionId" in config2 ? {
            collectionId: config2.collectionId,
            operationId: config2.operationId
          } : {},
          displayOptions: {
            ...productionLandingPageEmbedConfigOrDefault.displayOptions
          }
        },
        persistExplorerState: productionLandingPageEmbedConfigOrDefault.persistExplorerState,
        includeCookies: config2.includeCookies,
        runtime: apolloServerVersion,
        runTelemetry: productionLandingPageEmbedConfigOrDefault.runTelemetry,
        allowDynamicStyles: false
      };
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style nonce=${nonce}>
  iframe {
    background-color: white;
    height: 100%;
    width: 100%;
    border: none;
  }
  #embeddableExplorer {
    width: 100vw;
    height: 100vh;
    position: absolute;
    top: 0;
  }
</style>
<div id="embeddableExplorer"></div>
<script nonce="${nonce}" src="https://embeddable-explorer.cdn.apollographql.com/${encodeURIComponent(explorerCdnVersion)}/embeddable-explorer.umd.production.min.js?runtime=${encodeURIComponent(apolloServerVersion)}"><\/script>
<script nonce="${nonce}">
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
<\/script>
`;
    }, "getEmbeddedExplorerHTML");
    getEmbeddedSandboxHTML = /* @__PURE__ */ __name((sandboxCdnVersion, config2, apolloServerVersion, nonce) => {
      const localDevelopmentEmbedConfigOrDefault = {
        runTelemetry: true,
        endpointIsEditable: false,
        initialState: {},
        ...typeof config2.embed === "boolean" ? {} : config2.embed ?? {}
      };
      const embeddedSandboxConfig = {
        target: "#embeddableSandbox",
        initialState: {
          ..."document" in config2 || "headers" in config2 || "variables" in config2 ? {
            document: config2.document,
            variables: config2.variables,
            headers: config2.headers
          } : {},
          ..."collectionId" in config2 ? {
            collectionId: config2.collectionId,
            operationId: config2.operationId
          } : {},
          includeCookies: config2.includeCookies,
          ...localDevelopmentEmbedConfigOrDefault.initialState
        },
        hideCookieToggle: false,
        endpointIsEditable: localDevelopmentEmbedConfigOrDefault.endpointIsEditable,
        runtime: apolloServerVersion,
        runTelemetry: localDevelopmentEmbedConfigOrDefault.runTelemetry,
        allowDynamicStyles: false
      };
      return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style nonce=${nonce}>
  iframe {
    background-color: white;
    height: 100%;
    width: 100%;
    border: none;
  }
  #embeddableSandbox {
    width: 100vw;
    height: 100vh;
    position: absolute;
    top: 0;
  }
</style>
<div id="embeddableSandbox"></div>
<script nonce="${nonce}" src="https://embeddable-sandbox.cdn.apollographql.com/${encodeURIComponent(sandboxCdnVersion)}/embeddable-sandbox.umd.production.min.js?runtime=${encodeURIComponent(apolloServerVersion)}"><\/script>
<script nonce="${nonce}">
  var initialEndpoint = window.location.href;
  var embeddedSandboxConfig = ${getConfigStringForHtml(embeddedSandboxConfig)};
  new window.EmbeddedSandbox(
    {
      ...embeddedSandboxConfig,
      initialEndpoint,
    }
  );
<\/script>
`;
    }, "getEmbeddedSandboxHTML");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/landingPage/default/index.js
var default_exports = {};
__export(default_exports, {
  ApolloServerPluginLandingPageLocalDefault: () => ApolloServerPluginLandingPageLocalDefault,
  ApolloServerPluginLandingPageProductionDefault: () => ApolloServerPluginLandingPageProductionDefault,
  DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION: () => DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION,
  DEFAULT_EMBEDDED_EXPLORER_VERSION: () => DEFAULT_EMBEDDED_EXPLORER_VERSION,
  DEFAULT_EMBEDDED_SANDBOX_VERSION: () => DEFAULT_EMBEDDED_SANDBOX_VERSION
});
function ApolloServerPluginLandingPageLocalDefault(options = {}) {
  const { version: version3, __internal_apolloStudioEnv__, ...rest } = {
    embed: true,
    ...options
  };
  return ApolloServerPluginLandingPageDefault(version3, {
    isProd: false,
    apolloStudioEnv: __internal_apolloStudioEnv__,
    ...rest
  });
}
function ApolloServerPluginLandingPageProductionDefault(options = {}) {
  const { version: version3, __internal_apolloStudioEnv__, ...rest } = options;
  return ApolloServerPluginLandingPageDefault(version3, {
    isProd: true,
    apolloStudioEnv: __internal_apolloStudioEnv__,
    ...rest
  });
}
function encodeConfig(config2) {
  return JSON.stringify(encodeURIComponent(JSON.stringify(config2)));
}
function ApolloServerPluginLandingPageDefault(maybeVersion, config2) {
  const explorerVersion = maybeVersion ?? DEFAULT_EMBEDDED_EXPLORER_VERSION;
  const sandboxVersion = maybeVersion ?? DEFAULT_EMBEDDED_SANDBOX_VERSION;
  const apolloServerLandingPageVersion = maybeVersion ?? DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION;
  const apolloServerVersion = `@apollo/server@${packageVersion}`;
  const scriptSafeList = [
    "https://apollo-server-landing-page.cdn.apollographql.com",
    "https://embeddable-sandbox.cdn.apollographql.com",
    "https://embeddable-explorer.cdn.apollographql.com"
  ].join(" ");
  const styleSafeList = [
    "https://apollo-server-landing-page.cdn.apollographql.com",
    "https://embeddable-sandbox.cdn.apollographql.com",
    "https://embeddable-explorer.cdn.apollographql.com",
    "https://fonts.googleapis.com"
  ].join(" ");
  const iframeSafeList = [
    "https://explorer.embed.apollographql.com",
    "https://sandbox.embed.apollographql.com",
    "https://embed.apollo.local:3000"
  ].join(" ");
  return {
    __internal_installed_implicitly__: false,
    async serverWillStart(server) {
      if (config2.precomputedNonce) {
        server.logger.warn("The `precomputedNonce` landing page configuration option is deprecated. Removing this option is strictly an improvement to Apollo Server's landing page Content Security Policy (CSP) implementation for preventing XSS attacks.");
      }
      return {
        async renderLandingPage() {
          const encodedASLandingPageVersion = encodeURIComponent(apolloServerLandingPageVersion);
          async function html() {
            const nonce = config2.precomputedNonce ?? (0, import_utils26.createHash)("sha256").update(v4_default()).digest("hex");
            const scriptCsp = `script-src 'self' 'nonce-${nonce}' ${scriptSafeList}`;
            const styleCsp = `style-src 'nonce-${nonce}' ${styleSafeList}`;
            const imageCsp = `img-src https://apollo-server-landing-page.cdn.apollographql.com`;
            const manifestCsp = `manifest-src https://apollo-server-landing-page.cdn.apollographql.com`;
            const frameCsp = `frame-src ${iframeSafeList}`;
            return `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy" content="${scriptCsp}; ${styleCsp}; ${imageCsp}; ${manifestCsp}; ${frameCsp}" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${encodedASLandingPageVersion}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style nonce=${nonce}>
        body {
          margin: 0;
          overflow-x: hidden;
          overflow-y: hidden;
        }
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config2.embed ? "graphRef" in config2 && config2.graphRef ? getEmbeddedExplorerHTML(explorerVersion, config2, apolloServerVersion, nonce) : !("graphRef" in config2) ? getEmbeddedSandboxHTML(sandboxVersion, config2, apolloServerVersion, nonce) : getNonEmbeddedLandingPageHTML(apolloServerLandingPageVersion, config2, apolloServerVersion, nonce) : getNonEmbeddedLandingPageHTML(apolloServerLandingPageVersion, config2, apolloServerVersion, nonce)}
    </div>
  </body>
</html>
          `;
          }
          __name(html, "html");
          return { html };
        }
      };
    }
  };
}
var import_utils26, getNonEmbeddedLandingPageHTML, DEFAULT_EMBEDDED_EXPLORER_VERSION, DEFAULT_EMBEDDED_SANDBOX_VERSION, DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION;
var init_default = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/landingPage/default/index.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_getEmbeddedHTML();
    init_packageVersion();
    import_utils26 = __toESM(require_dist3(), 1);
    init_esm_browser();
    __name(ApolloServerPluginLandingPageLocalDefault, "ApolloServerPluginLandingPageLocalDefault");
    __name(ApolloServerPluginLandingPageProductionDefault, "ApolloServerPluginLandingPageProductionDefault");
    __name(encodeConfig, "encodeConfig");
    getNonEmbeddedLandingPageHTML = /* @__PURE__ */ __name((cdnVersion, config2, apolloServerVersion, nonce) => {
      const encodedConfig = encodeConfig(config2);
      return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script nonce="${nonce}">window.landingPage = ${encodedConfig};<\/script>
<script nonce="${nonce}" src="https://apollo-server-landing-page.cdn.apollographql.com/${encodeURIComponent(cdnVersion)}/static/js/main.js?runtime=${apolloServerVersion}"><\/script>`;
    }, "getNonEmbeddedLandingPageHTML");
    DEFAULT_EMBEDDED_EXPLORER_VERSION = "v3";
    DEFAULT_EMBEDDED_SANDBOX_VERSION = "v2";
    DEFAULT_APOLLO_SERVER_LANDING_PAGE_VERSION = "_latest";
    __name(ApolloServerPluginLandingPageDefault, "ApolloServerPluginLandingPageDefault");
  }
});

// ../node_modules/@apollo/server/dist/esm/plugin/disableSuggestions/index.js
var disableSuggestions_exports = {};
__export(disableSuggestions_exports, {
  ApolloServerPluginDisableSuggestions: () => ApolloServerPluginDisableSuggestions
});
function ApolloServerPluginDisableSuggestions() {
  return internalPlugin({
    __internal_plugin_id__: "DisableSuggestions",
    __is_disabled_plugin__: false,
    async requestDidStart() {
      return {
        async validationDidStart() {
          return async (validationErrors) => {
            validationErrors?.forEach((error3) => {
              error3.message = error3.message.replace(/ ?Did you mean(.+?)\?$/, "");
            });
          };
        }
      };
    }
  });
}
var init_disableSuggestions = __esm({
  "../node_modules/@apollo/server/dist/esm/plugin/disableSuggestions/index.js"() {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_internalPlugin();
    __name(ApolloServerPluginDisableSuggestions, "ApolloServerPluginDisableSuggestions");
  }
});

// node-built-in-modules:stream
import libDefault2 from "stream";
var require_stream = __commonJS({
  "node-built-in-modules:stream"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = libDefault2;
  }
});

// node-built-in-modules:util
var require_util = __commonJS({
  "node-built-in-modules:util"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util2();
    module2.exports = util_default;
  }
});

// ../node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "../node_modules/jws/lib/data-stream.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require_stream();
    var util = require_util();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    __name(DataStream, "DataStream");
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = /* @__PURE__ */ __name(function write(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    }, "write");
    DataStream.prototype.end = /* @__PURE__ */ __name(function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    }, "end");
    module2.exports = DataStream;
  }
});

// ../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    __name(getParamSize, "getParamSize");
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    __name(getParamBytesForAlg, "getParamBytesForAlg");
    module2.exports = getParamBytesForAlg;
  }
});

// ../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "../node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64Url, "base64Url");
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    __name(signatureAsBuffer, "signatureAsBuffer");
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    __name(derToJose, "derToJose");
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    __name(countPadding, "countPadding");
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    __name(joseToDer, "joseToDer");
    module2.exports = {
      derToJose,
      joseToDer
    };
  }
});

// ../node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "../node_modules/buffer-equal-constant-time/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_buffer().Buffer;
    var SlowBuffer = require_buffer().SlowBuffer;
    module2.exports = bufferEq;
    function bufferEq(a, b) {
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a.length; i++) {
        c |= a[i] ^ b[i];
      }
      return c === 0;
    }
    __name(bufferEq, "bufferEq");
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = /* @__PURE__ */ __name(function equal(that) {
        return bufferEq(this, that);
      }, "equal");
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// ../node_modules/jwa/index.js
var require_jwa = __commonJS({
  "../node_modules/jwa/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto2 = require_crypto();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    __name(checkIsPublicKey, "checkIsPublicKey");
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    __name(checkIsPrivateKey, "checkIsPrivateKey");
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    __name(checkIsSecretKey, "checkIsSecretKey");
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(fromBase64, "fromBase64");
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    __name(toBase64, "toBase64");
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    __name(typeError, "typeError");
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    __name(bufferOrString, "bufferOrString");
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    __name(normalizeInput, "normalizeInput");
    function createHmacSigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto2.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createHmacSigner, "createHmacSigner");
    var bufferEqual;
    var timingSafeEqual2 = "timingSafeEqual" in crypto2 ? /* @__PURE__ */ __name(function timingSafeEqual3(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return crypto2.timingSafeEqual(a, b);
    }, "timingSafeEqual") : /* @__PURE__ */ __name(function timingSafeEqual3(a, b) {
      if (!bufferEqual) {
        bufferEqual = require_buffer_equal_constant_time();
      }
      return bufferEqual(a, b);
    }, "timingSafeEqual");
    function createHmacVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return timingSafeEqual2(Buffer2.from(signature), Buffer2.from(computedSig));
      }, "verify");
    }
    __name(createHmacVerifier, "createHmacVerifier");
    function createKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createKeySigner, "createKeySigner");
    function createKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      }, "verify");
    }
    __name(createKeyVerifier, "createKeyVerifier");
    function createPSSKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createPSSKeySigner, "createPSSKeySigner");
    function createPSSKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      }, "verify");
    }
    __name(createPSSKeyVerifier, "createPSSKeyVerifier");
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return /* @__PURE__ */ __name(function sign3() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      }, "sign");
    }
    __name(createECDSASigner, "createECDSASigner");
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      }, "verify");
    }
    __name(createECDSAVerifer, "createECDSAVerifer");
    function createNoneSigner() {
      return /* @__PURE__ */ __name(function sign3() {
        return "";
      }, "sign");
    }
    __name(createNoneSigner, "createNoneSigner");
    function createNoneVerifier() {
      return /* @__PURE__ */ __name(function verify3(thing, signature) {
        return signature === "";
      }, "verify");
    }
    __name(createNoneVerifier, "createNoneVerifier");
    module2.exports = /* @__PURE__ */ __name(function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    }, "jwa");
  }
});

// ../node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "../node_modules/jws/lib/tostring.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_buffer().Buffer;
    module2.exports = /* @__PURE__ */ __name(function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    }, "toString");
  }
});

// ../node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "../node_modules/jws/lib/sign-stream.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64url, "base64url");
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    __name(jwsSecuredInput, "jwsSecuredInput");
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    __name(jwsSign, "jwsSign");
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    __name(SignStream, "SignStream");
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = /* @__PURE__ */ __name(function sign3() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "sign");
    SignStream.sign = jwsSign;
    module2.exports = SignStream;
  }
});

// ../node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "../node_modules/jws/lib/verify-stream.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject3(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    __name(isObject3, "isObject");
    function safeJsonParse(thing) {
      if (isObject3(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    __name(safeJsonParse, "safeJsonParse");
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    __name(headerFromJWS, "headerFromJWS");
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    __name(securedInputFromJWS, "securedInputFromJWS");
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    __name(signatureFromJWS, "signatureFromJWS");
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    __name(payloadFromJWS, "payloadFromJWS");
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    __name(isValidJws, "isValidJws");
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    __name(jwsVerify, "jwsVerify");
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    __name(jwsDecode, "jwsDecode");
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    __name(VerifyStream, "VerifyStream");
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = /* @__PURE__ */ __name(function verify3() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "verify");
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module2.exports = VerifyStream;
  }
});

// ../node_modules/jws/index.js
var require_jws = __commonJS({
  "../node_modules/jws/index.js"(exports2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports2.ALGORITHMS = ALGORITHMS;
    exports2.sign = SignStream.sign;
    exports2.verify = VerifyStream.verify;
    exports2.decode = VerifyStream.decode;
    exports2.isValid = VerifyStream.isValid;
    exports2.createSign = /* @__PURE__ */ __name(function createSign2(opts) {
      return new SignStream(opts);
    }, "createSign");
    exports2.createVerify = /* @__PURE__ */ __name(function createVerify2(opts) {
      return new VerifyStream(opts);
    }, "createVerify");
  }
});

// ../node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "../node_modules/jsonwebtoken/decode.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var jws = require_jws();
    module2.exports = function(jwt2, options) {
      options = options || {};
      var decoded = jws.decode(jwt2, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// ../node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "../node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = /* @__PURE__ */ __name(function(message, error3) {
      Error.call(this, message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message;
      if (error3) this.inner = error3;
    }, "JsonWebTokenError");
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module2.exports = JsonWebTokenError;
  }
});

// ../node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "../node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = /* @__PURE__ */ __name(function(message, date) {
      JsonWebTokenError.call(this, message);
      this.name = "NotBeforeError";
      this.date = date;
    }, "NotBeforeError");
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module2.exports = NotBeforeError;
  }
});

// ../node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "../node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = /* @__PURE__ */ __name(function(message, expiredAt) {
      JsonWebTokenError.call(this, message);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    }, "TokenExpiredError");
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module2.exports = TokenExpiredError;
  }
});

// ../node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/ms/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse3(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse3, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// ../node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "../node_modules/jsonwebtoken/lib/timespan.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ms = require_ms();
    module2.exports = function(time3, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time3 === "string") {
        var milliseconds = ms(time3);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time3 === "number") {
        return timestamp + time3;
      } else {
        return;
      }
    };
  }
});

// ../node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "../node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// ../node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug4 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug4;
  }
});

// ../node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug4 = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = /* @__PURE__ */ __name((value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    }, "makeSafeRegex");
    var createToken = /* @__PURE__ */ __name((name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug4(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    }, "createToken");
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// ../node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = /* @__PURE__ */ __name((options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    }, "parseOptions");
    module2.exports = parseOptions;
  }
});

// ../node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = /* @__PURE__ */ __name((a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }, "compareIdentifiers");
    var rcompareIdentifiers = /* @__PURE__ */ __name((a, b) => compareIdentifiers(b, a), "rcompareIdentifiers");
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug4 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      static {
        __name(this, "SemVer");
      }
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug4("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug4("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug4("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug4("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release3, identifier, identifierBase) {
        if (release3.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release3) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release3}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// ../node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse3 = /* @__PURE__ */ __name((version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    }, "parse");
    module2.exports = parse3;
  }
});

// ../node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse3 = require_parse();
    var valid = /* @__PURE__ */ __name((version3, options) => {
      const v = parse3(version3, options);
      return v ? v.version : null;
    }, "valid");
    module2.exports = valid;
  }
});

// ../node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse3 = require_parse();
    var clean = /* @__PURE__ */ __name((version3, options) => {
      const s = parse3(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }, "clean");
    module2.exports = clean;
  }
});

// ../node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var inc = /* @__PURE__ */ __name((version3, release3, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release3, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    }, "inc");
    module2.exports = inc;
  }
});

// ../node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse3 = require_parse();
    var diff = /* @__PURE__ */ __name((version1, version22) => {
      const v1 = parse3(version1, null, true);
      const v2 = parse3(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    }, "diff");
    module2.exports = diff;
  }
});

// ../node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var major = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).major, "major");
    module2.exports = major;
  }
});

// ../node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var minor = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).minor, "minor");
    module2.exports = minor;
  }
});

// ../node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var patch = /* @__PURE__ */ __name((a, loose) => new SemVer(a, loose).patch, "patch");
    module2.exports = patch;
  }
});

// ../node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse3 = require_parse();
    var prerelease = /* @__PURE__ */ __name((version3, options) => {
      const parsed = parse3(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }, "prerelease");
    module2.exports = prerelease;
  }
});

// ../node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var compare = /* @__PURE__ */ __name((a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose)), "compare");
    module2.exports = compare;
  }
});

// ../node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var rcompare = /* @__PURE__ */ __name((a, b, loose) => compare(b, a, loose), "rcompare");
    module2.exports = rcompare;
  }
});

// ../node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var compareLoose = /* @__PURE__ */ __name((a, b) => compare(a, b, true), "compareLoose");
    module2.exports = compareLoose;
  }
});

// ../node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var compareBuild = /* @__PURE__ */ __name((a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }, "compareBuild");
    module2.exports = compareBuild;
  }
});

// ../node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compareBuild = require_compare_build();
    var sort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(a, b, loose)), "sort");
    module2.exports = sort;
  }
});

// ../node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compareBuild = require_compare_build();
    var rsort = /* @__PURE__ */ __name((list, loose) => list.sort((a, b) => compareBuild(b, a, loose)), "rsort");
    module2.exports = rsort;
  }
});

// ../node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var gt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) > 0, "gt");
    module2.exports = gt;
  }
});

// ../node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var lt = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) < 0, "lt");
    module2.exports = lt;
  }
});

// ../node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var eq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) === 0, "eq");
    module2.exports = eq;
  }
});

// ../node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var neq = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) !== 0, "neq");
    module2.exports = neq;
  }
});

// ../node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var gte = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) >= 0, "gte");
    module2.exports = gte;
  }
});

// ../node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var lte = /* @__PURE__ */ __name((a, b, loose) => compare(a, b, loose) <= 0, "lte");
    module2.exports = lte;
  }
});

// ../node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = /* @__PURE__ */ __name((a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    }, "cmp");
    module2.exports = cmp;
  }
});

// ../node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = /* @__PURE__ */ __name((version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    }, "coerce");
    module2.exports = coerce;
  }
});

// ../node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "../node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var LRUCache2 = class {
      static {
        __name(this, "LRUCache");
      }
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache2;
  }
});

// ../node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      static {
        __name(this, "Range");
      }
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug4("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug4("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug4("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug4("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug4("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug4("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = /* @__PURE__ */ __name((c) => c.value === "<0.0.0-0", "isNullSet");
    var isAny = /* @__PURE__ */ __name((c) => c.value === "", "isAny");
    var isSatisfiable = /* @__PURE__ */ __name((comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }, "isSatisfiable");
    var parseComparator = /* @__PURE__ */ __name((comp, options) => {
      debug4("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug4("caret", comp);
      comp = replaceTildes(comp, options);
      debug4("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug4("xrange", comp);
      comp = replaceStars(comp, options);
      debug4("stars", comp);
      return comp;
    }, "parseComparator");
    var isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === "x" || id === "*", "isX");
    var replaceTildes = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    }, "replaceTildes");
    var replaceTilde = /* @__PURE__ */ __name((comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug4("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug4("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug4("tilde return", ret);
        return ret;
      });
    }, "replaceTilde");
    var replaceCarets = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    }, "replaceCarets");
    var replaceCaret = /* @__PURE__ */ __name((comp, options) => {
      debug4("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug4("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug4("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug4("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug4("caret return", ret);
        return ret;
      });
    }, "replaceCaret");
    var replaceXRanges = /* @__PURE__ */ __name((comp, options) => {
      debug4("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    }, "replaceXRanges");
    var replaceXRange = /* @__PURE__ */ __name((comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug4("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug4("xRange return", ret);
        return ret;
      });
    }, "replaceXRange");
    var replaceStars = /* @__PURE__ */ __name((comp, options) => {
      debug4("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }, "replaceStars");
    var replaceGTE0 = /* @__PURE__ */ __name((comp, options) => {
      debug4("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    }, "replaceGTE0");
    var hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    }, "hyphenReplace");
    var testSet = /* @__PURE__ */ __name((set, version3, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug4(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }, "testSet");
  }
});

// ../node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static {
        __name(this, "Comparator");
      }
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug4("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug4("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug4("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug4 = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// ../node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var satisfies = /* @__PURE__ */ __name((version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    }, "satisfies");
    module2.exports = satisfies;
  }
});

// ../node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var toComparators = /* @__PURE__ */ __name((range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" ")), "toComparators");
    module2.exports = toComparators;
  }
});

// ../node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = /* @__PURE__ */ __name((versions2, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions2.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }, "maxSatisfying");
    module2.exports = maxSatisfying;
  }
});

// ../node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = /* @__PURE__ */ __name((versions2, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions2.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }, "minSatisfying");
    module2.exports = minSatisfying;
  }
});

// ../node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = /* @__PURE__ */ __name((range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }, "minVersion");
    module2.exports = minVersion;
  }
});

// ../node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var validRange = /* @__PURE__ */ __name((range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }, "validRange");
    module2.exports = validRange;
  }
});

// ../node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = /* @__PURE__ */ __name((version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    }, "outside");
    module2.exports = outside;
  }
});

// ../node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var outside = require_outside();
    var gtr = /* @__PURE__ */ __name((version3, range, options) => outside(version3, range, ">", options), "gtr");
    module2.exports = gtr;
  }
});

// ../node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var outside = require_outside();
    var ltr = /* @__PURE__ */ __name((version3, range, options) => outside(version3, range, "<", options), "ltr");
    module2.exports = ltr;
  }
});

// ../node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var intersects = /* @__PURE__ */ __name((r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    }, "intersects");
    module2.exports = intersects;
  }
});

// ../node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions2, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions2.sort((a, b) => compare(a, b, options));
      for (const version3 of v) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = /* @__PURE__ */ __name((sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    }, "subset");
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = /* @__PURE__ */ __name((sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    }, "simpleSubset");
    var higherGT = /* @__PURE__ */ __name((a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    }, "higherGT");
    var lowerLT = /* @__PURE__ */ __name((a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    }, "lowerLT");
    module2.exports = subset;
  }
});

// ../node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var internalRe = require_re();
    var constants3 = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants3.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants3.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// ../node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "../node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// ../node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "../node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// ../node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "../node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module2.exports = function(algorithm, key) {
      if (!algorithm || !key) return;
      const keyType = key.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// ../node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "../node_modules/jsonwebtoken/lib/psSupported.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module2.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// ../node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "../node_modules/jsonwebtoken/verify.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws();
    var { KeyObject: KeyObject2, createSecretKey: createSecretKey2, createPublicKey: createPublicKey2 } = require_crypto();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module2.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = /* @__PURE__ */ __name(function(err, data) {
          if (err) throw err;
          return data;
        }, "done");
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = /* @__PURE__ */ __name(function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        }, "getSecret");
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject2)) {
          try {
            secretOrPublicKey2 = createPublicKey2(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey2(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// ../node_modules/lodash.includes/index.js
var require_lodash2 = __commonJS({
  "../node_modules/lodash.includes/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    __name(baseIndexOf, "baseIndexOf");
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    __name(baseValues, "baseValues");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    __name(includes, "includes");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    __name(isString2, "isString");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    __name(values, "values");
    module2.exports = includes;
  }
});

// ../node_modules/lodash.isboolean/index.js
var require_lodash3 = __commonJS({
  "../node_modules/lodash.isboolean/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean2(value) {
      return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
    }
    __name(isBoolean2, "isBoolean");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    module2.exports = isBoolean2;
  }
});

// ../node_modules/lodash.isinteger/index.js
var require_lodash4 = __commonJS({
  "../node_modules/lodash.isinteger/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    __name(isInteger, "isInteger");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module2.exports = isInteger;
  }
});

// ../node_modules/lodash.isnumber/index.js
var require_lodash5 = __commonJS({
  "../node_modules/lodash.isnumber/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
    }
    __name(isNumber2, "isNumber");
    module2.exports = isNumber2;
  }
});

// ../node_modules/lodash.isplainobject/index.js
var require_lodash6 = __commonJS({
  "../node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    module2.exports = isPlainObject;
  }
});

// ../node_modules/lodash.isstring/index.js
var require_lodash7 = __commonJS({
  "../node_modules/lodash.isstring/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray2 = Array.isArray;
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
    }
    __name(isString2, "isString");
    module2.exports = isString2;
  }
});

// ../node_modules/lodash.once/index.js
var require_lodash8 = __commonJS({
  "../node_modules/lodash.once/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    __name(before, "before");
    function once2(func) {
      return before(2, func);
    }
    __name(once2, "once");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module2.exports = once2;
  }
});

// ../node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "../node_modules/jsonwebtoken/sign.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws();
    var includes = require_lodash2();
    var isBoolean2 = require_lodash3();
    var isInteger = require_lodash4();
    var isNumber2 = require_lodash5();
    var isPlainObject = require_lodash6();
    var isString2 = require_lodash7();
    var once2 = require_lodash8();
    var { KeyObject: KeyObject2, createSecretKey: createSecretKey2, createPrivateKey: createPrivateKey2 } = require_crypto();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: /* @__PURE__ */ __name(function(value) {
        return isInteger(value) || isString2(value) && value;
      }, "isValid"), message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: /* @__PURE__ */ __name(function(value) {
        return isInteger(value) || isString2(value) && value;
      }, "isValid"), message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: /* @__PURE__ */ __name(function(value) {
        return isString2(value) || Array.isArray(value);
      }, "isValid"), message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString2, message: '"encoding" must be a string' },
      issuer: { isValid: isString2, message: '"issuer" must be a string' },
      subject: { isValid: isString2, message: '"subject" must be a string' },
      jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean2, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString2, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean2, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean2, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean2, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' }
    };
    function validate2(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    __name(validate2, "validate");
    function validateOptions(options) {
      return validate2(sign_options_schema, false, options, "options");
    }
    __name(validateOptions, "validateOptions");
    function validatePayload(payload) {
      return validate2(registered_claims_schema, true, payload, "payload");
    }
    __name(validatePayload, "validatePayload");
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module2.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      __name(failure, "failure");
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject2)) {
        try {
          secretOrPrivateKey = createPrivateKey2(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey2(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error3) {
          return failure(error3);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error3) {
        return failure(error3);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error3) {
          return failure(error3);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once2(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// ../node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "../node_modules/jsonwebtoken/index.js"(exports2, module2) {
    init_strip_cf_connecting_ip_header();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module2.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// .wrangler/tmp/bundle-kaawHL/middleware-loader.entry.ts
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-kaawHL/middleware-insertion-facade.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@apollo/server/dist/esm/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@apollo/server/dist/esm/ApolloServer.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_utils27 = __toESM(require_dist(), 1);
var import_utils28 = __toESM(require_dist2(), 1);

// ../node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql9 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/helpers.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var asArray = /* @__PURE__ */ __name((fns) => Array.isArray(fns) ? fns : fns ? [fns] : [], "asArray");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/Interfaces.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MapperKind;
(function(MapperKind2) {
  MapperKind2["TYPE"] = "MapperKind.TYPE";
  MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind2["QUERY"] = "MapperKind.QUERY";
  MapperKind2["MUTATION"] = "MapperKind.MUTATION";
  MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind2["FIELD"] = "MapperKind.FIELD";
  MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/mapSchema.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql5 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql = __toESM(require_graphql2(), 1);
function getObjectTypeFromTypeMap(typeMap, type2) {
  if (type2) {
    const maybeObjectType = typeMap[type2.name];
    if ((0, import_graphql.isObjectType)(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}
__name(getObjectTypeFromTypeMap, "getObjectTypeFromTypeMap");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/rewire.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql3 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/stub.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql2 = __toESM(require_graphql2(), 1);
function isNamedStub(type2) {
  if ("getFields" in type2) {
    const fields = type2.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
__name(isNamedStub, "isNamedStub");
function getBuiltInForStub(type2) {
  switch (type2.name) {
    case import_graphql2.GraphQLInt.name:
      return import_graphql2.GraphQLInt;
    case import_graphql2.GraphQLFloat.name:
      return import_graphql2.GraphQLFloat;
    case import_graphql2.GraphQLString.name:
      return import_graphql2.GraphQLString;
    case import_graphql2.GraphQLBoolean.name:
      return import_graphql2.GraphQLBoolean;
    case import_graphql2.GraphQLID.name:
      return import_graphql2.GraphQLID;
    default:
      return type2;
  }
}
__name(getBuiltInForStub, "getBuiltInForStub");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/rewire.js
function rewireTypes(originalTypeMap, directives) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
      continue;
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if ((0, import_graphql3.isSpecifiedDirective)(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new import_graphql3.GraphQLDirective(directiveConfig);
  }
  __name(rewireDirective, "rewireDirective");
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  __name(rewireArgs, "rewireArgs");
  function rewireNamedType(type2) {
    if ((0, import_graphql3.isObjectType)(type2)) {
      const config2 = type2.toConfig();
      const newConfig = {
        ...config2,
        fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields"),
        interfaces: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.interfaces), "interfaces")
      };
      return new import_graphql3.GraphQLObjectType(newConfig);
    } else if ((0, import_graphql3.isInterfaceType)(type2)) {
      const config2 = type2.toConfig();
      const newConfig = {
        ...config2,
        fields: /* @__PURE__ */ __name(() => rewireFields(config2.fields), "fields")
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
      }
      return new import_graphql3.GraphQLInterfaceType(newConfig);
    } else if ((0, import_graphql3.isUnionType)(type2)) {
      const config2 = type2.toConfig();
      const newConfig = {
        ...config2,
        types: /* @__PURE__ */ __name(() => rewireNamedTypes(config2.types), "types")
      };
      return new import_graphql3.GraphQLUnionType(newConfig);
    } else if ((0, import_graphql3.isInputObjectType)(type2)) {
      const config2 = type2.toConfig();
      const newConfig = {
        ...config2,
        fields: /* @__PURE__ */ __name(() => rewireInputFields(config2.fields), "fields")
      };
      return new import_graphql3.GraphQLInputObjectType(newConfig);
    } else if ((0, import_graphql3.isEnumType)(type2)) {
      const enumConfig = type2.toConfig();
      return new import_graphql3.GraphQLEnumType(enumConfig);
    } else if ((0, import_graphql3.isScalarType)(type2)) {
      if ((0, import_graphql3.isSpecifiedScalarType)(type2)) {
        return type2;
      }
      const scalarConfig = type2.toConfig();
      return new import_graphql3.GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type2}`);
  }
  __name(rewireNamedType, "rewireNamedType");
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  __name(rewireFields, "rewireFields");
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  __name(rewireInputFields, "rewireInputFields");
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  __name(rewireNamedTypes, "rewireNamedTypes");
  function rewireType(type2) {
    if ((0, import_graphql3.isListType)(type2)) {
      const rewiredType = rewireType(type2.ofType);
      return rewiredType != null ? new import_graphql3.GraphQLList(rewiredType) : null;
    } else if ((0, import_graphql3.isNonNullType)(type2)) {
      const rewiredType = rewireType(type2.ofType);
      return rewiredType != null ? new import_graphql3.GraphQLNonNull(rewiredType) : null;
    } else if ((0, import_graphql3.isNamedType)(type2)) {
      let rewiredType = referenceTypeMap[type2.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub(type2) ? getBuiltInForStub(type2) : rewireNamedType(type2);
        newTypeMap[rewiredType.name] = referenceTypeMap[type2.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
  __name(rewireType, "rewireType");
}
__name(rewireTypes, "rewireTypes");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/transformInputValue.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql4 = __toESM(require_graphql2(), 1);
function transformInputValue(type2, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = (0, import_graphql4.getNullableType)(type2);
  if ((0, import_graphql4.isLeafType)(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if ((0, import_graphql4.isListType)(nullableType)) {
    return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if ((0, import_graphql4.isInputObjectType)(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
__name(transformInputValue, "transformInputValue");
function serializeInputValue(type2, value) {
  return transformInputValue(type2, value, (t, v) => {
    try {
      return t.serialize(v);
    } catch (_a) {
      return v;
    }
  });
}
__name(serializeInputValue, "serializeInputValue");
function parseInputValue(type2, value) {
  return transformInputValue(type2, value, (t, v) => {
    try {
      return t.parseValue(v);
    } catch (_a) {
      return v;
    }
  });
}
__name(parseInputValue, "parseInputValue");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/mapSchema.js
function mapSchema(schema, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type2) => (0, import_graphql5.isLeafType)(type2)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type2) => !(0, import_graphql5.isLeafType)(type2)), schema, schemaMapper), schema, schemaMapper);
  const originalDirectives = schema.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
  return new import_graphql5.GraphQLSchema({
    ...schema.toConfig(),
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  });
}
__name(mapSchema, "mapSchema");
function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
__name(mapTypes, "mapTypes");
function mapEnumValues(originalTypeMap, schema, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema, {
    [MapperKind.ENUM_TYPE]: (type2) => {
      const config2 = type2.toConfig();
      const originalEnumValueConfigMap = config2.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type2.name, schema, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new import_graphql5.GraphQLEnumType({
        ...config2,
        values: newEnumValueConfigMap
      }));
    }
  }, (type2) => (0, import_graphql5.isEnumType)(type2));
}
__name(mapEnumValues, "mapEnumValues");
function mapDefaultValues(originalTypeMap, schema, fn) {
  const newTypeMap = mapArguments(originalTypeMap, schema, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields(newTypeMap, schema, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
}
__name(mapDefaultValues, "mapDefaultValues");
function getNewType(newTypeMap, type2) {
  if ((0, import_graphql5.isListType)(type2)) {
    const newType = getNewType(newTypeMap, type2.ofType);
    return newType != null ? new import_graphql5.GraphQLList(newType) : null;
  } else if ((0, import_graphql5.isNonNullType)(type2)) {
    const newType = getNewType(newTypeMap, type2.ofType);
    return newType != null ? new import_graphql5.GraphQLNonNull(newType) : null;
  } else if ((0, import_graphql5.isNamedType)(type2)) {
    const newType = newTypeMap[type2.name];
    return newType != null ? newType : null;
  }
  return null;
}
__name(getNewType, "getNewType");
function mapFields(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql5.isObjectType)(originalType) && !(0, import_graphql5.isInterfaceType)(originalType) && !(0, import_graphql5.isInputObjectType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if ((0, import_graphql5.isObjectType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql5.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else if ((0, import_graphql5.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new import_graphql5.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes(new import_graphql5.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
__name(mapFields, "mapFields");
function mapArguments(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!(0, import_graphql5.isObjectType)(originalType) && !(0, import_graphql5.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if ((0, import_graphql5.isObjectType)(originalType)) {
        newTypeMap[typeName] = new import_graphql5.GraphQLObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else if ((0, import_graphql5.isInterfaceType)(originalType)) {
        newTypeMap[typeName] = new import_graphql5.GraphQLInterfaceType({
          ...config2,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new import_graphql5.GraphQLInputObjectType({
          ...config2,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
}
__name(mapArguments, "mapArguments");
function mapDirectives(originalDirectives, schema, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema);
    if (mappedDirective === void 0) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
__name(mapDirectives, "mapDirectives");
function getTypeSpecifiers(schema, typeName) {
  var _a, _b, _c;
  const type2 = schema.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if ((0, import_graphql5.isObjectType)(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if ((0, import_graphql5.isInputObjectType)(type2)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if ((0, import_graphql5.isInterfaceType)(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if ((0, import_graphql5.isUnionType)(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if ((0, import_graphql5.isEnumType)(type2)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if ((0, import_graphql5.isScalarType)(type2)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
}
__name(getTypeSpecifiers, "getTypeSpecifiers");
function getTypeMapper(schema, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
}
__name(getTypeMapper, "getTypeMapper");
function getFieldSpecifiers(schema, typeName) {
  var _a, _b, _c;
  const type2 = schema.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if ((0, import_graphql5.isObjectType)(type2)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if ((0, import_graphql5.isInterfaceType)(type2)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if ((0, import_graphql5.isInputObjectType)(type2)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
__name(getFieldSpecifiers, "getFieldSpecifiers");
function getFieldMapper(schema, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
}
__name(getFieldMapper, "getFieldMapper");
function getArgumentMapper(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
__name(getArgumentMapper, "getArgumentMapper");
function getDirectiveMapper(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
__name(getDirectiveMapper, "getDirectiveMapper");
function getEnumValueMapper(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
__name(getEnumValueMapper, "getEnumValueMapper");
function correctASTNodes(type2) {
  if ((0, import_graphql5.isObjectType)(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql5.Kind.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql5.Kind.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql5.GraphQLObjectType(config2);
  } else if ((0, import_graphql5.isInterfaceType)(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql5.Kind.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql5.Kind.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql5.GraphQLInterfaceType(config2);
  } else if ((0, import_graphql5.isInputObjectType)(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        kind: import_graphql5.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        kind: import_graphql5.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new import_graphql5.GraphQLInputObjectType(config2);
  } else if ((0, import_graphql5.isEnumType)(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const values = [];
      for (const enumKey in config2.values) {
        const enumValueConfig = config2.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config2.astNode = {
        ...config2.astNode,
        values
      };
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => ({
        ...node,
        values: void 0
      }));
    }
    return new import_graphql5.GraphQLEnumType(config2);
  } else {
    return type2;
  }
}
__name(correctASTNodes, "correctASTNodes");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/heal.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql6 = __toESM(require_graphql2(), 1);
function healSchema(schema) {
  healTypes(schema.getTypeMap(), schema.getDirectives());
  return schema;
}
__name(healSchema, "healSchema");
function healTypes(originalTypeMap, directives) {
  const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualNamedTypeMap[actualName] != null) {
      console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
      continue;
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type2) {
    if ((0, import_graphql6.isObjectType)(type2)) {
      healFields(type2);
      healInterfaces(type2);
      return;
    } else if ((0, import_graphql6.isInterfaceType)(type2)) {
      healFields(type2);
      if ("getInterfaces" in type2) {
        healInterfaces(type2);
      }
      return;
    } else if ((0, import_graphql6.isUnionType)(type2)) {
      healUnderlyingTypes(type2);
      return;
    } else if ((0, import_graphql6.isInputObjectType)(type2)) {
      healInputFields(type2);
      return;
    } else if ((0, import_graphql6.isLeafType)(type2)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type2}`);
  }
  __name(healNamedType, "healNamedType");
  function healFields(type2) {
    const fieldMap = type2.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  __name(healFields, "healFields");
  function healInterfaces(type2) {
    if ("getInterfaces" in type2) {
      const interfaces = type2.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  __name(healInterfaces, "healInterfaces");
  function healInputFields(type2) {
    const fieldMap = type2.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  __name(healInputFields, "healInputFields");
  function healUnderlyingTypes(type2) {
    const types3 = type2.getTypes();
    types3.push(...types3.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  __name(healUnderlyingTypes, "healUnderlyingTypes");
  function healType(type2) {
    if ((0, import_graphql6.isListType)(type2)) {
      const healedType = healType(type2.ofType);
      return healedType != null ? new import_graphql6.GraphQLList(healedType) : null;
    } else if ((0, import_graphql6.isNonNullType)(type2)) {
      const healedType = healType(type2.ofType);
      return healedType != null ? new import_graphql6.GraphQLNonNull(healedType) : null;
    } else if ((0, import_graphql6.isNamedType)(type2)) {
      const officialType = originalTypeMap[type2.name];
      if (officialType && type2 !== officialType) {
        return officialType;
      }
    }
    return type2;
  }
  __name(healType, "healType");
}
__name(healTypes, "healTypes");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/forEachField.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql7 = __toESM(require_graphql2(), 1);
function forEachField(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type2 = typeMap[typeName];
    if (!(0, import_graphql7.getNamedType)(type2).name.startsWith("__") && (0, import_graphql7.isObjectType)(type2)) {
      const fields = type2.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn(field, typeName, fieldName);
      }
    }
  }
}
__name(forEachField, "forEachField");

// ../node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql8 = __toESM(require_graphql2(), 1);
function forEachDefaultValue(schema, fn) {
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type2 = typeMap[typeName];
    if (!(0, import_graphql8.getNamedType)(type2).name.startsWith("__")) {
      if ((0, import_graphql8.isObjectType)(type2)) {
        const fields = type2.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn(arg.type, arg.defaultValue);
          }
        }
      } else if ((0, import_graphql8.isInputObjectType)(type2)) {
        const fields = type2.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn(field.type, field.defaultValue);
        }
      }
    }
  }
}
__name(forEachDefaultValue, "forEachDefaultValue");

// ../node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
function assertResolversPresent(schema, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !(0, import_graphql9.isScalarType)((0, import_graphql9.getNamedType)(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
__name(assertResolversPresent, "assertResolversPresent");
function expectResolver(validator, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
}
__name(expectResolver, "expectResolver");

// ../node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql10 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
  mapSchema(schema, {
    [MapperKind.ABSTRACT_TYPE]: (type2) => {
      if (!type2.resolveType) {
        const message = `Type "${type2.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return void 0;
    }
  });
}
__name(checkForResolveTypeResolver, "checkForResolveTypeResolver");

// ../node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function extendResolversFromInterfaces(schema, resolvers2) {
  const extendedResolvers = {};
  const typeMap = schema.getTypeMap();
  for (const typeName in typeMap) {
    const type2 = typeMap[typeName];
    if ("getInterfaces" in type2) {
      extendedResolvers[typeName] = {};
      for (const iFace of type2.getInterfaces()) {
        if (resolvers2[iFace.name]) {
          for (const fieldName in resolvers2[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers2[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers2[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers2[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}
__name(extendResolversFromInterfaces, "extendResolversFromInterfaces");

// ../node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
function addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver2, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers2 = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;
  for (const typeName in resolvers2) {
    const resolverValue = resolvers2[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type2 = schema.getType(typeName);
    if (type2 == null) {
      if (requireResolversToMatchSchema === "ignore") {
        continue;
      }
      throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
    } else if ((0, import_graphql10.isSpecifiedScalarType)(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type2[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql10.isEnumType)(type2)) {
      const values = type2.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but not present within ${type2.name}`);
        }
      }
    } else if ((0, import_graphql10.isUnionType)(type2)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but ${type2.name} is not an object or interface type`);
        }
      }
    } else if ((0, import_graphql10.isObjectType)(type2) || (0, import_graphql10.isInterfaceType)(type2)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields = type2.getFields();
          const field = fields[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver2) : createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver2);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema, requireResolversForResolveType);
  }
  return schema;
}
__name(addResolversToSchema, "addResolversToSchema");
function addResolversToExistingSchema(schema, resolvers2, defaultFieldResolver2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  const typeMap = schema.getTypeMap();
  for (const typeName in resolvers2) {
    const type2 = schema.getType(typeName);
    const resolverValue = resolvers2[typeName];
    if ((0, import_graphql10.isScalarType)(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type2.astNode != null) {
          type2.astNode = {
            ...type2.astNode,
            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.astNode.description,
            directives: ((_c = type2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
          };
        } else if (fieldName === "extensionASTNodes" && type2.extensionASTNodes != null) {
          type2.extensionASTNodes = type2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
        } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
          type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
        } else {
          type2[fieldName] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql10.isEnumType)(type2)) {
      const config2 = type2.toConfig();
      const enumValueConfigMap = config2.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config2[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config2.astNode != null) {
          config2.astNode = {
            ...config2.astNode,
            description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config2.astNode.description,
            directives: ((_j = config2.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])
          };
        } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);
        } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
          type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new import_graphql10.GraphQLEnumType(config2);
    } else if ((0, import_graphql10.isUnionType)(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if ((0, import_graphql10.isObjectType)(type2) || (0, import_graphql10.isInterfaceType)(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields = type2.getFields();
        const field = fields[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema, serializeInputValue);
  healSchema(schema);
  forEachDefaultValue(schema, parseInputValue);
  if (defaultFieldResolver2 != null) {
    forEachField(schema, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver2;
      }
    });
  }
  return schema;
}
__name(addResolversToExistingSchema, "addResolversToExistingSchema");
function createNewSchemaWithResolvers(schema, resolvers2, defaultFieldResolver2) {
  schema = mapSchema(schema, {
    [MapperKind.SCALAR_TYPE]: (type2) => {
      var _a, _b, _c, _d, _e, _f;
      const config2 = type2.toConfig();
      const resolverValue = resolvers2[type2.name];
      if (!(0, import_graphql10.isSpecifiedScalarType)(type2) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
              directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
          } else {
            config2[fieldName] = resolverValue[fieldName];
          }
        }
        return new import_graphql10.GraphQLScalarType(config2);
      }
    },
    [MapperKind.ENUM_TYPE]: (type2) => {
      var _a, _b, _c, _d, _e, _f;
      const resolverValue = resolvers2[type2.name];
      const config2 = type2.toConfig();
      const enumValueConfigMap = config2.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = {
              ...config2.astNode,
              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config2.astNode.description,
              directives: ((_c = config2.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])
            };
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new import_graphql10.GraphQLEnumType(config2);
      }
    },
    [MapperKind.UNION_TYPE]: (type2) => {
      const resolverValue = resolvers2[type2.name];
      if (resolverValue != null) {
        const config2 = type2.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql10.GraphQLUnionType(config2);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type2) => {
      const resolverValue = resolvers2[type2.name];
      if (resolverValue != null) {
        const config2 = type2.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config2.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new import_graphql10.GraphQLObjectType(config2);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type2) => {
      const resolverValue = resolvers2[type2.name];
      if (resolverValue != null) {
        const config2 = type2.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new import_graphql10.GraphQLInterfaceType(config2);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers2[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver2 != null) {
    schema = mapSchema(schema, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver2
      })
    });
  }
  return schema;
}
__name(createNewSchemaWithResolvers, "createNewSchemaWithResolvers");
function setFieldProperties(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
}
__name(setFieldProperties, "setFieldProperties");

// ../node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql28 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/merge/esm/merge-resolvers.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/helpers.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function compareStrings(a, b) {
  if (String(a) < String(b)) {
    return -1;
  }
  if (String(a) > String(b)) {
    return 1;
  }
  return 0;
}
__name(compareStrings, "compareStrings");
function nodeToString(a) {
  var _a, _b;
  let name;
  if ("alias" in a) {
    name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;
  }
  if (name == null && "name" in a) {
    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
  }
  if (name == null) {
    name = a.kind;
  }
  return name;
}
__name(nodeToString, "nodeToString");
function compareNodes(a, b, customFn) {
  const aStr = nodeToString(a);
  const bStr = nodeToString(b);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
__name(compareNodes, "compareNodes");
function isSome(input) {
  return input != null;
}
__name(isSome, "isSome");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/get-directives.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/inspect.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql11 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/AggregateError.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var AggregateErrorImpl;
if (typeof AggregateError === "undefined") {
  class AggregateErrorClass extends Error {
    static {
      __name(this, "AggregateErrorClass");
    }
    constructor(errors, message = "") {
      super(message);
      this.errors = errors;
      this.name = "AggregateError";
      Error.captureStackTrace(this, AggregateErrorClass);
    }
  }
  AggregateErrorImpl = /* @__PURE__ */ __name(function(errors, message) {
    return new AggregateErrorClass(errors, message);
  }, "AggregateErrorImpl");
} else {
  AggregateErrorImpl = AggregateError;
}
function isAggregateError(error3) {
  return "errors" in error3 && Array.isArray(error3["errors"]);
}
__name(isAggregateError, "isAggregateError");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/inspect.js
var MAX_RECURSIVE_DEPTH = 3;
function inspect(value) {
  return formatValue(value, []);
}
__name(inspect, "inspect");
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
__name(formatValue, "formatValue");
function formatError(value) {
  if (value instanceof import_graphql11.GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
__name(formatError, "formatError");
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (isAggregateError(value)) {
      return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
    }
    return formatError(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
__name(formatObjectValue, "formatObjectValue");
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
__name(isJSONable, "isJSONable");
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
__name(formatObject, "formatObject");
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
}
__name(formatArray, "formatArray");
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
__name(getObjectTag, "getObjectTag");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/get-directives.js
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
}
__name(getDirectivesInExtensions, "getDirectivesInExtensions");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql14 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/astFromType.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql12 = __toESM(require_graphql2(), 1);
function astFromType(type2) {
  if ((0, import_graphql12.isNonNullType)(type2)) {
    const innerType = astFromType(type2.ofType);
    if (innerType.kind === import_graphql12.Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type2)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: import_graphql12.Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if ((0, import_graphql12.isListType)(type2)) {
    return {
      kind: import_graphql12.Kind.LIST_TYPE,
      type: astFromType(type2.ofType)
    };
  }
  return {
    kind: import_graphql12.Kind.NAMED_TYPE,
    name: {
      kind: import_graphql12.Kind.NAME,
      value: type2.name
    }
  };
}
__name(astFromType, "astFromType");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql13 = __toESM(require_graphql2(), 1);
function astFromValueUntyped(value) {
  if (value === null) {
    return { kind: import_graphql13.Kind.NULL };
  }
  if (value === void 0) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: import_graphql13.Kind.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast = astFromValueUntyped(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: import_graphql13.Kind.OBJECT_FIELD,
          name: { kind: import_graphql13.Kind.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: import_graphql13.Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: import_graphql13.Kind.BOOLEAN, value };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp.test(stringNum) ? { kind: import_graphql13.Kind.INT, value: stringNum } : { kind: import_graphql13.Kind.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: import_graphql13.Kind.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
__name(astFromValueUntyped, "astFromValueUntyped");
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/rootTypes.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/memoize.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function memoize1(fn) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return /* @__PURE__ */ __name(function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  }, "memoized");
}
__name(memoize1, "memoize1");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/rootTypes.js
var getRootTypeNames = memoize1(/* @__PURE__ */ __name(function getRootTypeNames2(schema) {
  const rootTypes = getRootTypes(schema);
  return new Set([...rootTypes].map((type2) => type2.name));
}, "getRootTypeNames"));
var getRootTypes = memoize1(/* @__PURE__ */ __name(function getRootTypes2(schema) {
  const rootTypeMap = getRootTypeMap(schema);
  return new Set(rootTypeMap.values());
}, "getRootTypes"));
var getRootTypeMap = memoize1(/* @__PURE__ */ __name(function getRootTypeMap2(schema) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
}, "getRootTypeMap"));

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
function getDocumentNodeFromSchema(schema, options = {}) {
  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
  const typesMap = schema.getTypeMap();
  const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives = schema.getDirectives();
  for (const directive of directives) {
    if ((0, import_graphql14.isSpecifiedDirective)(directive)) {
      continue;
    }
    definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type2 = typesMap[typeName];
    const isPredefinedScalar = (0, import_graphql14.isSpecifiedScalarType)(type2);
    const isIntrospection = (0, import_graphql14.isIntrospectionType)(type2);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if ((0, import_graphql14.isObjectType)(type2)) {
      definitions.push(astFromObjectType(type2, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql14.isInterfaceType)(type2)) {
      definitions.push(astFromInterfaceType(type2, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql14.isUnionType)(type2)) {
      definitions.push(astFromUnionType(type2, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql14.isInputObjectType)(type2)) {
      definitions.push(astFromInputObjectType(type2, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql14.isEnumType)(type2)) {
      definitions.push(astFromEnumType(type2, schema, pathToDirectivesInExtensions));
    } else if ((0, import_graphql14.isScalarType)(type2)) {
      definitions.push(astFromScalarType(type2, schema, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type2}.`);
    }
  }
  return {
    kind: import_graphql14.Kind.DOCUMENT,
    definitions
  };
}
__name(getDocumentNodeFromSchema, "getDocumentNodeFromSchema");
function astFromSchema(schema, pathToDirectivesInExtensions) {
  var _a, _b;
  const operationTypeMap = /* @__PURE__ */ new Map([
    ["query", void 0],
    ["mutation", void 0],
    ["subscription", void 0]
  ]);
  const nodes = [];
  if (schema.astNode != null) {
    nodes.push(schema.astNode);
  }
  if (schema.extensionASTNodes != null) {
    for (const extensionASTNode of schema.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: import_graphql14.Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? import_graphql14.Kind.SCHEMA_DEFINITION : import_graphql14.Kind.SCHEMA_EXTENSION,
    operationTypes,
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives
  };
  schemaNode.description = ((_b = (_a = schema.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : schema.description != null) ? {
    kind: import_graphql14.Kind.STRING,
    value: schema.description,
    block: true
  } : void 0;
  return schemaNode;
}
__name(astFromSchema, "astFromSchema");
function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c, _d;
  return {
    kind: import_graphql14.Kind.DIRECTIVE_DEFINITION,
    description: (_b = (_a = directive.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : directive.description ? {
      kind: import_graphql14.Kind.STRING,
      value: directive.description
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: directive.name
    },
    arguments: (_c = directive.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: ((_d = directive.locations) === null || _d === void 0 ? void 0 : _d.map((location) => ({
      kind: import_graphql14.Kind.NAME,
      value: location
    }))) || []
  };
}
__name(astFromDirective, "astFromDirective");
function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let nodes = [];
  if (entity.astNode != null) {
    nodes.push(entity.astNode);
  }
  if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
    nodes = nodes.concat(entity.extensionASTNodes);
  }
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = [];
    for (const node of nodes) {
      if (node.directives) {
        directives.push(...node.directives);
      }
    }
  }
  return directives;
}
__name(getDirectiveNodes, "getDirectiveNodes");
function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  let directiveNodesBesidesDeprecated = [];
  let deprecatedDirectiveNode = null;
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives;
  if (directivesInExtensions != null) {
    directives = makeDirectiveNodes(schema, directivesInExtensions);
  } else {
    directives = (_a = entity.astNode) === null || _a === void 0 ? void 0 : _a.directives;
  }
  if (directives != null) {
    directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
}
__name(getDeprecatableDirectiveNodes, "getDeprecatableDirectiveNodes");
function astFromArg(arg, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c;
  return {
    kind: import_graphql14.Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a = arg.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : arg.description ? {
      kind: import_graphql14.Kind.STRING,
      value: arg.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    defaultValue: arg.defaultValue !== void 0 ? (_c = (0, import_graphql14.astFromValue)(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
    directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
  };
}
__name(astFromArg, "astFromArg");
function astFromObjectType(type2, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql14.Kind.OBJECT_TYPE_DEFINITION,
    description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: import_graphql14.Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: type2.name
    },
    fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    interfaces: Object.values(type2.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
  };
}
__name(astFromObjectType, "astFromObjectType");
function astFromInterfaceType(type2, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  const node = {
    kind: import_graphql14.Kind.INTERFACE_TYPE_DEFINITION,
    description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: import_graphql14.Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: type2.name
    },
    fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type2) {
    node.interfaces = Object.values(type2.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
__name(astFromInterfaceType, "astFromInterfaceType");
function astFromUnionType(type2, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql14.Kind.UNION_TYPE_DEFINITION,
    description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: import_graphql14.Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: type2.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions),
    types: type2.getTypes().map((type3) => astFromType(type3))
  };
}
__name(astFromUnionType, "astFromUnionType");
function astFromInputObjectType(type2, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql14.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: import_graphql14.Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: type2.name
    },
    fields: Object.values(type2.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
  };
}
__name(astFromInputObjectType, "astFromInputObjectType");
function astFromEnumType(type2, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql14.Kind.ENUM_TYPE_DEFINITION,
    description: (_b = (_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: import_graphql14.Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: type2.name
    },
    values: Object.values(type2.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDirectiveNodes(type2, schema, pathToDirectivesInExtensions)
  };
}
__name(astFromEnumType, "astFromEnumType");
function astFromScalarType(type2, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c;
  const directivesInExtensions = getDirectivesInExtensions(type2, pathToDirectivesInExtensions);
  const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type2.astNode) === null || _a === void 0 ? void 0 : _a.directives) || [];
  const specifiedByValue = type2["specifiedByUrl"] || type2["specifiedByURL"];
  if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: import_graphql14.Kind.SCALAR_TYPE_DEFINITION,
    description: (_c = (_b = type2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type2.description ? {
      kind: import_graphql14.Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: type2.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives
  };
}
__name(astFromScalarType, "astFromScalarType");
function astFromField(field, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql14.Kind.FIELD_DEFINITION,
    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: import_graphql14.Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
  };
}
__name(astFromField, "astFromField");
function astFromInputField(field, schema, pathToDirectivesInExtensions) {
  var _a, _b, _c;
  return {
    kind: import_graphql14.Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a = field.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: import_graphql14.Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
    defaultValue: (_c = (0, import_graphql14.astFromValue)(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
  };
}
__name(astFromInputField, "astFromInputField");
function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
  var _a, _b;
  return {
    kind: import_graphql14.Kind.ENUM_VALUE_DEFINITION,
    description: (_b = (_a = value.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : value.description ? {
      kind: import_graphql14.Kind.STRING,
      value: value.description,
      block: true
    } : void 0,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: value.name
    },
    // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
    directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
  };
}
__name(astFromEnumValue, "astFromEnumValue");
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, import_graphql14.GraphQLDeprecatedDirective);
}
__name(makeDeprecatedDirective, "makeDeprecatedDirective");
function makeDirectiveNode(name, args, directive) {
  const directiveArguments = [];
  if (directive != null) {
    for (const arg of directive.args) {
      const argName = arg.name;
      const argValue = args[argName];
      if (argValue !== void 0) {
        const value = (0, import_graphql14.astFromValue)(argValue, arg.type);
        if (value) {
          directiveArguments.push({
            kind: import_graphql14.Kind.ARGUMENT,
            name: {
              kind: import_graphql14.Kind.NAME,
              value: argName
            },
            value
          });
        }
      }
    }
  } else {
    for (const argName in args) {
      const argValue = args[argName];
      const value = astFromValueUntyped(argValue);
      if (value) {
        directiveArguments.push({
          kind: import_graphql14.Kind.ARGUMENT,
          name: {
            kind: import_graphql14.Kind.NAME,
            value: argName
          },
          value
        });
      }
    }
  }
  return {
    kind: import_graphql14.Kind.DIRECTIVE,
    name: {
      kind: import_graphql14.Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
__name(makeDirectiveNode, "makeDirectiveNode");
function makeDirectiveNodes(schema, directiveValues) {
  const directiveNodes = [];
  for (const directiveName in directiveValues) {
    const arrayOrSingleValue = directiveValues[directiveName];
    const directive = schema === null || schema === void 0 ? void 0 : schema.getDirective(directiveName);
    if (Array.isArray(arrayOrSingleValue)) {
      for (const value of arrayOrSingleValue) {
        directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
      }
    } else {
      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
    }
  }
  return directiveNodes;
}
__name(makeDirectiveNodes, "makeDirectiveNodes");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/comments.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql15 = __toESM(require_graphql2(), 1);
var MAX_LINE_LENGTH = 80;
var commentsRegistry = {};
function resetComments() {
  commentsRegistry = {};
}
__name(resetComments, "resetComments");
function collectComment(node) {
  var _a;
  const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
__name(collectComment, "collectComment");
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys = [entity];
  if (field) {
    keys.push(field);
    if (argument) {
      keys.push(argument);
    }
  }
  const path = keys.join(".");
  if (!commentsRegistry[path]) {
    commentsRegistry[path] = [];
  }
  commentsRegistry[path].push(comment);
}
__name(pushComment, "pushComment");
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
__name(printComment, "printComment");
function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
}
__name(join, "join");
function hasMultilineItems(maybeArray) {
  var _a;
  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a !== void 0 ? _a : false;
}
__name(hasMultilineItems, "hasMultilineItems");
function addDescription(cb) {
  return (node, _key, _parent, path, ancestors) => {
    var _a;
    const keys = [];
    const parent = path.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
  };
}
__name(addDescription, "addDescription");
function indent(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
__name(indent, "indent");
function block(array) {
  return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
}
__name(block, "block");
function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
__name(wrap, "wrap");
function printBlockString(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
}
__name(printBlockString, "printBlockString");
var printDocASTReducer = {
  Name: { leave: /* @__PURE__ */ __name((node) => node.value, "leave") },
  Variable: { leave: /* @__PURE__ */ __name((node) => "$" + node.name, "leave") },
  // Document
  Document: {
    leave: /* @__PURE__ */ __name((node) => join(node.definitions, "\n\n"), "leave")
  },
  OperationDefinition: {
    leave: /* @__PURE__ */ __name((node) => {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }, "leave")
  },
  VariableDefinition: {
    leave: /* @__PURE__ */ __name(({ variable, type: type2, defaultValue, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " ")), "leave")
  },
  SelectionSet: { leave: /* @__PURE__ */ __name(({ selections }) => block(selections), "leave") },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
  // Fragments
  FragmentSpread: {
    leave: /* @__PURE__ */ __name(({ name, directives }) => "..." + name + wrap(" ", join(directives, " ")), "leave")
  },
  InlineFragment: {
    leave: /* @__PURE__ */ __name(({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " "), "leave")
  },
  FragmentDefinition: {
    leave: /* @__PURE__ */ __name(({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    ), "leave")
  },
  // Value
  IntValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
  FloatValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
  StringValue: {
    leave: /* @__PURE__ */ __name(({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString(value);
      }
      return JSON.stringify(value);
    }, "leave")
  },
  BooleanValue: { leave: /* @__PURE__ */ __name(({ value }) => value ? "true" : "false", "leave") },
  NullValue: { leave: /* @__PURE__ */ __name(() => "null", "leave") },
  EnumValue: { leave: /* @__PURE__ */ __name(({ value }) => value, "leave") },
  ListValue: { leave: /* @__PURE__ */ __name(({ values }) => "[" + join(values, ", ") + "]", "leave") },
  ObjectValue: { leave: /* @__PURE__ */ __name(({ fields }) => "{" + join(fields, ", ") + "}", "leave") },
  ObjectField: { leave: /* @__PURE__ */ __name(({ name, value }) => name + ": " + value, "leave") },
  // Directive
  Directive: {
    leave: /* @__PURE__ */ __name(({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")"), "leave")
  },
  // Type
  NamedType: { leave: /* @__PURE__ */ __name(({ name }) => name, "leave") },
  ListType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => "[" + type2 + "]", "leave") },
  NonNullType: { leave: /* @__PURE__ */ __name(({ type: type2 }) => type2 + "!", "leave") },
  // Type System Definitions
  SchemaDefinition: {
    leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["schema", join(directives, " "), block(operationTypes)], " "), "leave")
  },
  OperationTypeDefinition: {
    leave: /* @__PURE__ */ __name(({ operation, type: type2 }) => operation + ": " + type2, "leave")
  },
  ScalarTypeDefinition: {
    leave: /* @__PURE__ */ __name(({ name, directives }) => join(["scalar", name, join(directives, " ")], " "), "leave")
  },
  ObjectTypeDefinition: {
    leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
  },
  FieldDefinition: {
    leave: /* @__PURE__ */ __name(({ name, arguments: args, type: type2, directives }) => name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " ")), "leave")
  },
  InputValueDefinition: {
    leave: /* @__PURE__ */ __name(({ name, type: type2, defaultValue, directives }) => join([name + ": " + type2, wrap("= ", defaultValue), join(directives, " ")], " "), "leave")
  },
  InterfaceTypeDefinition: {
    leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
  },
  UnionTypeDefinition: {
    leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
  },
  EnumTypeDefinition: {
    leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["enum", name, join(directives, " "), block(values)], " "), "leave")
  },
  EnumValueDefinition: {
    leave: /* @__PURE__ */ __name(({ name, directives }) => join([name, join(directives, " ")], " "), "leave")
  },
  InputObjectTypeDefinition: {
    leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["input", name, join(directives, " "), block(fields)], " "), "leave")
  },
  DirectiveDefinition: {
    leave: /* @__PURE__ */ __name(({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | "), "leave")
  },
  SchemaExtension: {
    leave: /* @__PURE__ */ __name(({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " "), "leave")
  },
  ScalarTypeExtension: {
    leave: /* @__PURE__ */ __name(({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " "), "leave")
  },
  ObjectTypeExtension: {
    leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
  },
  InterfaceTypeExtension: {
    leave: /* @__PURE__ */ __name(({ name, interfaces, directives, fields }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " "), "leave")
  },
  UnionTypeExtension: {
    leave: /* @__PURE__ */ __name(({ name, directives, types: types3 }) => join(["extend union", name, join(directives, " "), wrap("= ", join(types3, " | "))], " "), "leave")
  },
  EnumTypeExtension: {
    leave: /* @__PURE__ */ __name(({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " "), "leave")
  },
  InputObjectTypeExtension: {
    leave: /* @__PURE__ */ __name(({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " "), "leave")
  }
};
var printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({
  ...prev,
  [key]: {
    leave: addDescription(printDocASTReducer[key].leave)
  }
}), {});
function printWithComments(ast) {
  return (0, import_graphql15.visit)(ast, printDocASTReducerWithComments);
}
__name(printWithComments, "printWithComments");
function isFieldDefinitionNode(node) {
  return node.kind === "FieldDefinition";
}
__name(isFieldDefinitionNode, "isFieldDefinitionNode");
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== void 0) {
    return dedentBlockStringValue(`
${rawValue}`);
  }
}
__name(getComment, "getComment");
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === import_graphql15.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
__name(getLeadingCommentBlock, "getLeadingCommentBlock");
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
__name(dedentBlockStringValue, "dedentBlockStringValue");
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    if (commonIndent === null || indent2 < commonIndent) {
      commonIndent = indent2;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
__name(getBlockStringIndentation, "getBlockStringIndentation");
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && (str[i] === " " || str[i] === "	")) {
    i++;
  }
  return i;
}
__name(leadingWhitespace, "leadingWhitespace");
function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
__name(isBlank, "isBlank");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/mergeDeep.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function mergeDeep(sources, respectPrototype = false) {
  const target = sources[0] || {};
  const output = {};
  if (respectPrototype) {
    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
  }
  for (const source of sources) {
    if (isObject(target) && isObject(source)) {
      if (respectPrototype) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source) {
        if (isObject(source[key])) {
          if (!(key in output)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep([output[key], source[key]], respectPrototype);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      }
    }
  }
  return output;
}
__name(mergeDeep, "mergeDeep");
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
__name(isObject, "isObject");

// ../node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/esm/isDocumentNode.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql16 = __toESM(require_graphql2(), 1);
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === import_graphql16.Kind.DOCUMENT;
}
__name(isDocumentNode, "isDocumentNode");

// ../node_modules/@graphql-tools/merge/esm/merge-resolvers.js
function mergeResolvers(resolversDefinitions, options) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers2 = new Array();
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers2.push(resolversDefinition);
    }
  }
  const result = mergeDeep(resolvers2, true);
  if (options === null || options === void 0 ? void 0 : options.exclusions) {
    for (const exclusion of options.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (!fieldName || fieldName === "*") {
        delete result[typeName];
      } else if (result[typeName]) {
        delete result[typeName][fieldName];
      }
    }
  }
  return result;
}
__name(mergeResolvers, "mergeResolvers");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function mergeArguments(args1, args2, config2) {
  const result = deduplicateArguments([...args2, ...args1].filter(isSome), config2);
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}
__name(mergeArguments, "mergeArguments");
function deduplicateArguments(args, config2) {
  return args.reduce((acc, current) => {
    const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
    if (dupIndex === -1) {
      return acc.concat([current]);
    } else if (!(config2 === null || config2 === void 0 ? void 0 : config2.reverseArguments)) {
      acc[dupIndex] = current;
    }
    return acc;
  }, []);
}
__name(deduplicateArguments, "deduplicateArguments");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql17 = __toESM(require_graphql2(), 1);
function directiveAlreadyExists(directivesArr, otherDirective) {
  return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
}
__name(directiveAlreadyExists, "directiveAlreadyExists");
function isRepeatableDirective(directive, directives) {
  var _a;
  return !!((_a = directives === null || directives === void 0 ? void 0 : directives[directive.name.value]) === null || _a === void 0 ? void 0 : _a.repeatable);
}
__name(isRepeatableDirective, "isRepeatableDirective");
function nameAlreadyExists(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
}
__name(nameAlreadyExists, "nameAlreadyExists");
function mergeArguments2(a1, a2) {
  const result = [...a2];
  for (const argument of a1) {
    const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
          const value = targetVal.value;
          return !value || !source2.some((sourceVal) => sourceVal.value === value);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result.push(argument);
    }
  }
  return result;
}
__name(mergeArguments2, "mergeArguments");
function deduplicateDirectives(directives, definitions) {
  return directives.map((directive, i, all) => {
    const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
    if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
      const dup = all[firstAt];
      directive.arguments = mergeArguments2(directive.arguments, dup.arguments);
      return null;
    }
    return directive;
  }).filter(isSome);
}
__name(deduplicateDirectives, "deduplicateDirectives");
function mergeDirectives(d1 = [], d2 = [], config2, directives) {
  const reverseOrder = config2 && config2.reverseDirectives;
  const asNext = reverseOrder ? d1 : d2;
  const asFirst = reverseOrder ? d2 : d1;
  const result = deduplicateDirectives([...asNext], directives);
  for (const directive of asFirst) {
    if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {
      const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
      const existingDirective = result[existingDirectiveIndex];
      result[existingDirectiveIndex].arguments = mergeArguments2(directive.arguments || [], existingDirective.arguments || []);
    } else {
      result.push(directive);
    }
  }
  return result;
}
__name(mergeDirectives, "mergeDirectives");
function validateInputs(node, existingNode) {
  const printedNode = (0, import_graphql17.print)({
    ...node,
    description: void 0
  });
  const printedExistingNode = (0, import_graphql17.print)({
    ...existingNode,
    description: void 0
  });
  const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
  const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
  if (!sameArguments) {
    throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
  }
}
__name(validateInputs, "validateInputs");
function mergeDirective(node, existingNode) {
  if (existingNode) {
    validateInputs(node, existingNode);
    return {
      ...node,
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    };
  }
  return node;
}
__name(mergeDirective, "mergeDirective");
function deduplicateLists(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
}
__name(deduplicateLists, "deduplicateLists");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function mergeEnumValues(first, second, config2, directives) {
  if (config2 === null || config2 === void 0 ? void 0 : config2.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = /* @__PURE__ */ new Map();
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives, directives);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}
__name(mergeEnumValues, "mergeEnumValues");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql18 = __toESM(require_graphql2(), 1);
function mergeEnum(e1, e2, config2, directives) {
  if (e2) {
    return {
      name: e1.name,
      description: e1["description"] || e2["description"],
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e2.directives, config2, directives),
      values: mergeEnumValues(e1.values, e2.values, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...e1,
    kind: import_graphql18.Kind.ENUM_TYPE_DEFINITION
  } : e1;
}
__name(mergeEnum, "mergeEnum");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql19 = __toESM(require_graphql2(), 1);
function isStringTypes(types3) {
  return typeof types3 === "string";
}
__name(isStringTypes, "isStringTypes");
function isSourceTypes(types3) {
  return types3 instanceof import_graphql19.Source;
}
__name(isSourceTypes, "isSourceTypes");
function extractType(type2) {
  let visitedType = type2;
  while (visitedType.kind === import_graphql19.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
__name(extractType, "extractType");
function isWrappingTypeNode(type2) {
  return type2.kind !== import_graphql19.Kind.NAMED_TYPE;
}
__name(isWrappingTypeNode, "isWrappingTypeNode");
function isListTypeNode(type2) {
  return type2.kind === import_graphql19.Kind.LIST_TYPE;
}
__name(isListTypeNode, "isListTypeNode");
function isNonNullTypeNode(type2) {
  return type2.kind === import_graphql19.Kind.NON_NULL_TYPE;
}
__name(isNonNullTypeNode, "isNonNullTypeNode");
function printTypeNode(type2) {
  if (isListTypeNode(type2)) {
    return `[${printTypeNode(type2.type)}]`;
  }
  if (isNonNullTypeNode(type2)) {
    return `${printTypeNode(type2.type)}!`;
  }
  return type2.name.value;
}
__name(printTypeNode, "printTypeNode");
var CompareVal;
(function(CompareVal2) {
  CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal || (CompareVal = {}));
function defaultStringComparator(a, b) {
  if (a == null && b == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a < b)
    return CompareVal.A_SMALLER_THAN_B;
  if (a > b)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}
__name(defaultStringComparator, "defaultStringComparator");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
function fieldAlreadyExists(fieldsArr, otherField) {
  const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
  return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
}
__name(fieldAlreadyExists, "fieldAlreadyExists");
function mergeFields(type2, f1, f2, config2, directives) {
  const result = [];
  if (f2 != null) {
    result.push(...f2);
  }
  if (f1 != null) {
    for (const field of f1) {
      const [existing, existingIndex] = fieldAlreadyExists(result, field);
      if (existing && !(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
        const newField = (config2 === null || config2 === void 0 ? void 0 : config2.onFieldTypeConflict) && config2.onFieldTypeConflict(existing, field, type2, config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict) || preventConflicts(type2, existing, field, config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict);
        newField.arguments = mergeArguments(field["arguments"] || [], existing["arguments"] || [], config2);
        newField.directives = mergeDirectives(field.directives, existing.directives, config2, directives);
        newField.description = field.description || existing.description;
        result[existingIndex] = newField;
      } else {
        result.push(field);
      }
    }
  }
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  if (config2 && config2.exclusions) {
    const exclusions = config2.exclusions;
    return result.filter((field) => !exclusions.includes(`${type2.name.value}.${field.name.value}`));
  }
  return result;
}
__name(mergeFields, "mergeFields");
function preventConflicts(type2, a, b, ignoreNullability = false) {
  const aType = printTypeNode(a.type);
  const bType = printTypeNode(b.type);
  if (aType !== bType) {
    const t1 = extractType(a.type);
    const t2 = extractType(b.type);
    if (t1.name.value !== t2.name.value) {
      throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
    }
    if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
      throw new Error(`Field '${type2.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  if (isNonNullTypeNode(b.type) && !isNonNullTypeNode(a.type)) {
    a.type = b.type;
  }
  return a;
}
__name(preventConflicts, "preventConflicts");
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
}
__name(safeChangeForFieldType, "safeChangeForFieldType");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql20 = __toESM(require_graphql2(), 1);
function mergeInputType(node, existingNode, config2, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2, directives)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql20.Kind.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}
__name(mergeInputType, "mergeInputType");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql21 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function alreadyExists(arr, other) {
  return !!arr.find((i) => i.name.value === other.name.value);
}
__name(alreadyExists, "alreadyExists");
function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
  const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
  if (config2 && config2.sort) {
    result.sort(compareNodes);
  }
  return result;
}
__name(mergeNamedTypeArray, "mergeNamedTypeArray");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
function mergeInterface(node, existingNode, config2, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2, directives),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config2) : void 0
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql21.Kind.INTERFACE_TYPE_DEFINITION
  } : node;
}
__name(mergeInterface, "mergeInterface");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql26 = __toESM(require_graphql2(), 1);

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql22 = __toESM(require_graphql2(), 1);
function mergeType(node, existingNode, config2, directives) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2, directives),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config2)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql22.Kind.OBJECT_TYPE_DEFINITION
  } : node;
}
__name(mergeType, "mergeType");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql23 = __toESM(require_graphql2(), 1);
function mergeScalar(node, existingNode, config2, directives) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config2, directives)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql23.Kind.SCALAR_TYPE_DEFINITION
  } : node;
}
__name(mergeScalar, "mergeScalar");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql24 = __toESM(require_graphql2(), 1);
function mergeUnion(first, second, config2, directives) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
      directives: mergeDirectives(first.directives, second.directives, config2, directives),
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? import_graphql24.Kind.UNION_TYPE_DEFINITION : import_graphql24.Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...first,
    kind: import_graphql24.Kind.UNION_TYPE_DEFINITION
  } : first;
}
__name(mergeUnion, "mergeUnion");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql25 = __toESM(require_graphql2(), 1);
var DEFAULT_OPERATION_TYPE_NAME_MAP = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
}
__name(mergeOperationTypes, "mergeOperationTypes");
function mergeSchemaDefs(node, existingNode, config2, directives) {
  if (existingNode) {
    return {
      kind: node.kind === import_graphql25.Kind.SCHEMA_DEFINITION || existingNode.kind === import_graphql25.Kind.SCHEMA_DEFINITION ? import_graphql25.Kind.SCHEMA_DEFINITION : import_graphql25.Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config2, directives),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? {
    ...node,
    kind: import_graphql25.Kind.SCHEMA_DEFINITION
  } : node;
}
__name(mergeSchemaDefs, "mergeSchemaDefs");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
__name(isNamedDefinitionNode, "isNamedDefinitionNode");
function mergeGraphQLNodes(nodes, config2, directives = {}) {
  var _a, _b, _c;
  const mergedResultMap = directives;
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = (_a = nodeDefinition.name) === null || _a === void 0 ? void 0 : _a.value;
      if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (((_b = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case import_graphql26.Kind.OBJECT_TYPE_DEFINITION:
          case import_graphql26.Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql26.Kind.ENUM_TYPE_DEFINITION:
          case import_graphql26.Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql26.Kind.UNION_TYPE_DEFINITION:
          case import_graphql26.Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql26.Kind.SCALAR_TYPE_DEFINITION:
          case import_graphql26.Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql26.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case import_graphql26.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql26.Kind.INTERFACE_TYPE_DEFINITION:
          case import_graphql26.Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config2, directives);
            break;
          case import_graphql26.Kind.DIRECTIVE_DEFINITION:
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === import_graphql26.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === import_graphql26.Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config2);
    }
  }
  return mergedResultMap;
}
__name(mergeGraphQLNodes, "mergeGraphQLNodes");

// ../node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql27 = __toESM(require_graphql2(), 1);
function mergeTypeDefs(typeSource, config2) {
  resetComments();
  const doc = {
    kind: import_graphql27.Kind.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config2
    })
  };
  let result;
  if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
    result = printWithComments(doc);
  } else {
    result = doc;
  }
  resetComments();
  return result;
}
__name(mergeTypeDefs, "mergeTypeDefs");
function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type2 of typeSource) {
        visitTypeSources(type2, options, allDirectives, allNodes, visitedTypeSources);
      }
    } else if ((0, import_graphql27.isSchema)(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = (0, import_graphql27.parse)(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && (0, import_graphql27.isDefinitionNode)(typeSource)) {
      if (typeSource.kind === import_graphql27.Kind.DIRECTIVE_DEFINITION) {
        allDirectives.push(typeSource);
      } else {
        allNodes.push(typeSource);
      }
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return { allDirectives, allNodes };
}
__name(visitTypeSources, "visitTypeSources");
function mergeGraphQLTypes(typeSource, config2) {
  var _a, _b, _c;
  resetComments();
  const { allDirectives, allNodes } = visitTypeSources(typeSource, config2);
  const mergedDirectives = mergeGraphQLNodes(allDirectives, config2);
  const mergedNodes = mergeGraphQLNodes(allNodes, config2, mergedDirectives);
  if (config2 === null || config2 === void 0 ? void 0 : config2.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: import_graphql27.Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: import_graphql27.Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: import_graphql27.Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if ((config2 === null || config2 === void 0 ? void 0 : config2.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
    mergedNodes[schemaDefSymbol] = {
      kind: import_graphql27.Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: import_graphql27.Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: import_graphql27.Kind.NAMED_TYPE,
            name: {
              kind: import_graphql27.Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config2 === null || config2 === void 0 ? void 0 : config2.sort) {
    const sortFn = typeof config2.sort === "function" ? config2.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a, b) => {
      var _a2, _b2;
      return sortFn((_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
    });
  }
  return mergedNodeDefinitions;
}
__name(mergeGraphQLTypes, "mergeGraphQLTypes");

// ../node_modules/@graphql-tools/merge/esm/extensions.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function mergeExtensions(extensions) {
  return mergeDeep(extensions);
}
__name(mergeExtensions, "mergeExtensions");
function applyExtensionObject(obj, extensions) {
  if (!obj) {
    return;
  }
  obj.extensions = mergeDeep([obj.extensions || {}, extensions || {}]);
}
__name(applyExtensionObject, "applyExtensionObject");
function applyExtensions(schema, extensions) {
  applyExtensionObject(schema, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type2 = schema.getType(typeName);
    if (type2) {
      applyExtensionObject(type2, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a) => a.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value = type2.getValue(valueName);
          applyExtensionObject(value, valueData);
        }
      }
    }
  }
  return schema;
}
__name(applyExtensions, "applyExtensions");

// ../node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
function makeExecutableSchema({ typeDefs: typeDefs2, resolvers: resolvers2 = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs2) {
    throw new Error("Must provide typeDefs");
  }
  let schema;
  if ((0, import_graphql28.isSchema)(typeDefs2)) {
    schema = typeDefs2;
  } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs2, {
      ...otherOptions,
      commentDescriptions: true
    });
    schema = (0, import_graphql28.buildSchema)(mergedTypeDefs, otherOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs2, otherOptions);
    schema = (0, import_graphql28.buildASTSchema)(mergedTypeDefs, otherOptions);
  }
  schema = addResolversToSchema({
    schema,
    resolvers: mergeResolvers(resolvers2),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema, resolverValidationOptions);
  }
  if (schemaExtensions) {
    schemaExtensions = mergeExtensions(asArray(schemaExtensions));
    applyExtensions(schema, schemaExtensions);
  }
  return schema;
}
__name(makeExecutableSchema, "makeExecutableSchema");

// ../node_modules/@apollo/server/dist/esm/utils/resolvable.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var resolvable_default = /* @__PURE__ */ __name(() => {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
}, "default");

// ../node_modules/@apollo/server/dist/esm/ApolloServer.js
var import_graphql42 = __toESM(require_graphql2(), 1);
var import_loglevel = __toESM(require_loglevel(), 1);
var import_negotiator2 = __toESM(require_negotiator(), 1);
init_cachePolicy();

// ../node_modules/@apollo/server/dist/esm/determineApolloConfig.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_utils21 = __toESM(require_dist3(), 1);
function determineApolloConfig(input, logger) {
  const apolloConfig = {};
  const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT } = process.env;
  if (input?.key) {
    apolloConfig.key = input.key.trim();
  } else if (APOLLO_KEY) {
    apolloConfig.key = APOLLO_KEY.trim();
  }
  if ((input?.key ?? APOLLO_KEY) !== apolloConfig.key) {
    logger.warn("The provided API key has unexpected leading or trailing whitespace. Apollo Server will trim the key value before use.");
  }
  if (apolloConfig.key) {
    assertValidHeaderValue(apolloConfig.key);
  }
  if (apolloConfig.key) {
    apolloConfig.keyHash = (0, import_utils21.createHash)("sha512").update(apolloConfig.key).digest("hex");
  }
  if (input?.graphRef) {
    apolloConfig.graphRef = input.graphRef;
  } else if (APOLLO_GRAPH_REF) {
    apolloConfig.graphRef = APOLLO_GRAPH_REF;
  }
  const graphId = input?.graphId ?? APOLLO_GRAPH_ID;
  const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;
  if (apolloConfig.graphRef) {
    if (graphId) {
      throw new Error("Cannot specify both graph ref and graph ID. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.");
    }
    if (graphVariant) {
      throw new Error("Cannot specify both graph ref and graph variant. Please use `apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.");
    }
  } else if (graphId) {
    apolloConfig.graphRef = graphVariant ? `${graphId}@${graphVariant}` : graphId;
  }
  return apolloConfig;
}
__name(determineApolloConfig, "determineApolloConfig");
function assertValidHeaderValue(value) {
  const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
  if (invalidHeaderCharRegex.test(value)) {
    const invalidChars = value.match(invalidHeaderCharRegex);
    throw new Error(`The API key provided to Apollo Server contains characters which are invalid as HTTP header values. The following characters found in the key are invalid: ${invalidChars.join(", ")}. Valid header values may only contain ASCII visible characters. If you think there is an issue with your key, please contact Apollo support.`);
  }
}
__name(assertValidHeaderValue, "assertValidHeaderValue");

// ../node_modules/@apollo/server/dist/esm/errorNormalize.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql31 = __toESM(require_graphql2(), 1);

// ../node_modules/@apollo/server/dist/esm/errors/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ApolloServerErrorCode;
(function(ApolloServerErrorCode2) {
  ApolloServerErrorCode2["INTERNAL_SERVER_ERROR"] = "INTERNAL_SERVER_ERROR";
  ApolloServerErrorCode2["GRAPHQL_PARSE_FAILED"] = "GRAPHQL_PARSE_FAILED";
  ApolloServerErrorCode2["GRAPHQL_VALIDATION_FAILED"] = "GRAPHQL_VALIDATION_FAILED";
  ApolloServerErrorCode2["PERSISTED_QUERY_NOT_FOUND"] = "PERSISTED_QUERY_NOT_FOUND";
  ApolloServerErrorCode2["PERSISTED_QUERY_NOT_SUPPORTED"] = "PERSISTED_QUERY_NOT_SUPPORTED";
  ApolloServerErrorCode2["BAD_USER_INPUT"] = "BAD_USER_INPUT";
  ApolloServerErrorCode2["OPERATION_RESOLUTION_FAILURE"] = "OPERATION_RESOLUTION_FAILURE";
  ApolloServerErrorCode2["BAD_REQUEST"] = "BAD_REQUEST";
})(ApolloServerErrorCode || (ApolloServerErrorCode = {}));
var ApolloServerValidationErrorCode;
(function(ApolloServerValidationErrorCode2) {
  ApolloServerValidationErrorCode2["INTROSPECTION_DISABLED"] = "INTROSPECTION_DISABLED";
  ApolloServerValidationErrorCode2["MAX_RECURSIVE_SELECTIONS_EXCEEDED"] = "MAX_RECURSIVE_SELECTIONS_EXCEEDED";
})(ApolloServerValidationErrorCode || (ApolloServerValidationErrorCode = {}));

// ../node_modules/@apollo/server/dist/esm/runHttpQuery.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql30 = __toESM(require_graphql2(), 1);

// ../node_modules/@apollo/server/dist/esm/internalErrorClasses.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql29 = __toESM(require_graphql2(), 1);

// ../node_modules/@apollo/server/dist/esm/utils/HeaderMap.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HeaderMap = class extends Map {
  static {
    __name(this, "HeaderMap");
  }
  constructor() {
    super(...arguments);
    this.__identity = Symbol("HeaderMap");
  }
  set(key, value) {
    return super.set(key.toLowerCase(), value);
  }
  get(key) {
    return super.get(key.toLowerCase());
  }
  delete(key) {
    return super.delete(key.toLowerCase());
  }
  has(key) {
    return super.has(key.toLowerCase());
  }
};

// ../node_modules/@apollo/server/dist/esm/internalErrorClasses.js
var GraphQLErrorWithCode = class extends import_graphql29.GraphQLError {
  static {
    __name(this, "GraphQLErrorWithCode");
  }
  constructor(message, code, options) {
    super(message, {
      ...options,
      extensions: { ...options?.extensions, code }
    });
    this.name = this.constructor.name;
  }
};
var SyntaxError = class extends GraphQLErrorWithCode {
  static {
    __name(this, "SyntaxError");
  }
  constructor(graphqlError) {
    super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {
      source: graphqlError.source,
      positions: graphqlError.positions,
      extensions: { http: newHTTPGraphQLHead(400), ...graphqlError.extensions },
      originalError: graphqlError
    });
  }
};
var ValidationError = class extends GraphQLErrorWithCode {
  static {
    __name(this, "ValidationError");
  }
  constructor(graphqlError) {
    super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED, {
      nodes: graphqlError.nodes,
      extensions: {
        http: newHTTPGraphQLHead(400),
        ...graphqlError.extensions
      },
      originalError: graphqlError.originalError ?? graphqlError
    });
  }
};
var getPersistedQueryErrorHttp = /* @__PURE__ */ __name(() => ({
  status: 200,
  headers: new HeaderMap([
    ["cache-control", "private, no-cache, must-revalidate"]
  ])
}), "getPersistedQueryErrorHttp");
var PersistedQueryNotFoundError = class extends GraphQLErrorWithCode {
  static {
    __name(this, "PersistedQueryNotFoundError");
  }
  constructor() {
    super("PersistedQueryNotFound", ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND, { extensions: { http: getPersistedQueryErrorHttp() } });
  }
};
var PersistedQueryNotSupportedError = class extends GraphQLErrorWithCode {
  static {
    __name(this, "PersistedQueryNotSupportedError");
  }
  constructor() {
    super("PersistedQueryNotSupported", ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED, { extensions: { http: getPersistedQueryErrorHttp() } });
  }
};
var UserInputError = class extends GraphQLErrorWithCode {
  static {
    __name(this, "UserInputError");
  }
  constructor(graphqlError) {
    super(graphqlError.message, ApolloServerErrorCode.BAD_USER_INPUT, {
      nodes: graphqlError.nodes,
      originalError: graphqlError.originalError ?? graphqlError,
      extensions: graphqlError.extensions
    });
  }
};
var OperationResolutionError = class extends GraphQLErrorWithCode {
  static {
    __name(this, "OperationResolutionError");
  }
  constructor(graphqlError) {
    super(graphqlError.message, ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE, {
      nodes: graphqlError.nodes,
      originalError: graphqlError.originalError ?? graphqlError,
      extensions: {
        http: newHTTPGraphQLHead(400),
        ...graphqlError.extensions
      }
    });
  }
};
var BadRequestError = class extends GraphQLErrorWithCode {
  static {
    __name(this, "BadRequestError");
  }
  constructor(message, options) {
    super(message, ApolloServerErrorCode.BAD_REQUEST, {
      ...options,
      extensions: { http: newHTTPGraphQLHead(400), ...options?.extensions }
    });
  }
};

// ../node_modules/@apollo/server/dist/esm/runHttpQuery.js
var import_negotiator = __toESM(require_negotiator(), 1);
function fieldIfString(o, fieldName) {
  const value = o[fieldName];
  if (typeof value === "string") {
    return value;
  }
  return void 0;
}
__name(fieldIfString, "fieldIfString");
function searchParamIfSpecifiedOnce(searchParams, paramName) {
  const values = searchParams.getAll(paramName);
  switch (values.length) {
    case 0:
      return void 0;
    case 1:
      return values[0];
    default:
      throw new BadRequestError(`The '${paramName}' search parameter may only be specified once.`);
  }
}
__name(searchParamIfSpecifiedOnce, "searchParamIfSpecifiedOnce");
function jsonParsedSearchParamIfSpecifiedOnce(searchParams, fieldName) {
  const value = searchParamIfSpecifiedOnce(searchParams, fieldName);
  if (value === void 0) {
    return void 0;
  }
  let hopefullyRecord;
  try {
    hopefullyRecord = JSON.parse(value);
  } catch {
    throw new BadRequestError(`The ${fieldName} search parameter contains invalid JSON.`);
  }
  if (!isStringRecord(hopefullyRecord)) {
    throw new BadRequestError(`The ${fieldName} search parameter should contain a JSON-encoded object.`);
  }
  return hopefullyRecord;
}
__name(jsonParsedSearchParamIfSpecifiedOnce, "jsonParsedSearchParamIfSpecifiedOnce");
function fieldIfRecord(o, fieldName) {
  const value = o[fieldName];
  if (isStringRecord(value)) {
    return value;
  }
  return void 0;
}
__name(fieldIfRecord, "fieldIfRecord");
function isStringRecord(o) {
  return !!o && typeof o === "object" && !Buffer.isBuffer(o) && !Array.isArray(o);
}
__name(isStringRecord, "isStringRecord");
function isNonEmptyStringRecord(o) {
  return isStringRecord(o) && Object.keys(o).length > 0;
}
__name(isNonEmptyStringRecord, "isNonEmptyStringRecord");
function ensureQueryIsStringOrMissing(query) {
  if (!query || typeof query === "string") {
    return;
  }
  if (query.kind === import_graphql30.Kind.DOCUMENT) {
    throw new BadRequestError("GraphQL queries must be strings. It looks like you're sending the internal graphql-js representation of a parsed query in your request instead of a request in the GraphQL query language. You can convert an AST to a string using the `print` function from `graphql`, or use a client like `apollo-client` which converts the internal representation to a string for you.");
  } else {
    throw new BadRequestError("GraphQL queries must be strings.");
  }
}
__name(ensureQueryIsStringOrMissing, "ensureQueryIsStringOrMissing");
async function runHttpQuery({ server, httpRequest, contextValue, schemaDerivedData, internals, sharedResponseHTTPGraphQLHead }) {
  let graphQLRequest;
  switch (httpRequest.method) {
    case "POST": {
      if (!isNonEmptyStringRecord(httpRequest.body)) {
        throw new BadRequestError("POST body missing, invalid Content-Type, or JSON object has no keys.");
      }
      ensureQueryIsStringOrMissing(httpRequest.body.query);
      if (typeof httpRequest.body.variables === "string") {
        throw new BadRequestError("`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.");
      }
      if (typeof httpRequest.body.extensions === "string") {
        throw new BadRequestError("`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.");
      }
      if ("extensions" in httpRequest.body && httpRequest.body.extensions !== null && !isStringRecord(httpRequest.body.extensions)) {
        throw new BadRequestError("`extensions` in a POST body must be an object if provided.");
      }
      if ("variables" in httpRequest.body && httpRequest.body.variables !== null && !isStringRecord(httpRequest.body.variables)) {
        throw new BadRequestError("`variables` in a POST body must be an object if provided.");
      }
      if ("operationName" in httpRequest.body && httpRequest.body.operationName !== null && typeof httpRequest.body.operationName !== "string") {
        throw new BadRequestError("`operationName` in a POST body must be a string if provided.");
      }
      graphQLRequest = {
        query: fieldIfString(httpRequest.body, "query"),
        operationName: fieldIfString(httpRequest.body, "operationName"),
        variables: fieldIfRecord(httpRequest.body, "variables"),
        extensions: fieldIfRecord(httpRequest.body, "extensions"),
        http: httpRequest
      };
      break;
    }
    case "GET": {
      const searchParams = new URLSearchParams(httpRequest.search);
      graphQLRequest = {
        query: searchParamIfSpecifiedOnce(searchParams, "query"),
        operationName: searchParamIfSpecifiedOnce(searchParams, "operationName"),
        variables: jsonParsedSearchParamIfSpecifiedOnce(searchParams, "variables"),
        extensions: jsonParsedSearchParamIfSpecifiedOnce(searchParams, "extensions"),
        http: httpRequest
      };
      break;
    }
    default:
      throw new BadRequestError("Apollo Server supports only GET/POST requests.", {
        extensions: {
          http: {
            status: 405,
            headers: new HeaderMap([["allow", "GET, POST"]])
          }
        }
      });
  }
  const graphQLResponse = await internalExecuteOperation({
    server,
    graphQLRequest,
    internals,
    schemaDerivedData,
    sharedResponseHTTPGraphQLHead
  }, { contextValue });
  if (graphQLResponse.body.kind === "single") {
    if (!graphQLResponse.http.headers.get("content-type")) {
      const contentType = chooseContentTypeForSingleResultResponse(httpRequest);
      if (contentType === null) {
        throw new BadRequestError(`An 'accept' header was provided for this request which does not accept ${MEDIA_TYPES.APPLICATION_JSON} or ${MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`, { extensions: { http: { status: 406 } } });
      }
      graphQLResponse.http.headers.set("content-type", contentType);
    }
    return {
      ...graphQLResponse.http,
      body: {
        kind: "complete",
        string: await internals.stringifyResult(orderExecutionResultFields(graphQLResponse.body.singleResult))
      }
    };
  }
  const acceptHeader = httpRequest.headers.get("accept");
  if (!(acceptHeader && new import_negotiator.default({
    headers: { accept: httpRequest.headers.get("accept") }
  }).mediaType([
    MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
    MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL
  ]) === MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL)) {
    throw new BadRequestError("Apollo server received an operation that uses incremental delivery (@defer or @stream), but the client does not accept multipart/mixed HTTP responses. To enable incremental delivery support, add the HTTP header 'Accept: multipart/mixed; deferSpec=20220824'.", { extensions: { http: { status: 406 } } });
  }
  graphQLResponse.http.headers.set("content-type", 'multipart/mixed; boundary="-"; deferSpec=20220824');
  return {
    ...graphQLResponse.http,
    body: {
      kind: "chunked",
      asyncIterator: writeMultipartBody(graphQLResponse.body.initialResult, graphQLResponse.body.subsequentResults)
    }
  };
}
__name(runHttpQuery, "runHttpQuery");
async function* writeMultipartBody(initialResult, subsequentResults) {
  yield `\r
---\r
content-type: application/json; charset=utf-8\r
\r
${JSON.stringify(orderInitialIncrementalExecutionResultFields(initialResult))}\r
---${initialResult.hasNext ? "" : "--"}\r
`;
  for await (const result of subsequentResults) {
    yield `content-type: application/json; charset=utf-8\r
\r
${JSON.stringify(orderSubsequentIncrementalExecutionResultFields(result))}\r
---${result.hasNext ? "" : "--"}\r
`;
  }
}
__name(writeMultipartBody, "writeMultipartBody");
function orderExecutionResultFields(result) {
  return {
    errors: result.errors,
    data: result.data,
    extensions: result.extensions
  };
}
__name(orderExecutionResultFields, "orderExecutionResultFields");
function orderInitialIncrementalExecutionResultFields(result) {
  return {
    hasNext: result.hasNext,
    errors: result.errors,
    data: result.data,
    incremental: orderIncrementalResultFields(result.incremental),
    extensions: result.extensions
  };
}
__name(orderInitialIncrementalExecutionResultFields, "orderInitialIncrementalExecutionResultFields");
function orderSubsequentIncrementalExecutionResultFields(result) {
  return {
    hasNext: result.hasNext,
    incremental: orderIncrementalResultFields(result.incremental),
    extensions: result.extensions
  };
}
__name(orderSubsequentIncrementalExecutionResultFields, "orderSubsequentIncrementalExecutionResultFields");
function orderIncrementalResultFields(incremental) {
  return incremental?.map((i) => ({
    hasNext: i.hasNext,
    errors: i.errors,
    path: i.path,
    label: i.label,
    data: i.data,
    items: i.items,
    extensions: i.extensions
  }));
}
__name(orderIncrementalResultFields, "orderIncrementalResultFields");
function prettyJSONStringify(value) {
  return JSON.stringify(value) + "\n";
}
__name(prettyJSONStringify, "prettyJSONStringify");
function newHTTPGraphQLHead(status) {
  return {
    status,
    headers: new HeaderMap()
  };
}
__name(newHTTPGraphQLHead, "newHTTPGraphQLHead");
function mergeHTTPGraphQLHead(target, source) {
  if (source.status) {
    target.status = source.status;
  }
  if (source.headers) {
    for (const [name, value] of source.headers) {
      target.headers.set(name, value);
    }
  }
}
__name(mergeHTTPGraphQLHead, "mergeHTTPGraphQLHead");

// ../node_modules/@apollo/server/dist/esm/errorNormalize.js
function normalizeAndFormatErrors(errors, options = {}) {
  const formatError2 = options.formatError ?? ((error3) => error3);
  const httpFromErrors = newHTTPGraphQLHead();
  return {
    httpFromErrors,
    formattedErrors: errors.map((error3) => {
      try {
        return formatError2(enrichError(error3), error3);
      } catch (formattingError) {
        if (options.includeStacktraceInErrorResponses) {
          return enrichError(formattingError);
        } else {
          return {
            message: "Internal server error",
            extensions: { code: ApolloServerErrorCode.INTERNAL_SERVER_ERROR }
          };
        }
      }
    })
  };
  function enrichError(maybeError) {
    const graphqlError = ensureGraphQLError(maybeError);
    const extensions = {
      ...graphqlError.extensions,
      code: graphqlError.extensions.code ?? ApolloServerErrorCode.INTERNAL_SERVER_ERROR
    };
    if (isPartialHTTPGraphQLHead(extensions.http)) {
      mergeHTTPGraphQLHead(httpFromErrors, {
        headers: new HeaderMap(),
        ...extensions.http
      });
      delete extensions.http;
    }
    if (options.includeStacktraceInErrorResponses) {
      extensions.stacktrace = graphqlError.stack?.split("\n");
    }
    return { ...graphqlError.toJSON(), extensions };
  }
  __name(enrichError, "enrichError");
}
__name(normalizeAndFormatErrors, "normalizeAndFormatErrors");
function ensureError(maybeError) {
  return maybeError instanceof Error ? maybeError : new import_graphql31.GraphQLError("Unexpected error value: " + String(maybeError));
}
__name(ensureError, "ensureError");
function ensureGraphQLError(maybeError, messagePrefixIfNotGraphQLError = "") {
  const error3 = ensureError(maybeError);
  return error3 instanceof import_graphql31.GraphQLError ? error3 : new import_graphql31.GraphQLError(messagePrefixIfNotGraphQLError + error3.message, {
    originalError: error3
  });
}
__name(ensureGraphQLError, "ensureGraphQLError");
function isPartialHTTPGraphQLHead(x) {
  return !!x && typeof x === "object" && (!("status" in x) || typeof x.status === "number") && (!("headers" in x) || x.headers instanceof Map);
}
__name(isPartialHTTPGraphQLHead, "isPartialHTTPGraphQLHead");

// ../node_modules/@apollo/server/dist/esm/httpBatching.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function runBatchedHttpQuery({ server, batchRequest, body, contextValue, schemaDerivedData, internals }) {
  if (body.length === 0) {
    throw new BadRequestError("No operations found in request.");
  }
  const sharedResponseHTTPGraphQLHead = newHTTPGraphQLHead();
  const responseBodies = await Promise.all(body.map(async (bodyPiece) => {
    const singleRequest = {
      ...batchRequest,
      body: bodyPiece
    };
    const response = await runHttpQuery({
      server,
      httpRequest: singleRequest,
      contextValue,
      schemaDerivedData,
      internals,
      sharedResponseHTTPGraphQLHead
    });
    if (response.body.kind === "chunked") {
      throw Error("Incremental delivery is not implemented for batch requests");
    }
    return response.body.string;
  }));
  return {
    ...sharedResponseHTTPGraphQLHead,
    body: { kind: "complete", string: `[${responseBodies.join(",")}]` }
  };
}
__name(runBatchedHttpQuery, "runBatchedHttpQuery");
async function runPotentiallyBatchedHttpQuery(server, httpGraphQLRequest, contextValue, schemaDerivedData, internals) {
  if (!(httpGraphQLRequest.method === "POST" && Array.isArray(httpGraphQLRequest.body))) {
    return await runHttpQuery({
      server,
      httpRequest: httpGraphQLRequest,
      contextValue,
      schemaDerivedData,
      internals,
      sharedResponseHTTPGraphQLHead: null
    });
  }
  if (internals.allowBatchedHttpRequests) {
    return await runBatchedHttpQuery({
      server,
      batchRequest: httpGraphQLRequest,
      body: httpGraphQLRequest.body,
      contextValue,
      schemaDerivedData,
      internals
    });
  }
  throw new BadRequestError("Operation batching disabled.");
}
__name(runPotentiallyBatchedHttpQuery, "runPotentiallyBatchedHttpQuery");

// ../node_modules/@apollo/server/dist/esm/ApolloServer.js
init_internalPlugin();

// ../node_modules/@apollo/server/dist/esm/preventCsrf.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_whatwg_mimetype = __toESM(require_mime_type(), 1);
var recommendedCsrfPreventionRequestHeaders = [
  "x-apollo-operation-name",
  "apollo-require-preflight"
];
var NON_PREFLIGHTED_CONTENT_TYPES = [
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
];
function preventCsrf(headers, csrfPreventionRequestHeaders) {
  const contentType = headers.get("content-type");
  if (contentType !== void 0) {
    const contentTypeParsed = import_whatwg_mimetype.default.parse(contentType);
    if (contentTypeParsed === null) {
      return;
    }
    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
      return;
    }
  }
  if (csrfPreventionRequestHeaders.some((header) => {
    const value = headers.get(header);
    return value !== void 0 && value.length > 0;
  })) {
    return;
  }
  throw new BadRequestError(`This operation has been blocked as a potential Cross-Site Request Forgery (CSRF). Please either specify a 'content-type' header (with a type that is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(", ")}) or provide a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(", ")}
`);
}
__name(preventCsrf, "preventCsrf");

// ../node_modules/@apollo/server/dist/esm/requestPipeline.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_utils22 = __toESM(require_dist3(), 1);
var import_graphql34 = __toESM(require_graphql2(), 1);

// ../node_modules/@apollo/server/dist/esm/utils/schemaInstrumentation.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql32 = __toESM(require_graphql2(), 1);
var symbolExecutionDispatcherWillResolveField = Symbol("apolloServerExecutionDispatcherWillResolveField");
var symbolUserFieldResolver = Symbol("apolloServerUserFieldResolver");
var symbolPluginsEnabled = Symbol("apolloServerPluginsEnabled");
function enablePluginsForSchemaResolvers(schema) {
  if (pluginsEnabledForSchemaResolvers(schema)) {
    return schema;
  }
  Object.defineProperty(schema, symbolPluginsEnabled, {
    value: true
  });
  const typeMap = schema.getTypeMap();
  Object.values(typeMap).forEach((type2) => {
    if (!(0, import_graphql32.getNamedType)(type2).name.startsWith("__") && type2 instanceof import_graphql32.GraphQLObjectType) {
      const fields = type2.getFields();
      Object.values(fields).forEach((field) => {
        wrapField(field);
      });
    }
  });
  return schema;
}
__name(enablePluginsForSchemaResolvers, "enablePluginsForSchemaResolvers");
function pluginsEnabledForSchemaResolvers(schema) {
  return !!schema[symbolPluginsEnabled];
}
__name(pluginsEnabledForSchemaResolvers, "pluginsEnabledForSchemaResolvers");
function wrapField(field) {
  const originalFieldResolve = field.resolve;
  field.resolve = (source, args, contextValue, info3) => {
    const willResolveField = contextValue?.[symbolExecutionDispatcherWillResolveField];
    const userFieldResolver = contextValue?.[symbolUserFieldResolver];
    const didResolveField = typeof willResolveField === "function" && willResolveField({ source, args, contextValue, info: info3 });
    const fieldResolver = originalFieldResolve || userFieldResolver || import_graphql32.defaultFieldResolver;
    try {
      const result = fieldResolver(source, args, contextValue, info3);
      if (typeof didResolveField === "function") {
        whenResultIsFinished(result, didResolveField);
      }
      return result;
    } catch (error3) {
      if (typeof didResolveField === "function") {
        didResolveField(error3);
      }
      throw error3;
    }
  };
}
__name(wrapField, "wrapField");
function isPromise(x) {
  return x && typeof x.then === "function";
}
__name(isPromise, "isPromise");
function whenResultIsFinished(result, callback) {
  if (isPromise(result)) {
    result.then((r) => whenResultIsFinished(r, callback), (err) => callback(err));
  } else if (Array.isArray(result)) {
    if (result.some(isPromise)) {
      Promise.all(result).then((r) => callback(null, r), (err) => callback(err));
    } else {
      callback(null, result);
    }
  } else {
    callback(null, result);
  }
}
__name(whenResultIsFinished, "whenResultIsFinished");

// ../node_modules/@apollo/server/dist/esm/utils/invokeHooks.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@apollo/server/dist/esm/utils/isDefined.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isDefined(t) {
  return t != null;
}
__name(isDefined, "isDefined");

// ../node_modules/@apollo/server/dist/esm/utils/invokeHooks.js
async function invokeDidStartHook(targets, hook) {
  const didEndHooks = (await Promise.all(targets.map((target) => hook(target)))).filter(isDefined);
  didEndHooks.reverse();
  return async (...args) => {
    for (const didEndHook of didEndHooks) {
      didEndHook(...args);
    }
  };
}
__name(invokeDidStartHook, "invokeDidStartHook");
function invokeSyncDidStartHook(targets, hook) {
  const didEndHooks = targets.map((target) => hook(target)).filter(isDefined);
  didEndHooks.reverse();
  return (...args) => {
    for (const didEndHook of didEndHooks) {
      didEndHook(...args);
    }
  };
}
__name(invokeSyncDidStartHook, "invokeSyncDidStartHook");
async function invokeHooksUntilDefinedAndNonNull(targets, hook) {
  for (const target of targets) {
    const value = await hook(target);
    if (value != null) {
      return value;
    }
  }
  return null;
}
__name(invokeHooksUntilDefinedAndNonNull, "invokeHooksUntilDefinedAndNonNull");

// ../node_modules/@apollo/server/dist/esm/utils/makeGatewayGraphQLRequestContext.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function makeGatewayGraphQLRequestContext(as4RequestContext, server, internals) {
  const request = {};
  if ("query" in as4RequestContext.request) {
    request.query = as4RequestContext.request.query;
  }
  if ("operationName" in as4RequestContext.request) {
    request.operationName = as4RequestContext.request.operationName;
  }
  if ("variables" in as4RequestContext.request) {
    request.variables = as4RequestContext.request.variables;
  }
  if ("extensions" in as4RequestContext.request) {
    request.extensions = as4RequestContext.request.extensions;
  }
  if (as4RequestContext.request.http) {
    const as4http = as4RequestContext.request.http;
    const needQuestion = as4http.search !== "" && !as4http.search.startsWith("?");
    request.http = {
      method: as4http.method,
      url: `https://unknown-url.invalid/${needQuestion ? "?" : ""}${as4http.search}`,
      headers: new FetcherHeadersForHeaderMap(as4http.headers)
    };
  }
  const response = {
    http: {
      headers: new FetcherHeadersForHeaderMap(as4RequestContext.response.http.headers),
      get status() {
        return as4RequestContext.response.http.status;
      },
      set status(newStatus) {
        as4RequestContext.response.http.status = newStatus;
      }
    }
  };
  return {
    request,
    response,
    logger: server.logger,
    schema: as4RequestContext.schema,
    schemaHash: "schemaHash no longer exists in Apollo Server 4",
    context: as4RequestContext.contextValue,
    cache: server.cache,
    queryHash: as4RequestContext.queryHash,
    document: as4RequestContext.document,
    source: as4RequestContext.source,
    operationName: as4RequestContext.operationName,
    operation: as4RequestContext.operation,
    errors: as4RequestContext.errors,
    metrics: as4RequestContext.metrics,
    debug: internals.includeStacktraceInErrorResponses,
    overallCachePolicy: as4RequestContext.overallCachePolicy,
    requestIsBatched: as4RequestContext.requestIsBatched
  };
}
__name(makeGatewayGraphQLRequestContext, "makeGatewayGraphQLRequestContext");
var FetcherHeadersForHeaderMap = class {
  static {
    __name(this, "FetcherHeadersForHeaderMap");
  }
  constructor(map) {
    this.map = map;
  }
  append(name, value) {
    if (this.map.has(name)) {
      this.map.set(name, this.map.get(name) + ", " + value);
    } else {
      this.map.set(name, value);
    }
  }
  delete(name) {
    this.map.delete(name);
  }
  get(name) {
    return this.map.get(name) ?? null;
  }
  has(name) {
    return this.map.has(name);
  }
  set(name, value) {
    this.map.set(name, value);
  }
  entries() {
    return this.map.entries();
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  [Symbol.iterator]() {
    return this.map.entries();
  }
};

// ../node_modules/@apollo/server/dist/esm/incrementalDeliveryPolyfill.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql33 = __toESM(require_graphql2(), 1);
var graphqlExperimentalExecuteIncrementally = void 0;
async function tryToLoadGraphQL17() {
  if (graphqlExperimentalExecuteIncrementally !== void 0) {
    return;
  }
  const graphql = await Promise.resolve().then(() => __toESM(require_graphql2(), 1));
  if ("experimentalExecuteIncrementally" in graphql) {
    graphqlExperimentalExecuteIncrementally = graphql.experimentalExecuteIncrementally;
  } else {
    graphqlExperimentalExecuteIncrementally = null;
  }
}
__name(tryToLoadGraphQL17, "tryToLoadGraphQL17");
async function executeIncrementally(args) {
  await tryToLoadGraphQL17();
  if (graphqlExperimentalExecuteIncrementally) {
    return graphqlExperimentalExecuteIncrementally(args);
  }
  return (0, import_graphql33.execute)(args);
}
__name(executeIncrementally, "executeIncrementally");

// ../node_modules/@apollo/server/dist/esm/requestPipeline.js
var APQ_CACHE_PREFIX = "apq:";
function computeQueryHash(query) {
  return (0, import_utils22.createHash)("sha256").update(query).digest("hex");
}
__name(computeQueryHash, "computeQueryHash");
function isBadUserInputGraphQLError(error3) {
  return error3.nodes?.length === 1 && error3.nodes[0].kind === import_graphql34.Kind.VARIABLE_DEFINITION && (error3.message.startsWith(`Variable "$${error3.nodes[0].variable.name.value}" got invalid value `) || error3.message.startsWith(`Variable "$${error3.nodes[0].variable.name.value}" of required type `) || error3.message.startsWith(`Variable "$${error3.nodes[0].variable.name.value}" of non-null type `));
}
__name(isBadUserInputGraphQLError, "isBadUserInputGraphQLError");
async function processGraphQLRequest(schemaDerivedData, server, internals, requestContext) {
  const requestListeners = (await Promise.all(internals.plugins.map((p) => p.requestDidStart?.(requestContext)))).filter(isDefined);
  const request = requestContext.request;
  let { query, extensions } = request;
  let queryHash;
  requestContext.metrics.persistedQueryHit = false;
  requestContext.metrics.persistedQueryRegister = false;
  if (extensions?.persistedQuery) {
    if (!internals.persistedQueries) {
      return await sendErrorResponse([new PersistedQueryNotSupportedError()]);
    } else if (extensions.persistedQuery.version !== 1) {
      return await sendErrorResponse([
        new import_graphql34.GraphQLError("Unsupported persisted query version", {
          extensions: { http: newHTTPGraphQLHead(400) }
        })
      ]);
    }
    queryHash = extensions.persistedQuery.sha256Hash;
    if (query === void 0) {
      query = await internals.persistedQueries.cache.get(queryHash);
      if (query) {
        requestContext.metrics.persistedQueryHit = true;
      } else {
        return await sendErrorResponse([new PersistedQueryNotFoundError()]);
      }
    } else {
      const computedQueryHash = computeQueryHash(query);
      if (queryHash !== computedQueryHash) {
        return await sendErrorResponse([
          new import_graphql34.GraphQLError("provided sha does not match query", {
            extensions: { http: newHTTPGraphQLHead(400) }
          })
        ]);
      }
      requestContext.metrics.persistedQueryRegister = true;
    }
  } else if (query) {
    queryHash = computeQueryHash(query);
  } else {
    return await sendErrorResponse([
      new BadRequestError("GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.")
    ]);
  }
  requestContext.queryHash = queryHash;
  requestContext.source = query;
  await Promise.all(requestListeners.map((l) => l.didResolveSource?.(requestContext)));
  if (schemaDerivedData.documentStore) {
    try {
      requestContext.document = await schemaDerivedData.documentStore.get(schemaDerivedData.documentStoreKeyPrefix + queryHash);
    } catch (err) {
      server.logger.warn("An error occurred while attempting to read from the documentStore. " + ensureError(err).message);
    }
  }
  if (!requestContext.document) {
    const parsingDidEnd = await invokeDidStartHook(requestListeners, async (l) => l.parsingDidStart?.(requestContext));
    try {
      requestContext.document = (0, import_graphql34.parse)(query, internals.parseOptions);
    } catch (syntaxMaybeError) {
      const error3 = ensureError(syntaxMaybeError);
      await parsingDidEnd(error3);
      return await sendErrorResponse([
        new SyntaxError(ensureGraphQLError(error3))
      ]);
    }
    await parsingDidEnd();
    if (internals.dangerouslyDisableValidation !== true) {
      const validationDidEnd = await invokeDidStartHook(requestListeners, async (l) => l.validationDidStart?.(requestContext));
      let validationErrors = (0, import_graphql34.validate)(schemaDerivedData.schema, requestContext.document, [...import_graphql34.specifiedRules, ...internals.validationRules]);
      if (validationErrors.length === 0 && internals.laterValidationRules) {
        validationErrors = (0, import_graphql34.validate)(schemaDerivedData.schema, requestContext.document, internals.laterValidationRules);
      }
      if (validationErrors.length === 0) {
        await validationDidEnd();
      } else {
        await validationDidEnd(validationErrors);
        return await sendErrorResponse(validationErrors.map((error3) => new ValidationError(error3)));
      }
    }
    if (schemaDerivedData.documentStore) {
      Promise.resolve(schemaDerivedData.documentStore.set(schemaDerivedData.documentStoreKeyPrefix + queryHash, requestContext.document)).catch((err) => server.logger.warn("Could not store validated document. " + err?.message || err));
    }
  }
  const operation = (0, import_graphql34.getOperationAST)(requestContext.document, request.operationName);
  requestContext.operation = operation || void 0;
  requestContext.operationName = operation?.name?.value || null;
  if (request.http?.method === "GET" && operation?.operation && operation.operation !== "query") {
    return await sendErrorResponse([
      new BadRequestError(`GET requests only support query operations, not ${operation.operation} operations`, {
        extensions: {
          http: { status: 405, headers: new HeaderMap([["allow", "POST"]]) }
        }
      })
    ]);
  }
  try {
    await Promise.all(requestListeners.map((l) => l.didResolveOperation?.(requestContext)));
  } catch (err) {
    return await sendErrorResponse([ensureGraphQLError(err)]);
  }
  if (requestContext.metrics.persistedQueryRegister && internals.persistedQueries) {
    const ttl = internals.persistedQueries?.ttl;
    Promise.resolve(internals.persistedQueries.cache.set(queryHash, query, ttl !== void 0 ? { ttl: internals.persistedQueries?.ttl } : void 0)).catch(server.logger.warn);
  }
  const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(requestListeners, async (l) => await l.responseForOperation?.(requestContext));
  if (responseFromPlugin !== null) {
    requestContext.response.body = responseFromPlugin.body;
    mergeHTTPGraphQLHead(requestContext.response.http, responseFromPlugin.http);
  } else {
    const executionListeners = (await Promise.all(requestListeners.map((l) => l.executionDidStart?.(requestContext)))).filter(isDefined);
    executionListeners.reverse();
    if (executionListeners.some((l) => l.willResolveField)) {
      const invokeWillResolveField = /* @__PURE__ */ __name((...args) => invokeSyncDidStartHook(executionListeners, (l) => l.willResolveField?.(...args)), "invokeWillResolveField");
      Object.defineProperty(requestContext.contextValue, symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
      if (internals.fieldResolver) {
        Object.defineProperty(requestContext.contextValue, symbolUserFieldResolver, {
          value: internals.fieldResolver
        });
      }
      enablePluginsForSchemaResolvers(schemaDerivedData.schema);
    }
    try {
      const fullResult = await execute2(requestContext);
      const result = "singleResult" in fullResult ? fullResult.singleResult : fullResult.initialResult;
      if (!requestContext.operation) {
        if (!result.errors?.length) {
          throw new Error("Unexpected error: Apollo Server did not resolve an operation but execute did not return errors");
        }
        throw new OperationResolutionError(result.errors[0]);
      }
      const resultErrors = result.errors?.map((e) => {
        if (isBadUserInputGraphQLError(e) && e.extensions?.code == null) {
          return new UserInputError(e);
        }
        return e;
      });
      if (resultErrors) {
        await didEncounterErrors(resultErrors);
      }
      const { formattedErrors, httpFromErrors } = resultErrors ? formatErrors(resultErrors) : { formattedErrors: void 0, httpFromErrors: newHTTPGraphQLHead() };
      if (internals.status400ForVariableCoercionErrors && resultErrors?.length && result.data === void 0 && !httpFromErrors.status) {
        httpFromErrors.status = 400;
      }
      mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);
      if ("singleResult" in fullResult) {
        requestContext.response.body = {
          kind: "single",
          singleResult: {
            ...result,
            errors: formattedErrors
          }
        };
      } else {
        requestContext.response.body = {
          kind: "incremental",
          initialResult: {
            ...fullResult.initialResult,
            errors: formattedErrors
          },
          subsequentResults: fullResult.subsequentResults
        };
      }
    } catch (executionMaybeError) {
      const executionError = ensureError(executionMaybeError);
      await Promise.all(executionListeners.map((l) => l.executionDidEnd?.(executionError)));
      return await sendErrorResponse([ensureGraphQLError(executionError)]);
    }
    await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));
  }
  await invokeWillSendResponse();
  if (!requestContext.response.body) {
    throw Error("got to end of processGraphQLRequest without setting body?");
  }
  return requestContext.response;
  async function execute2(requestContext2) {
    const { request: request2, document } = requestContext2;
    if (internals.__testing_incrementalExecutionResults) {
      return internals.__testing_incrementalExecutionResults;
    } else if (internals.gatewayExecutor) {
      const result = await internals.gatewayExecutor(makeGatewayGraphQLRequestContext(requestContext2, server, internals));
      return { singleResult: result };
    } else {
      const resultOrResults = await executeIncrementally({
        schema: schemaDerivedData.schema,
        document,
        rootValue: typeof internals.rootValue === "function" ? internals.rootValue(document) : internals.rootValue,
        contextValue: requestContext2.contextValue,
        variableValues: request2.variables,
        operationName: request2.operationName,
        fieldResolver: internals.fieldResolver
      });
      if ("initialResult" in resultOrResults) {
        return {
          initialResult: resultOrResults.initialResult,
          subsequentResults: formatErrorsInSubsequentResults(resultOrResults.subsequentResults)
        };
      } else {
        return { singleResult: resultOrResults };
      }
    }
  }
  __name(execute2, "execute");
  async function* formatErrorsInSubsequentResults(results) {
    for await (const result of results) {
      const payload = result.incremental ? {
        ...result,
        incremental: await seriesAsyncMap(result.incremental, async (incrementalResult) => {
          const { errors } = incrementalResult;
          if (errors) {
            await Promise.all(requestListeners.map((l) => l.didEncounterSubsequentErrors?.(requestContext, errors)));
            return {
              ...incrementalResult,
              errors: formatErrors(errors).formattedErrors
            };
          }
          return incrementalResult;
        })
      } : result;
      await Promise.all(requestListeners.map((l) => l.willSendSubsequentPayload?.(requestContext, payload)));
      yield payload;
    }
  }
  __name(formatErrorsInSubsequentResults, "formatErrorsInSubsequentResults");
  async function invokeWillSendResponse() {
    await Promise.all(requestListeners.map((l) => l.willSendResponse?.(requestContext)));
  }
  __name(invokeWillSendResponse, "invokeWillSendResponse");
  async function didEncounterErrors(errors) {
    requestContext.errors = errors;
    return await Promise.all(requestListeners.map((l) => l.didEncounterErrors?.(requestContext)));
  }
  __name(didEncounterErrors, "didEncounterErrors");
  async function sendErrorResponse(errors) {
    await didEncounterErrors(errors);
    const { formattedErrors, httpFromErrors } = formatErrors(errors);
    requestContext.response.body = {
      kind: "single",
      singleResult: {
        errors: formattedErrors
      }
    };
    mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);
    if (!requestContext.response.http.status) {
      requestContext.response.http.status = 500;
    }
    await invokeWillSendResponse();
    return requestContext.response;
  }
  __name(sendErrorResponse, "sendErrorResponse");
  function formatErrors(errors) {
    return normalizeAndFormatErrors(errors, {
      formatError: internals.formatError,
      includeStacktraceInErrorResponses: internals.includeStacktraceInErrorResponses
    });
  }
  __name(formatErrors, "formatErrors");
}
__name(processGraphQLRequest, "processGraphQLRequest");
async function seriesAsyncMap(ts, fn) {
  const us = [];
  for (const t of ts) {
    const u = await fn(t);
    us.push(u);
  }
  return us;
}
__name(seriesAsyncMap, "seriesAsyncMap");

// ../node_modules/@apollo/server/dist/esm/ApolloServer.js
init_UnreachableCaseError();
init_computeCoreSchemaHash();

// ../node_modules/@apollo/server/dist/esm/utils/schemaManager.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SchemaManager = class {
  static {
    __name(this, "SchemaManager");
  }
  constructor(options) {
    this.onSchemaLoadOrUpdateListeners = /* @__PURE__ */ new Set();
    this.isStopped = false;
    this.logger = options.logger;
    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
    if ("gateway" in options) {
      this.modeSpecificState = {
        mode: "gateway",
        gateway: options.gateway,
        apolloConfig: options.apolloConfig
      };
    } else {
      this.modeSpecificState = {
        mode: "schema",
        apiSchema: options.apiSchema,
        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema)
      };
    }
  }
  async start() {
    if (this.modeSpecificState.mode === "gateway") {
      const gateway = this.modeSpecificState.gateway;
      if (gateway.onSchemaLoadOrUpdate) {
        this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaLoadOrUpdate((schemaContext) => {
          this.processSchemaLoadOrUpdateEvent(schemaContext);
        });
      } else {
        throw new Error("Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway");
      }
      const config2 = await this.modeSpecificState.gateway.load({
        apollo: this.modeSpecificState.apolloConfig
      });
      return config2.executor;
    } else {
      this.processSchemaLoadOrUpdateEvent({
        apiSchema: this.modeSpecificState.apiSchema
      }, this.modeSpecificState.schemaDerivedData);
      return null;
    }
  }
  onSchemaLoadOrUpdate(callback) {
    if (!this.schemaContext) {
      throw new Error("You must call start() before onSchemaLoadOrUpdate()");
    }
    if (!this.isStopped) {
      try {
        callback(this.schemaContext);
      } catch (e) {
        throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
      }
    }
    this.onSchemaLoadOrUpdateListeners.add(callback);
    return () => {
      this.onSchemaLoadOrUpdateListeners.delete(callback);
    };
  }
  getSchemaDerivedData() {
    if (!this.schemaDerivedData) {
      throw new Error("You must call start() before getSchemaDerivedData()");
    }
    return this.schemaDerivedData;
  }
  async stop() {
    this.isStopped = true;
    if (this.modeSpecificState.mode === "gateway") {
      this.modeSpecificState.unsubscribeFromGateway?.();
      await this.modeSpecificState.gateway.stop?.();
    }
  }
  processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
    if (!this.isStopped) {
      this.schemaDerivedData = schemaDerivedData ?? this.schemaDerivedDataProvider(schemaContext.apiSchema);
      this.schemaContext = schemaContext;
      this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
        try {
          listener(schemaContext);
        } catch (e) {
          this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
          this.logger.error(e);
        }
      });
    }
  }
};

// ../node_modules/@apollo/server/dist/esm/validationRules/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@apollo/server/dist/esm/validationRules/NoIntrospection.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql35 = __toESM(require_graphql2(), 1);
var NoIntrospection = /* @__PURE__ */ __name((context2) => ({
  Field(node) {
    if (node.name.value === "__schema" || node.name.value === "__type") {
      context2.reportError(new import_graphql35.GraphQLError("GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production", {
        nodes: [node],
        extensions: {
          validationErrorCode: ApolloServerValidationErrorCode.INTROSPECTION_DISABLED
        }
      }));
    }
  }
}), "NoIntrospection");

// ../node_modules/@apollo/server/dist/esm/validationRules/RecursiveSelectionsLimit.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql36 = __toESM(require_graphql2(), 1);
var DEFAULT_MAX_RECURSIVE_SELECTIONS = 1e7;
var RecursiveSelectionValidationContext = class {
  static {
    __name(this, "RecursiveSelectionValidationContext");
  }
  constructor(selectionCountLimit, context2) {
    this.selectionCountLimit = selectionCountLimit;
    this.context = context2;
    this.fragmentInfo = /* @__PURE__ */ new Map();
    this.operationInfo = /* @__PURE__ */ new Map();
    this.fragmentRecursiveSelectionCount = /* @__PURE__ */ new Map();
  }
  getExecutionDefinitionInfo() {
    if (this.currentFragment !== void 0) {
      let entry = this.fragmentInfo.get(this.currentFragment);
      if (!entry) {
        entry = {
          selectionCount: 0,
          fragmentSpreads: /* @__PURE__ */ new Map()
        };
        this.fragmentInfo.set(this.currentFragment, entry);
      }
      return entry;
    }
    if (this.currentOperation !== void 0) {
      let entry = this.operationInfo.get(this.currentOperation);
      if (!entry) {
        entry = {
          selectionCount: 0,
          fragmentSpreads: /* @__PURE__ */ new Map()
        };
        this.operationInfo.set(this.currentOperation, entry);
      }
      return entry;
    }
    return void 0;
  }
  processSelection(fragmentSpreadName) {
    const definitionInfo = this.getExecutionDefinitionInfo();
    if (!definitionInfo) {
      return;
    }
    definitionInfo.selectionCount++;
    if (fragmentSpreadName !== void 0) {
      let spreadCount = (definitionInfo.fragmentSpreads.get(fragmentSpreadName) ?? 0) + 1;
      definitionInfo.fragmentSpreads.set(fragmentSpreadName, spreadCount);
    }
  }
  enterFragment(fragment) {
    this.currentFragment = fragment;
  }
  leaveFragment() {
    this.currentFragment = void 0;
  }
  enterOperation(operation) {
    this.currentOperation = operation;
  }
  leaveOperation() {
    this.currentOperation = void 0;
  }
  computeFragmentRecursiveSelectionsCount(fragment) {
    const cachedCount = this.fragmentRecursiveSelectionCount.get(fragment);
    if (cachedCount === null) {
      return 0;
    }
    if (cachedCount !== void 0) {
      return cachedCount;
    }
    this.fragmentRecursiveSelectionCount.set(fragment, null);
    const definitionInfo = this.fragmentInfo.get(fragment);
    let count3 = 0;
    if (definitionInfo) {
      count3 = definitionInfo.selectionCount;
      for (const [fragment2, spreadCount] of definitionInfo.fragmentSpreads) {
        count3 += spreadCount * this.computeFragmentRecursiveSelectionsCount(fragment2);
      }
    }
    this.fragmentRecursiveSelectionCount.set(fragment, count3);
    return count3;
  }
  reportError(operation) {
    const operationName = operation ? `Operation "${operation}"` : "Anonymous operation";
    this.context.reportError(new import_graphql36.GraphQLError(`${operationName} recursively requests too many selections.`, {
      nodes: [],
      extensions: {
        validationErrorCode: ApolloServerValidationErrorCode.MAX_RECURSIVE_SELECTIONS_EXCEEDED
      }
    }));
  }
  checkLimitExceeded() {
    for (const [operation, definitionInfo] of this.operationInfo) {
      let count3 = definitionInfo.selectionCount;
      for (const [fragment, spreadCount] of definitionInfo.fragmentSpreads) {
        count3 += spreadCount * this.computeFragmentRecursiveSelectionsCount(fragment);
      }
      if (count3 > this.selectionCountLimit) {
        this.reportError(operation);
      }
    }
  }
};
function createMaxRecursiveSelectionsRule(limit) {
  return (context2) => {
    const selectionContext = new RecursiveSelectionValidationContext(limit, context2);
    return {
      Field() {
        selectionContext.processSelection();
      },
      InlineFragment() {
        selectionContext.processSelection();
      },
      FragmentSpread(node) {
        selectionContext.processSelection(node.name.value);
      },
      FragmentDefinition: {
        enter(node) {
          selectionContext.enterFragment(node.name.value);
        },
        leave() {
          selectionContext.leaveFragment();
        }
      },
      OperationDefinition: {
        enter(node) {
          selectionContext.enterOperation(node.name?.value ?? null);
        },
        leave() {
          selectionContext.leaveOperation();
        }
      },
      Document: {
        leave() {
          selectionContext.checkLimitExceeded();
        }
      }
    };
  };
}
__name(createMaxRecursiveSelectionsRule, "createMaxRecursiveSelectionsRule");

// ../node_modules/@apollo/server/dist/esm/ApolloServer.js
function defaultLogger() {
  const loglevelLogger = import_loglevel.default.getLogger("apollo-server");
  loglevelLogger.setLevel(import_loglevel.default.levels.INFO);
  return loglevelLogger;
}
__name(defaultLogger, "defaultLogger");
var ApolloServer = class _ApolloServer {
  static {
    __name(this, "ApolloServer");
  }
  constructor(config2) {
    const nodeEnv = config2.nodeEnv ?? "undefined" ?? "";
    this.logger = config2.logger ?? defaultLogger();
    const apolloConfig = determineApolloConfig(config2.apollo, this.logger);
    const isDev = nodeEnv !== "production";
    if (config2.cache && config2.cache !== "bounded" && import_utils28.PrefixingKeyValueCache.prefixesAreUnnecessaryForIsolation(config2.cache)) {
      throw new Error("You cannot pass a cache returned from `PrefixingKeyValueCache.cacheDangerouslyDoesNotNeedPrefixesForIsolation`to `new ApolloServer({ cache })`, because Apollo Server may use it for multiple features whose cache keys must be distinct from each other.");
    }
    const state = config2.gateway ? {
      phase: "initialized",
      schemaManager: new SchemaManager({
        gateway: config2.gateway,
        apolloConfig,
        schemaDerivedDataProvider: /* @__PURE__ */ __name((schema) => _ApolloServer.generateSchemaDerivedData(schema, config2.documentStore), "schemaDerivedDataProvider"),
        logger: this.logger
      })
    } : {
      phase: "initialized",
      schemaManager: new SchemaManager({
        apiSchema: _ApolloServer.constructSchema(config2),
        schemaDerivedDataProvider: /* @__PURE__ */ __name((schema) => _ApolloServer.generateSchemaDerivedData(schema, config2.documentStore), "schemaDerivedDataProvider"),
        logger: this.logger
      })
    };
    const introspectionEnabled = config2.introspection ?? isDev;
    const hideSchemaDetailsFromClientErrors = config2.hideSchemaDetailsFromClientErrors ?? false;
    this.cache = config2.cache === void 0 || config2.cache === "bounded" ? new import_utils28.InMemoryLRUCache() : config2.cache;
    const maxRecursiveSelectionsRule = config2.maxRecursiveSelections === true ? [createMaxRecursiveSelectionsRule(DEFAULT_MAX_RECURSIVE_SELECTIONS)] : typeof config2.maxRecursiveSelections === "number" ? [createMaxRecursiveSelectionsRule(config2.maxRecursiveSelections)] : [];
    const validationRules = [
      ...introspectionEnabled ? [] : [NoIntrospection],
      ...maxRecursiveSelectionsRule
    ];
    let laterValidationRules;
    if (maxRecursiveSelectionsRule.length > 0) {
      laterValidationRules = config2.validationRules;
    } else {
      validationRules.push(...config2.validationRules ?? []);
    }
    this.internals = {
      formatError: config2.formatError,
      rootValue: config2.rootValue,
      validationRules,
      laterValidationRules,
      hideSchemaDetailsFromClientErrors,
      dangerouslyDisableValidation: config2.dangerouslyDisableValidation ?? false,
      fieldResolver: config2.fieldResolver,
      includeStacktraceInErrorResponses: config2.includeStacktraceInErrorResponses ?? (nodeEnv !== "production" && nodeEnv !== "test"),
      persistedQueries: config2.persistedQueries === false ? void 0 : {
        ...config2.persistedQueries,
        cache: new import_utils28.PrefixingKeyValueCache(config2.persistedQueries?.cache ?? this.cache, APQ_CACHE_PREFIX)
      },
      nodeEnv,
      allowBatchedHttpRequests: config2.allowBatchedHttpRequests ?? false,
      apolloConfig,
      plugins: config2.plugins ?? [],
      parseOptions: config2.parseOptions ?? {},
      state,
      stopOnTerminationSignals: config2.stopOnTerminationSignals,
      gatewayExecutor: null,
      csrfPreventionRequestHeaders: config2.csrfPrevention === true || config2.csrfPrevention === void 0 ? recommendedCsrfPreventionRequestHeaders : config2.csrfPrevention === false ? null : config2.csrfPrevention.requestHeaders ?? recommendedCsrfPreventionRequestHeaders,
      status400ForVariableCoercionErrors: config2.status400ForVariableCoercionErrors ?? false,
      __testing_incrementalExecutionResults: config2.__testing_incrementalExecutionResults,
      stringifyResult: config2.stringifyResult ?? prettyJSONStringify
    };
  }
  async start() {
    return await this._start(false);
  }
  startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests() {
    this._start(true).catch((e) => this.logStartupError(e));
  }
  async _start(startedInBackground) {
    if (this.internals.state.phase !== "initialized") {
      throw new Error(`You should only call 'start()' or 'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' once on your ApolloServer.`);
    }
    const schemaManager = this.internals.state.schemaManager;
    const barrier = resolvable_default();
    this.internals.state = {
      phase: "starting",
      barrier,
      schemaManager,
      startedInBackground
    };
    try {
      await this.addDefaultPlugins();
      const toDispose = [];
      const executor = await schemaManager.start();
      if (executor) {
        this.internals.gatewayExecutor = executor;
      }
      toDispose.push(async () => {
        await schemaManager.stop();
      });
      const schemaDerivedData = schemaManager.getSchemaDerivedData();
      const service = {
        logger: this.logger,
        cache: this.cache,
        schema: schemaDerivedData.schema,
        apollo: this.internals.apolloConfig,
        startedInBackground
      };
      const taggedServerListeners = (await Promise.all(this.internals.plugins.map(async (plugin) => ({
        serverListener: plugin.serverWillStart && await plugin.serverWillStart(service),
        installedImplicitly: isImplicitlyInstallablePlugin(plugin) && plugin.__internal_installed_implicitly__
      })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === "object");
      taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } }) => {
        if (schemaDidLoadOrUpdate) {
          schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
        }
      });
      const serverWillStops = taggedServerListeners.map((l) => l.serverListener.serverWillStop).filter(isDefined);
      if (serverWillStops.length) {
        toDispose.push(async () => {
          await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
        });
      }
      const drainServerCallbacks = taggedServerListeners.map((l) => l.serverListener.drainServer).filter(isDefined);
      const drainServers = drainServerCallbacks.length ? async () => {
        await Promise.all(drainServerCallbacks.map((drainServer) => drainServer()));
      } : null;
      let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
      if (taggedServerListenersWithRenderLandingPage.length > 1) {
        taggedServerListenersWithRenderLandingPage = taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicitly);
      }
      let landingPage = null;
      if (taggedServerListenersWithRenderLandingPage.length > 1) {
        throw Error("Only one plugin can implement renderLandingPage.");
      } else if (taggedServerListenersWithRenderLandingPage.length) {
        landingPage = await taggedServerListenersWithRenderLandingPage[0].serverListener.renderLandingPage();
      }
      const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(["SIGINT", "SIGTERM"], startedInBackground);
      this.internals.state = {
        phase: "started",
        schemaManager,
        drainServers,
        landingPage,
        toDispose,
        toDisposeLast
      };
    } catch (maybeError) {
      const error3 = ensureError(maybeError);
      try {
        await Promise.all(this.internals.plugins.map(async (plugin) => plugin.startupDidFail?.({ error: error3 })));
      } catch (pluginError) {
        this.logger.error(`startupDidFail hook threw: ${pluginError}`);
      }
      this.internals.state = {
        phase: "failed to start",
        error: error3
      };
      throw error3;
    } finally {
      barrier.resolve();
    }
  }
  maybeRegisterTerminationSignalHandlers(signals2, startedInBackground) {
    const toDisposeLast = [];
    if (this.internals.stopOnTerminationSignals === false || this.internals.stopOnTerminationSignals === void 0 && !(import_utils27.isNodeLike && this.internals.nodeEnv !== "test" && !startedInBackground)) {
      return toDisposeLast;
    }
    let receivedSignal = false;
    const signalHandler = /* @__PURE__ */ __name(async (signal) => {
      if (receivedSignal) {
        return;
      }
      receivedSignal = true;
      try {
        await this.stop();
      } catch (e) {
        this.logger.error(`stop() threw during ${signal} shutdown`);
        this.logger.error(e);
        process.exit(1);
      }
      process.kill(process.pid, signal);
    }, "signalHandler");
    signals2.forEach((signal) => {
      process.on(signal, signalHandler);
      toDisposeLast.push(async () => {
        process.removeListener(signal, signalHandler);
      });
    });
    return toDisposeLast;
  }
  async _ensureStarted() {
    while (true) {
      switch (this.internals.state.phase) {
        case "initialized":
          throw new Error("You need to call `server.start()` before using your Apollo Server.");
        case "starting":
          await this.internals.state.barrier;
          break;
        case "failed to start":
          this.logStartupError(this.internals.state.error);
          throw new Error("This data graph is missing a valid configuration. More details may be available in the server logs.");
        case "started":
        case "draining":
          return this.internals.state;
        case "stopping":
        case "stopped":
          this.logger.warn("A GraphQL operation was received during server shutdown. The operation will fail. Consider draining the HTTP server on shutdown; see https://go.apollo.dev/s/drain for details.");
          throw new Error(`Cannot execute GraphQL operations ${this.internals.state.phase === "stopping" ? "while the server is stopping" : "after the server has stopped"}.'`);
        default:
          throw new UnreachableCaseError(this.internals.state);
      }
    }
  }
  assertStarted(expressionForError) {
    if (this.internals.state.phase !== "started" && this.internals.state.phase !== "draining" && !(this.internals.state.phase === "starting" && this.internals.state.startedInBackground)) {
      throw new Error("You must `await server.start()` before calling `" + expressionForError + "`");
    }
  }
  logStartupError(err) {
    this.logger.error("An error occurred during Apollo Server startup. All GraphQL requests will now fail. The startup error was: " + (err?.message || err));
  }
  static constructSchema(config2) {
    if (config2.schema) {
      return config2.schema;
    }
    const { typeDefs: typeDefs2, resolvers: resolvers2 } = config2;
    const augmentedTypeDefs = Array.isArray(typeDefs2) ? typeDefs2 : [typeDefs2];
    return makeExecutableSchema({
      typeDefs: augmentedTypeDefs,
      resolvers: resolvers2
    });
  }
  static generateSchemaDerivedData(schema, providedDocumentStore) {
    (0, import_graphql42.assertValidSchema)(schema);
    return {
      schema,
      documentStore: providedDocumentStore === void 0 ? new import_utils28.InMemoryLRUCache() : providedDocumentStore,
      documentStoreKeyPrefix: providedDocumentStore ? `${computeCoreSchemaHash((0, import_graphql42.printSchema)(schema))}:` : ""
    };
  }
  async stop() {
    switch (this.internals.state.phase) {
      case "initialized":
      case "starting":
      case "failed to start":
        throw Error("apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded");
      case "stopped":
        if (this.internals.state.stopError) {
          throw this.internals.state.stopError;
        }
        return;
      case "stopping":
      case "draining": {
        await this.internals.state.barrier;
        const state = this.internals.state;
        if (state.phase !== "stopped") {
          throw Error(`Surprising post-stopping state ${state.phase}`);
        }
        if (state.stopError) {
          throw state.stopError;
        }
        return;
      }
      case "started":
        break;
      default:
        throw new UnreachableCaseError(this.internals.state);
    }
    const barrier = resolvable_default();
    const { schemaManager, drainServers, landingPage, toDispose, toDisposeLast } = this.internals.state;
    this.internals.state = {
      phase: "draining",
      barrier,
      schemaManager,
      landingPage
    };
    try {
      await drainServers?.();
      this.internals.state = { phase: "stopping", barrier };
      await Promise.all([...toDispose].map((dispose) => dispose()));
      await Promise.all([...toDisposeLast].map((dispose) => dispose()));
    } catch (stopError) {
      this.internals.state = {
        phase: "stopped",
        stopError
      };
      barrier.resolve();
      throw stopError;
    }
    this.internals.state = { phase: "stopped", stopError: null };
  }
  async addDefaultPlugins() {
    const { plugins, apolloConfig, nodeEnv, hideSchemaDetailsFromClientErrors } = this.internals;
    const isDev = nodeEnv !== "production";
    const alreadyHavePluginWithInternalId = /* @__PURE__ */ __name((id) => plugins.some((p) => pluginIsInternal(p) && p.__internal_plugin_id__ === id), "alreadyHavePluginWithInternalId");
    const pluginsByInternalID = /* @__PURE__ */ new Map();
    for (const p of plugins) {
      if (pluginIsInternal(p)) {
        const id = p.__internal_plugin_id__;
        if (!pluginsByInternalID.has(id)) {
          pluginsByInternalID.set(id, {
            sawDisabled: false,
            sawNonDisabled: false
          });
        }
        const seen = pluginsByInternalID.get(id);
        if (p.__is_disabled_plugin__) {
          seen.sawDisabled = true;
        } else {
          seen.sawNonDisabled = true;
        }
        if (seen.sawDisabled && seen.sawNonDisabled) {
          throw new Error(`You have tried to install both ApolloServerPlugin${id} and ApolloServerPlugin${id}Disabled in your server. Please choose whether or not you want to disable the feature and install the appropriate plugin for your use case.`);
        }
      }
    }
    {
      if (!alreadyHavePluginWithInternalId("CacheControl")) {
        const { ApolloServerPluginCacheControl: ApolloServerPluginCacheControl2 } = await Promise.resolve().then(() => (init_cacheControl(), cacheControl_exports));
        plugins.push(ApolloServerPluginCacheControl2());
      }
    }
    {
      const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("UsageReporting");
      if (!alreadyHavePlugin2 && apolloConfig.key) {
        if (apolloConfig.graphRef) {
          const { ApolloServerPluginUsageReporting: ApolloServerPluginUsageReporting2 } = await Promise.resolve().then(() => (init_usageReporting(), usageReporting_exports));
          plugins.unshift(ApolloServerPluginUsageReporting2({
            __onlyIfSchemaIsNotSubgraph: true
          }));
        } else {
          this.logger.warn("You have specified an Apollo key but have not specified a graph ref; usage reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` environment variable to `your-graph-id@your-graph-variant`. To disable this warning, install `ApolloServerPluginUsageReportingDisabled`.");
        }
      }
    }
    {
      const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("SchemaReporting");
      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === "true";
      if (!alreadyHavePlugin2 && enabledViaEnvVar) {
        if (apolloConfig.key) {
          const { ApolloServerPluginSchemaReporting: ApolloServerPluginSchemaReporting2 } = await Promise.resolve().then(() => (init_schemaReporting(), schemaReporting_exports));
          plugins.push(ApolloServerPluginSchemaReporting2());
        } else {
          throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING environment variable to true, but you also need to provide your Apollo API key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})");
        }
      }
    }
    {
      const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("InlineTrace");
      if (!alreadyHavePlugin2) {
        const { ApolloServerPluginInlineTrace: ApolloServerPluginInlineTrace2 } = await Promise.resolve().then(() => (init_inlineTrace(), inlineTrace_exports));
        plugins.push(ApolloServerPluginInlineTrace2({ __onlyIfSchemaIsSubgraph: true }));
      }
    }
    const alreadyHavePlugin = alreadyHavePluginWithInternalId("LandingPageDisabled");
    if (!alreadyHavePlugin) {
      const { ApolloServerPluginLandingPageLocalDefault: ApolloServerPluginLandingPageLocalDefault2, ApolloServerPluginLandingPageProductionDefault: ApolloServerPluginLandingPageProductionDefault2 } = await Promise.resolve().then(() => (init_default(), default_exports));
      const plugin = isDev ? ApolloServerPluginLandingPageLocalDefault2() : ApolloServerPluginLandingPageProductionDefault2();
      if (!isImplicitlyInstallablePlugin(plugin)) {
        throw Error("default landing page plugin should be implicitly installable?");
      }
      plugin.__internal_installed_implicitly__ = true;
      plugins.push(plugin);
    }
    {
      const alreadyHavePlugin2 = alreadyHavePluginWithInternalId("DisableSuggestions");
      if (hideSchemaDetailsFromClientErrors && !alreadyHavePlugin2) {
        const { ApolloServerPluginDisableSuggestions: ApolloServerPluginDisableSuggestions2 } = await Promise.resolve().then(() => (init_disableSuggestions(), disableSuggestions_exports));
        plugins.push(ApolloServerPluginDisableSuggestions2());
      }
    }
  }
  addPlugin(plugin) {
    if (this.internals.state.phase !== "initialized") {
      throw new Error("Can't add plugins after the server has started");
    }
    this.internals.plugins.push(plugin);
  }
  async executeHTTPGraphQLRequest({ httpGraphQLRequest, context: context2 }) {
    try {
      let runningServerState;
      try {
        runningServerState = await this._ensureStarted();
      } catch (error3) {
        return await this.errorResponse(error3, httpGraphQLRequest);
      }
      if (runningServerState.landingPage && this.prefersHTML(httpGraphQLRequest)) {
        let renderedHtml;
        if (typeof runningServerState.landingPage.html === "string") {
          renderedHtml = runningServerState.landingPage.html;
        } else {
          try {
            renderedHtml = await runningServerState.landingPage.html();
          } catch (maybeError) {
            const error3 = ensureError(maybeError);
            this.logger.error(`Landing page \`html\` function threw: ${error3}`);
            return await this.errorResponse(error3, httpGraphQLRequest);
          }
        }
        return {
          headers: new HeaderMap([["content-type", "text/html"]]),
          body: {
            kind: "complete",
            string: renderedHtml
          }
        };
      }
      if (this.internals.csrfPreventionRequestHeaders) {
        preventCsrf(httpGraphQLRequest.headers, this.internals.csrfPreventionRequestHeaders);
      }
      let contextValue;
      try {
        contextValue = await context2();
      } catch (maybeError) {
        const error3 = ensureError(maybeError);
        try {
          await Promise.all(this.internals.plugins.map(async (plugin) => plugin.contextCreationDidFail?.({
            error: error3
          })));
        } catch (pluginError) {
          this.logger.error(`contextCreationDidFail hook threw: ${pluginError}`);
        }
        return await this.errorResponse(ensureGraphQLError(error3, "Context creation failed: "), httpGraphQLRequest);
      }
      return await runPotentiallyBatchedHttpQuery(this, httpGraphQLRequest, contextValue, runningServerState.schemaManager.getSchemaDerivedData(), this.internals);
    } catch (maybeError_) {
      const maybeError = maybeError_;
      if (maybeError instanceof import_graphql42.GraphQLError && maybeError.extensions.code === ApolloServerErrorCode.BAD_REQUEST) {
        try {
          await Promise.all(this.internals.plugins.map(async (plugin) => plugin.invalidRequestWasReceived?.({ error: maybeError })));
        } catch (pluginError) {
          this.logger.error(`invalidRequestWasReceived hook threw: ${pluginError}`);
        }
      }
      return await this.errorResponse(maybeError, httpGraphQLRequest);
    }
  }
  async errorResponse(error3, requestHead) {
    const { formattedErrors, httpFromErrors } = normalizeAndFormatErrors([error3], {
      includeStacktraceInErrorResponses: this.internals.includeStacktraceInErrorResponses,
      formatError: this.internals.formatError
    });
    return {
      status: httpFromErrors.status ?? 500,
      headers: new HeaderMap([
        ...httpFromErrors.headers,
        [
          "content-type",
          chooseContentTypeForSingleResultResponse(requestHead) ?? MEDIA_TYPES.APPLICATION_JSON
        ]
      ]),
      body: {
        kind: "complete",
        string: await this.internals.stringifyResult({
          errors: formattedErrors
        })
      }
    };
  }
  prefersHTML(request) {
    const acceptHeader = request.headers.get("accept");
    return request.method === "GET" && !!acceptHeader && new import_negotiator2.default({
      headers: { accept: acceptHeader }
    }).mediaType([
      MEDIA_TYPES.APPLICATION_JSON,
      MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
      MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,
      MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
      MEDIA_TYPES.TEXT_HTML
    ]) === MEDIA_TYPES.TEXT_HTML;
  }
  async executeOperation(request, options = {}) {
    if (this.internals.state.phase === "initialized") {
      await this.start();
    }
    const schemaDerivedData = (await this._ensureStarted()).schemaManager.getSchemaDerivedData();
    const graphQLRequest = {
      ...request,
      query: request.query && typeof request.query !== "string" ? (0, import_graphql42.print)(request.query) : request.query
    };
    const response = await internalExecuteOperation({
      server: this,
      graphQLRequest,
      internals: this.internals,
      schemaDerivedData,
      sharedResponseHTTPGraphQLHead: null
    }, options);
    return response;
  }
};
async function internalExecuteOperation({ server, graphQLRequest, internals, schemaDerivedData, sharedResponseHTTPGraphQLHead }, options) {
  const requestContext = {
    logger: server.logger,
    cache: server.cache,
    schema: schemaDerivedData.schema,
    request: graphQLRequest,
    response: {
      http: sharedResponseHTTPGraphQLHead ?? newHTTPGraphQLHead()
    },
    contextValue: cloneObject(options?.contextValue ?? {}),
    metrics: {},
    overallCachePolicy: newCachePolicy(),
    requestIsBatched: sharedResponseHTTPGraphQLHead !== null
  };
  try {
    return await processGraphQLRequest(schemaDerivedData, server, internals, requestContext);
  } catch (maybeError) {
    const error3 = ensureError(maybeError);
    await Promise.all(internals.plugins.map(async (plugin) => plugin.unexpectedErrorProcessingRequest?.({
      requestContext,
      error: error3
    })));
    server.logger.error(`Unexpected error processing request: ${error3}`);
    throw new Error("Internal server error");
  }
}
__name(internalExecuteOperation, "internalExecuteOperation");
function isImplicitlyInstallablePlugin(p) {
  return "__internal_installed_implicitly__" in p;
}
__name(isImplicitlyInstallablePlugin, "isImplicitlyInstallablePlugin");
var MEDIA_TYPES = {
  APPLICATION_JSON: "application/json; charset=utf-8",
  APPLICATION_JSON_GRAPHQL_CALLBACK: "application/json; callbackSpec=1.0; charset=utf-8",
  APPLICATION_GRAPHQL_RESPONSE_JSON: "application/graphql-response+json; charset=utf-8",
  MULTIPART_MIXED_NO_DEFER_SPEC: "multipart/mixed",
  MULTIPART_MIXED_EXPERIMENTAL: "multipart/mixed; deferSpec=20220824",
  TEXT_HTML: "text/html"
};
function chooseContentTypeForSingleResultResponse(head) {
  const acceptHeader = head.headers.get("accept");
  if (!acceptHeader) {
    return MEDIA_TYPES.APPLICATION_JSON;
  } else {
    const preferred = new import_negotiator2.default({
      headers: { accept: head.headers.get("accept") }
    }).mediaType([
      MEDIA_TYPES.APPLICATION_JSON,
      MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
      MEDIA_TYPES.APPLICATION_JSON_GRAPHQL_CALLBACK
    ]);
    if (preferred) {
      return preferred;
    } else {
      return null;
    }
  }
}
__name(chooseContentTypeForSingleResultResponse, "chooseContentTypeForSingleResultResponse");
function cloneObject(object) {
  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
}
__name(cloneObject, "cloneObject");

// ../node_modules/@apollo/server/dist/esm/externalTypes/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/@as-integrations/cloudflare-workers/dist/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function startServerAndCreateCloudflareWorkersHandler(server, options) {
  server.startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests();
  const defaultContext = /* @__PURE__ */ __name(async () => ({}), "defaultContext");
  const contextFunction = options?.context ?? defaultContext;
  return async (request) => {
    try {
      if (request.method === "OPTIONS") {
        return new Response("", { status: 204 });
      }
      const httpGraphQLRequest = await normalizeIncomingRequest(request);
      const { body, headers, status } = await server.executeHTTPGraphQLRequest({
        httpGraphQLRequest,
        context: /* @__PURE__ */ __name(() => contextFunction({ request }), "context")
      });
      if (body.kind === "chunked") {
        throw Error("Incremental delivery not implemented");
      }
      return new Response(body.string, {
        status: status || 200,
        headers: {
          ...Object.fromEntries(headers),
          "content-length": Buffer.byteLength(body.string).toString()
        }
      });
    } catch (e) {
      return new Response(e.message, { status: 400 });
    }
  };
}
__name(startServerAndCreateCloudflareWorkersHandler, "startServerAndCreateCloudflareWorkersHandler");
async function normalizeIncomingRequest(request) {
  const headers = normalizeHeaders(request.headers);
  const url = new URL(request.url);
  const method = request.method.toUpperCase();
  return {
    method,
    headers,
    body: method === "GET" ? request.body : await request.json(),
    search: url.search ?? ""
  };
}
__name(normalizeIncomingRequest, "normalizeIncomingRequest");
function normalizeHeaders(headers) {
  const headerMap = new HeaderMap();
  headers.forEach((value, key) => {
    headerMap.set(key, Array.isArray(value) ? value.join(", ") : value);
  });
  return headerMap;
}
__name(normalizeHeaders, "normalizeHeaders");

// dist/resolvers/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/resolvers/user.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/services/user.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/nanoid/index.browser.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../node_modules/nanoid/url-alphabet/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../node_modules/nanoid/index.browser.js
var nanoid = /* @__PURE__ */ __name((size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
}, "nanoid");

// dist/services/user.js
var UserService = class {
  static {
    __name(this, "UserService");
  }
  db;
  constructor(db) {
    this.db = db;
  }
  async getUserById(id) {
    const result = await this.db.prepare("SELECT * FROM users WHERE id = ?").bind(id).first();
    if (!result) {
      return null;
    }
    const prefsResult = await this.db.prepare("SELECT preferences FROM user_preferences WHERE user_id = ?").bind(id).first();
    const preferences = prefsResult?.preferences ? JSON.parse(prefsResult.preferences) : this.getDefaultPreferences();
    return this.mapToUser(result, preferences);
  }
  async getUserByEmail(email) {
    const result = await this.db.prepare("SELECT * FROM users WHERE email = ?").bind(email).first();
    if (!result) {
      return null;
    }
    const prefsResult = await this.db.prepare("SELECT preferences FROM user_preferences WHERE user_id = ?").bind(result.id).first();
    const preferences = prefsResult?.preferences ? JSON.parse(prefsResult.preferences) : this.getDefaultPreferences();
    return this.mapToUser(result, preferences);
  }
  async createUser(data) {
    const id = `user_${nanoid()}`;
    const now = (/* @__PURE__ */ new Date()).toISOString();
    await this.db.prepare("INSERT INTO users (id, email, display_name, primary_instrument, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)").bind(id, data.email, data.displayName || null, "PIANO", now, now).run();
    const preferences = this.getDefaultPreferences();
    await this.db.prepare("INSERT INTO user_preferences (user_id, preferences) VALUES (?, ?)").bind(id, JSON.stringify(preferences)).run();
    return {
      id,
      email: data.email,
      displayName: data.displayName,
      primaryInstrument: "PIANO",
      preferences,
      stats: this.getDefaultStats(),
      createdAt: now,
      updatedAt: now
    };
  }
  async updateUser(id, input) {
    const user = await this.getUserById(id);
    if (!user) {
      throw new Error("User not found");
    }
    const updates = [];
    const values = [];
    if (input.displayName !== void 0) {
      updates.push("display_name = ?");
      values.push(input.displayName);
    }
    if (input.primaryInstrument !== void 0) {
      updates.push("primary_instrument = ?");
      values.push(input.primaryInstrument);
    }
    if (updates.length > 0) {
      updates.push("updated_at = ?");
      values.push((/* @__PURE__ */ new Date()).toISOString());
      values.push(id);
      await this.db.prepare(`UPDATE users SET ${updates.join(", ")} WHERE id = ?`).bind(...values).run();
    }
    if (input.preferences) {
      const currentPrefs = user.preferences;
      const newPrefs = { ...currentPrefs, ...input.preferences };
      await this.db.prepare("UPDATE user_preferences SET preferences = ? WHERE user_id = ?").bind(JSON.stringify(newPrefs), id).run();
    }
    return this.getUserById(id);
  }
  async deleteUser(id) {
    await this.db.prepare("DELETE FROM users WHERE id = ?").bind(id).run();
  }
  async getUserStats(userId) {
    const statsResult = await this.db.prepare(`
        SELECT 
          COUNT(*) as total_sessions,
          COALESCE(SUM(CAST(julianday(completed_at) - julianday(started_at) AS REAL) * 86400), 0) as total_time,
          COALESCE(AVG(accuracy_percentage), 0) as avg_accuracy
        FROM practice_sessions
        WHERE user_id = ? AND completed_at IS NOT NULL
      `).bind(userId).first();
    const daysResult = await this.db.prepare(`
        SELECT DISTINCT DATE(started_at) as practice_date
        FROM practice_sessions
        WHERE user_id = ?
        ORDER BY practice_date DESC
      `).bind(userId).all();
    const consecutiveDays = this.calculateConsecutiveDays(daysResult.results.map((r) => r.practice_date));
    return {
      totalPracticeTime: Math.floor(statsResult?.total_time || 0),
      consecutiveDays,
      piecesCompleted: 0,
      // TODO: Implement when we have sheet music completion tracking
      accuracyAverage: Math.round((statsResult?.avg_accuracy || 0) * 100) / 100
    };
  }
  mapToUser(dbRow, preferences) {
    return {
      id: dbRow.id,
      email: dbRow.email,
      displayName: dbRow.display_name,
      primaryInstrument: dbRow.primary_instrument,
      preferences,
      stats: this.getDefaultStats(),
      // Stats are loaded separately
      createdAt: dbRow.created_at,
      updatedAt: dbRow.updated_at
    };
  }
  getDefaultPreferences() {
    return {
      theme: "LIGHT",
      notationSize: "MEDIUM",
      practiceReminders: true,
      dailyGoalMinutes: 30
    };
  }
  getDefaultStats() {
    return {
      totalPracticeTime: 0,
      consecutiveDays: 0,
      piecesCompleted: 0,
      accuracyAverage: 0
    };
  }
  calculateConsecutiveDays(dates) {
    if (dates.length === 0)
      return 0;
    let consecutive = 1;
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    if (dates[0] !== today) {
      const yesterday = /* @__PURE__ */ new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      if (dates[0] !== yesterday.toISOString().split("T")[0]) {
        return 0;
      }
    }
    for (let i = 1; i < dates.length; i++) {
      const current = new Date(dates[i - 1]);
      const previous = new Date(dates[i]);
      const diffDays = Math.floor((current.getTime() - previous.getTime()) / (1e3 * 60 * 60 * 24));
      if (diffDays === 1) {
        consecutive++;
      } else {
        break;
      }
    }
    return consecutive;
  }
};

// dist/resolvers/user.js
var Query = {
  me: /* @__PURE__ */ __name(async (_parent, _args, context2) => {
    if (!context2.user) {
      return null;
    }
    const userService = new UserService(context2.env.DB);
    return userService.getUserById(context2.user.id);
  }, "me"),
  user: /* @__PURE__ */ __name(async (_parent, { id }, context2) => {
    const userService = new UserService(context2.env.DB);
    return userService.getUserById(id);
  }, "user")
};
var Mutation = {
  updateUser: /* @__PURE__ */ __name(async (_parent, { input }, context2) => {
    if (!context2.user) {
      throw new Error("Authentication required");
    }
    const userService = new UserService(context2.env.DB);
    return userService.updateUser(context2.user.id, input);
  }, "updateUser"),
  deleteAccount: /* @__PURE__ */ __name(async (_parent, _args, context2) => {
    if (!context2.user) {
      throw new Error("Authentication required");
    }
    const userService = new UserService(context2.env.DB);
    await userService.deleteUser(context2.user.id);
    return {
      success: true,
      message: "Account deleted successfully"
    };
  }, "deleteAccount")
};
var User = {
  primaryInstrument: /* @__PURE__ */ __name((parent) => {
    return parent.primaryInstrument?.toUpperCase() || "PIANO";
  }, "primaryInstrument"),
  preferences: /* @__PURE__ */ __name(async (parent, _args, _context) => {
    return parent.preferences || {
      theme: "LIGHT",
      notationSize: "MEDIUM",
      practiceReminders: true,
      dailyGoalMinutes: 30
    };
  }, "preferences"),
  stats: /* @__PURE__ */ __name(async (parent, _args, context2) => {
    const userService = new UserService(context2.env.DB);
    return userService.getUserStats(parent.id);
  }, "stats")
};
var userResolvers = {
  Query,
  Mutation,
  User
};

// dist/resolvers/auth.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/services/auth.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/utils/auth.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var jwt = __toESM(require_jsonwebtoken(), 1);
function generateMagicLinkToken() {
  return nanoid(32);
}
__name(generateMagicLinkToken, "generateMagicLinkToken");
async function createJWT(user, secret, expiresIn = "15m") {
  const payload = {
    sub: user.id,
    email: user.email,
    user
  };
  return jwt.sign(payload, secret, {
    expiresIn,
    issuer: "mirubato"
  });
}
__name(createJWT, "createJWT");
async function createRefreshToken(userId, secret) {
  return jwt.sign({
    sub: userId,
    type: "refresh"
  }, secret, {
    expiresIn: "30d",
    issuer: "mirubato"
  });
}
__name(createRefreshToken, "createRefreshToken");
async function verifyJWT(token, secret) {
  try {
    const payload = jwt.verify(token, secret, {
      issuer: "mirubato"
    });
    return payload;
  } catch (error3) {
    throw new Error("Invalid or expired token");
  }
}
__name(verifyJWT, "verifyJWT");
async function verifyRefreshToken(token, secret) {
  try {
    const payload = jwt.verify(token, secret, {
      issuer: "mirubato"
    });
    if (payload.type !== "refresh") {
      throw new Error("Invalid token type");
    }
    return { sub: payload.sub };
  } catch (error3) {
    throw new Error("Invalid or expired refresh token");
  }
}
__name(verifyRefreshToken, "verifyRefreshToken");
function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
__name(isValidEmail, "isValidEmail");

// dist/services/auth.js
var AuthService = class {
  static {
    __name(this, "AuthService");
  }
  magicLinksKV;
  jwtSecret;
  MAGIC_LINK_TTL = 600;
  // 10 minutes
  MAGIC_LINK_PREFIX = "magic_link:";
  constructor(magicLinksKV, jwtSecret) {
    this.magicLinksKV = magicLinksKV;
    this.jwtSecret = jwtSecret;
  }
  async createMagicLink(email) {
    const token = generateMagicLinkToken();
    const key = `${this.MAGIC_LINK_PREFIX}${token}`;
    console.log(`AuthService: Creating magic link for email: ${email}`);
    console.log(`AuthService: Token: ${token}, Key: ${key}`);
    console.log("AuthService: KV namespace exists:", !!this.magicLinksKV);
    await this.magicLinksKV.put(key, email, {
      expirationTtl: this.MAGIC_LINK_TTL
    });
    console.log("AuthService: Magic link stored in KV with TTL:", this.MAGIC_LINK_TTL);
    return token;
  }
  async verifyMagicLink(token) {
    const key = `${this.MAGIC_LINK_PREFIX}${token}`;
    console.log(`AuthService: Verifying magic link with key: ${key}`);
    const email = await this.magicLinksKV.get(key);
    console.log(`AuthService: Retrieved email from KV: ${email ? "found" : "not found"}`);
    if (!email) {
      console.log("AuthService: Magic link not found in KV storage");
      console.log("AuthService: KV namespace exists:", !!this.magicLinksKV);
      return null;
    }
    console.log("AuthService: Deleting used magic link token");
    await this.magicLinksKV.delete(key);
    return email;
  }
  async generateTokens(user) {
    const [accessToken, refreshToken] = await Promise.all([
      createJWT(user, this.jwtSecret),
      createRefreshToken(user.id, this.jwtSecret)
    ]);
    return { accessToken, refreshToken };
  }
  async verifyRefreshToken(token) {
    const payload = await verifyRefreshToken(token, this.jwtSecret);
    return payload.sub;
  }
};

// dist/services/email.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// dist/templates/email/compiled-templates.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MAGIC_LINK_HTML_TEMPLATE = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Login to Mirubato</title>
  <!--[if mso]>
  <noscript>
    <xml>
      <o:OfficeDocumentSettings>
        <o:PixelsPerInch>96</o:PixelsPerInch>
      </o:OfficeDocumentSettings>
    </xml>
  </noscript>
  <![endif]-->
</head>
<body style="margin: 0; padding: 0; background-color: #f4f4f4; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
  <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="100%" style="background-color: #f4f4f4;">
    <tr>
      <td align="center" style="padding: 40px 0;">
        <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="600" style="background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          <!-- Header -->
          <tr>
            <td align="center" style="padding: 40px 20px 20px;">
              <h1 style="margin: 0; color: #333333; font-size: 28px; font-weight: 300; letter-spacing: -0.5px;">mirubato</h1>
              <p style="margin: 10px 0 0; color: #666666; font-size: 14px;">Play with me</p>
            </td>
          </tr>
          
          <!-- Main Content -->
          <tr>
            <td style="padding: 0 40px 30px;">
              <h2 style="margin: 0 0 20px; color: #333333; font-size: 20px; font-weight: 500;">Sign in to your account</h2>
              <p style="margin: 0 0 25px; color: #666666; font-size: 16px; line-height: 1.5;">
                Click the button below to sign in to Mirubato. This magic link will expire in 15 minutes.
              </p>
              
              <!-- CTA Button -->
              <table role="presentation" cellspacing="0" cellpadding="0" border="0" style="margin: 0 auto;">
                <tr>
                  <td style="border-radius: 8px; background-color: #2563eb;">
                    <a href="{{LOGIN_URL}}" target="_blank" style="display: inline-block; padding: 14px 32px; font-size: 16px; font-weight: 500; color: #ffffff; text-decoration: none; border-radius: 8px;">
                      Sign in to Mirubato
                    </a>
                  </td>
                </tr>
              </table>
              
              <!-- Alternative Link -->
              <p style="margin: 25px 0 0; color: #999999; font-size: 14px; line-height: 1.5;">
                Or copy and paste this link into your browser:<br>
                <a href="{{LOGIN_URL}}" style="color: #2563eb; text-decoration: none; word-break: break-all;">{{LOGIN_URL}}</a>
              </p>
            </td>
          </tr>
          
          <!-- Security Notice -->
          <tr>
            <td style="padding: 0 40px 30px;">
              <div style="padding: 16px; background-color: #f9fafb; border-radius: 6px;">
                <p style="margin: 0; color: #666666; font-size: 14px; line-height: 1.5;">
                  <strong>Didn't request this?</strong><br>
                  If you didn't request this login link, you can safely ignore this email. No one can access your account without clicking the link above.
                </p>
              </div>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="padding: 20px 40px 40px; border-top: 1px solid #e5e5e5;">
              <p style="margin: 0; color: #999999; font-size: 13px; text-align: center; line-height: 1.5;">
                Mirubato is an open-source sight-reading practice platform<br>
                for classical guitar and piano.<br>
                <a href="https://mirubato.com" style="color: #2563eb; text-decoration: none;">mirubato.com</a>
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`;
var MAGIC_LINK_TEXT_TEMPLATE = `Welcome to Mirubato!

Sign in to your account by clicking the link below:

{{LOGIN_URL}}

This magic link will expire in 15 minutes.

Didn't request this?
If you didn't request this login link, you can safely ignore this email. No one can access your account without clicking the link above.

---
Mirubato - Open-source sight-reading practice platform
https://mirubato.com`;

// ../shared/config/environment.ts
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// ../config/environments.json
var environments_default = {
  "// Configuration Guide": {
    MYDOMAIN: "Your primary domain (e.g., mirubato.com)",
    MYTEAM: "Your Cloudflare team/account name (e.g., pezware)",
    environments: "Define your different environments with their specific settings"
  },
  "// To customize": "Replace MYDOMAIN and MYTEAM with your values",
  MYDOMAIN: "mirubato.com",
  MYTEAM: "pezware",
  environments: {
    local: {
      name: "Local Development",
      frontend: {
        url: "http://localhost:3000",
        port: 3e3
      },
      backend: {
        url: "http://localhost:8787",
        port: 8787
      },
      database: {
        name: "mirubato-dev",
        binding: "DB"
      },
      kv: {
        magicLinks: {
          binding: "MIRUBATO_MAGIC_LINKS",
          namespace: "local-magic-links"
        }
      },
      environment: "development"
    },
    preview: {
      name: "Preview Deployments",
      frontend: {
        urlPattern: "https://*-mirubato.{MYTEAM}.workers.dev",
        examples: [
          "https://7a80e837-mirubato.pezware.workers.dev",
          "https://feature-branch-mirubato.pezware.workers.dev"
        ]
      },
      backend: {
        urlPattern: "https://*-mirubato-backend.{MYTEAM}.workers.dev",
        examples: [
          "https://1fe7f83d-mirubato-backend.pezware.workers.dev",
          "https://feature-branch-mirubato-backend.pezware.workers.dev"
        ]
      },
      database: {
        name: "mirubato-dev",
        binding: "DB",
        id: "4510137a-7fdf-4fcd-83c9-a1b0adb7fe3e"
      },
      kv: {
        magicLinks: {
          binding: "MIRUBATO_MAGIC_LINKS",
          id: "2632e7dcffe745f1a34ba6a3b029bd4c"
        }
      },
      environment: "development"
    },
    staging: {
      name: "Staging (Workers Direct)",
      frontend: {
        url: "https://mirubato.{MYTEAM}.workers.dev"
      },
      backend: {
        url: "https://mirubato-backend.{MYTEAM}.workers.dev"
      },
      database: {
        name: "mirubato-staging",
        binding: "DB",
        id: "01fd5633-05a7-4297-9d31-ee5a7c4b1221"
      },
      kv: {
        magicLinks: {
          binding: "MIRUBATO_MAGIC_LINKS",
          id: "1389dbc875e8413fb5e01c4f9f95da28"
        }
      },
      environment: "staging"
    },
    production: {
      name: "Production",
      frontend: {
        urls: ["https://{MYDOMAIN}", "https://www.{MYDOMAIN}"]
      },
      backend: {
        url: "https://api.{MYDOMAIN}"
      },
      database: {
        name: "mirubato-prod",
        binding: "DB",
        id: "31ecc854-aecf-4994-8bda-7a9cd3055122"
      },
      kv: {
        magicLinks: {
          binding: "MIRUBATO_MAGIC_LINKS",
          id: "d323a9723d424eed9a8aab2b1b9e15b0"
        }
      },
      environment: "production"
    }
  },
  "// Worker Names": "Cloudflare Worker names for deployments",
  workers: {
    frontend: "mirubato",
    backend: "mirubato-backend"
  },
  "// API Configuration": "API-specific settings",
  api: {
    graphqlPath: "/graphql",
    healthPath: "/health",
    debugPath: "/debug/cors"
  },
  "// Email Configuration": "Email service settings",
  email: {
    from: {
      name: "Mirubato",
      email: "noreply@{MYDOMAIN}"
    },
    resendApiKeyBinding: "RESEND_API_KEY"
  },
  "// Security": "Security-related settings",
  security: {
    jwtSecretBinding: "JWT_SECRET",
    jwtExpiresIn: "30d",
    magicLinkExpiresIn: "1h",
    rateLimiterBinding: "RATE_LIMITER"
  }
};

// ../shared/config/environment.ts
function replacePlaceholders(value, replacements) {
  if (typeof value === "string") {
    return value.replace(
      /{([^}]+)}/g,
      (match, key) => replacements[key] || match
    );
  }
  if (Array.isArray(value)) {
    return value.map((item) => replacePlaceholders(item, replacements));
  }
  if (typeof value === "object" && value !== null) {
    const result = {};
    for (const key in value) {
      result[key] = replacePlaceholders(value[key], replacements);
    }
    return result;
  }
  return value;
}
__name(replacePlaceholders, "replacePlaceholders");
function detectEnvironment() {
  if (typeof process !== "undefined" && process.env) {
    const env2 = process.env.ENVIRONMENT || "undefined";
    if (env2 === "production") return "production";
    if (env2 === "staging") return "staging";
    if (env2 === "development") return "local";
  }
  if (typeof window !== "undefined" && window.location) {
    const hostname2 = window.location.hostname;
    if (hostname2 === "localhost" || hostname2 === "127.0.0.1") {
      return "local";
    }
    const domain2 = environments_default.MYDOMAIN;
    if (hostname2 === domain2 || hostname2 === `www.${domain2}`) {
      return "production";
    }
    if (hostname2.endsWith(".workers.dev")) {
      const team = environments_default.MYTEAM;
      if (hostname2 === `mirubato.${team}.workers.dev` || hostname2 === `mirubato-backend.${team}.workers.dev`) {
        return "staging";
      }
      if (hostname2.includes("-mirubato")) {
        return "preview";
      }
    }
  }
  return "local";
}
__name(detectEnvironment, "detectEnvironment");
function getConfig(environmentName) {
  const env2 = environmentName || detectEnvironment();
  const environmentConfig = environments_default.environments[env2];
  if (!environmentConfig) {
    throw new Error(`Unknown environment: ${env2}`);
  }
  const replacements = {
    MYDOMAIN: environments_default.MYDOMAIN,
    MYTEAM: environments_default.MYTEAM
  };
  const processedEnvConfig = replacePlaceholders(
    environmentConfig,
    replacements
  );
  const processedWorkers = replacePlaceholders(
    environments_default.workers,
    replacements
  );
  const processedEmail = replacePlaceholders(
    environments_default.email,
    replacements
  );
  return {
    domain: environments_default.MYDOMAIN,
    team: environments_default.MYTEAM,
    currentEnvironment: processedEnvConfig,
    workers: processedWorkers,
    api: environments_default.api,
    email: processedEmail,
    security: environments_default.security
  };
}
__name(getConfig, "getConfig");
function getCorsOrigins(config2) {
  const cfg = config2 || getConfig();
  const origins = [];
  const frontend = cfg.currentEnvironment.frontend;
  if (frontend.url) {
    origins.push(frontend.url);
  }
  if (frontend.urls) {
    origins.push(...frontend.urls);
  }
  if (frontend.urlPattern) {
    const patterns = [
      frontend.urlPattern,
      // Also allow the backend preview URLs for GraphQL playground
      cfg.currentEnvironment.backend.urlPattern
    ].filter(Boolean);
    origins.push(...patterns);
  }
  if (cfg.currentEnvironment.environment === "development") {
    origins.push(
      "http://localhost:3000",
      "http://localhost:5173",
      "http://127.0.0.1:3000",
      "http://127.0.0.1:5173"
    );
  }
  return origins;
}
__name(getCorsOrigins, "getCorsOrigins");
function isOriginAllowed(origin, config2) {
  const cfg = config2 || getConfig();
  const allowedOrigins = getCorsOrigins(cfg);
  if (allowedOrigins.includes(origin)) {
    return true;
  }
  for (const pattern of allowedOrigins) {
    if (pattern.includes("*")) {
      const regex = new RegExp(
        "^" + pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*") + "$"
      );
      if (regex.test(origin)) {
        return true;
      }
    }
  }
  return false;
}
__name(isOriginAllowed, "isOriginAllowed");

// dist/services/email.js
var EmailService = class {
  static {
    __name(this, "EmailService");
  }
  env;
  constructor(env2) {
    this.env = env2;
  }
  async sendMagicLinkEmail(email, token) {
    const loginUrl = this.getLoginUrl(token);
    if (this.env.ENVIRONMENT === "development") {
      console.log(`Magic link for ${email}: ${loginUrl}`);
      return;
    }
    if (this.env.RESEND_API_KEY) {
      await this.sendViaResend(email, loginUrl);
    } else {
      console.warn("No email service configured. Magic link:", loginUrl);
    }
  }
  async sendViaResend(email, loginUrl) {
    const envKey = this.env.ENVIRONMENT === "production" ? "production" : "local";
    const config2 = getConfig(envKey);
    const html = this.getHtmlContent(loginUrl);
    const text = this.getTextContent(loginUrl);
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.env.RESEND_API_KEY}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        from: `${config2.email.from.name} <${config2.email.from.email}>`,
        to: email,
        subject: "Your Mirubato sign-in link",
        html,
        text
      })
    });
    if (!response.ok) {
      const error3 = await response.text();
      throw new Error(`Failed to send email: ${error3}`);
    }
  }
  getLoginUrl(token) {
    const envKey = this.env.ENVIRONMENT === "production" ? "production" : "local";
    console.log(`EmailService: Environment=${this.env.ENVIRONMENT}, using config=${envKey}`);
    const config2 = getConfig(envKey);
    const env2 = config2.currentEnvironment;
    const baseUrl = env2.frontend.url || env2.frontend.urls?.[0] || "http://localhost:3000";
    console.log(`EmailService: Generated base URL=${baseUrl}`);
    const fullUrl = `${baseUrl}/auth/verify?token=${token}`;
    console.log(`EmailService: Full magic link URL=${fullUrl}`);
    return fullUrl;
  }
  getHtmlContent(loginUrl) {
    return MAGIC_LINK_HTML_TEMPLATE.replace(/{{LOGIN_URL}}/g, loginUrl);
  }
  getTextContent(loginUrl) {
    return MAGIC_LINK_TEXT_TEMPLATE.replace(/{{LOGIN_URL}}/g, loginUrl);
  }
};

// dist/resolvers/auth.js
var authResolvers = {
  Mutation: {
    requestMagicLink: /* @__PURE__ */ __name(async (_, { email }, context2) => {
      console.log("requestMagicLink called with:", email);
      if (!isValidEmail(email)) {
        throw new Error("Invalid email address");
      }
      try {
        console.log("Context env:", {
          hasMagicLinksKV: !!context2.env.MIRUBATO_MAGIC_LINKS,
          hasJwtSecret: !!context2.env.JWT_SECRET,
          environment: context2.env.ENVIRONMENT,
          hasResendApiKey: !!context2.env.RESEND_API_KEY
        });
        const authService = new AuthService(context2.env.MIRUBATO_MAGIC_LINKS, context2.env.JWT_SECRET);
        const emailService = new EmailService(context2.env);
        const magicLink = await authService.createMagicLink(email);
        console.log("Magic link created:", magicLink);
        await emailService.sendMagicLinkEmail(email, magicLink);
        return {
          success: true,
          message: "Magic link sent to your email"
        };
      } catch (error3) {
        console.error("requestMagicLink error:", error3);
        throw error3;
      }
    }, "requestMagicLink"),
    verifyMagicLink: /* @__PURE__ */ __name(async (_, { token }, context2) => {
      console.log("verifyMagicLink called with token:", token?.slice(0, 8) + "...");
      try {
        const authService = new AuthService(context2.env.MIRUBATO_MAGIC_LINKS, context2.env.JWT_SECRET);
        const userService = new UserService(context2.env.DB);
        console.log("Verifying magic link token...");
        const email = await authService.verifyMagicLink(token);
        console.log("Magic link verification result:", email ? "success" : "failed");
        if (!email) {
          throw new Error("Invalid or expired magic link");
        }
        console.log("Getting or creating user for email:", email);
        let user = await userService.getUserByEmail(email);
        if (!user) {
          console.log("Creating new user");
          user = await userService.createUser({ email });
        } else {
          console.log("Found existing user:", user.id);
        }
        console.log("Generating tokens for user:", user.id);
        const { accessToken, refreshToken } = await authService.generateTokens(user);
        console.log("verifyMagicLink completed successfully");
        return {
          accessToken,
          refreshToken,
          expiresIn: 900,
          // 15 minutes
          user
        };
      } catch (error3) {
        console.error("verifyMagicLink error:", error3);
        throw error3;
      }
    }, "verifyMagicLink"),
    refreshToken: /* @__PURE__ */ __name(async (_, { refreshToken }, context2) => {
      const authService = new AuthService(context2.env.MIRUBATO_MAGIC_LINKS, context2.env.JWT_SECRET);
      const userService = new UserService(context2.env.DB);
      const userId = await authService.verifyRefreshToken(refreshToken);
      const user = await userService.getUserById(userId);
      if (!user) {
        throw new Error("User not found");
      }
      const tokens = await authService.generateTokens(user);
      return {
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        expiresIn: 900,
        user
      };
    }, "refreshToken"),
    logout: /* @__PURE__ */ __name(async (_parent, _args, _context) => {
      return {
        success: true,
        message: "Logged out successfully"
      };
    }, "logout")
  }
};

// dist/resolvers/sheetMusic.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var sheetMusicResolvers = {
  Query: {
    sheetMusic: /* @__PURE__ */ __name(async (_parent, { id: _id }, _context) => {
      return null;
    }, "sheetMusic"),
    listSheetMusic: /* @__PURE__ */ __name(async (_parent, { filter: _filter, offset: _offset = 0, limit: _limit = 20 }, _context) => {
      return {
        edges: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          startCursor: null,
          endCursor: null
        },
        totalCount: 0
      };
    }, "listSheetMusic"),
    randomSheetMusic: /* @__PURE__ */ __name(async (_parent, { instrument: _instrument, difficulty: _difficulty, maxDuration: _maxDuration }, _context) => {
      return null;
    }, "randomSheetMusic")
  },
  SheetMusic: {
    // Field resolvers if needed
  }
};

// dist/resolvers/practice.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var practiceResolvers = {
  Query: {
    practiceSession: /* @__PURE__ */ __name(async (_parent, { id: _id }, _context) => {
      return null;
    }, "practiceSession"),
    myPracticeSessions: /* @__PURE__ */ __name(async (_parent, { instrument: _instrument, offset: _offset = 0, limit: _limit = 20 }, _context) => {
      return {
        edges: [],
        pageInfo: {
          hasNextPage: false,
          hasPreviousPage: false,
          startCursor: null,
          endCursor: null
        },
        totalCount: 0
      };
    }, "myPracticeSessions")
  },
  Mutation: {
    startPracticeSession: /* @__PURE__ */ __name(async (_parent, { input: _input }, _context) => {
      throw new Error("Not implemented");
    }, "startPracticeSession"),
    pausePracticeSession: /* @__PURE__ */ __name(async (_parent, { sessionId: _sessionId }, _context) => {
      throw new Error("Not implemented");
    }, "pausePracticeSession"),
    resumePracticeSession: /* @__PURE__ */ __name(async (_parent, { sessionId: _sessionId }, _context) => {
      throw new Error("Not implemented");
    }, "resumePracticeSession"),
    completePracticeSession: /* @__PURE__ */ __name(async (_parent, { input: _input }, _context) => {
      throw new Error("Not implemented");
    }, "completePracticeSession"),
    createPracticeLog: /* @__PURE__ */ __name(async (_parent, { input: _input }, _context) => {
      throw new Error("Not implemented");
    }, "createPracticeLog")
  },
  PracticeSession: {
    user: /* @__PURE__ */ __name(async (_parent, _args, _context) => {
      return null;
    }, "user"),
    sheetMusic: /* @__PURE__ */ __name(async (_parent, _args, _context) => {
      return null;
    }, "sheetMusic"),
    logs: /* @__PURE__ */ __name(async (_parent, _args, _context) => {
      return [];
    }, "logs")
  }
};

// dist/resolvers/scalars.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_graphql43 = __toESM(require_graphql2(), 1);
var scalarResolvers = {
  DateTime: new import_graphql43.GraphQLScalarType({
    name: "DateTime",
    description: "DateTime custom scalar type",
    serialize(value) {
      if (value instanceof Date) {
        return value.toISOString();
      }
      return value;
    },
    parseValue(value) {
      return new Date(value);
    },
    parseLiteral(ast) {
      if (ast.kind === import_graphql43.Kind.STRING) {
        return new Date(ast.value);
      }
      return null;
    }
  }),
  JSON: new import_graphql43.GraphQLScalarType({
    name: "JSON",
    description: "JSON custom scalar type",
    serialize(value) {
      return value;
    },
    parseValue(value) {
      return value;
    },
    parseLiteral(ast) {
      switch (ast.kind) {
        case import_graphql43.Kind.STRING:
          return JSON.parse(ast.value);
        case import_graphql43.Kind.OBJECT:
          return parseObject(ast);
        default:
          return null;
      }
    }
  })
};
function parseObject(ast) {
  const value = /* @__PURE__ */ Object.create(null);
  ast.fields.forEach((field) => {
    value[field.name.value] = parseValue(field.value);
  });
  return value;
}
__name(parseObject, "parseObject");
function parseValue(ast) {
  switch (ast.kind) {
    case import_graphql43.Kind.STRING:
    case import_graphql43.Kind.BOOLEAN:
      return ast.value;
    case import_graphql43.Kind.INT:
    case import_graphql43.Kind.FLOAT:
      return parseFloat(ast.value);
    case import_graphql43.Kind.OBJECT:
      return parseObject(ast);
    case import_graphql43.Kind.LIST:
      return ast.values.map(parseValue);
    default:
      return null;
  }
}
__name(parseValue, "parseValue");

// dist/resolvers/index.js
var resolvers = {
  ...scalarResolvers,
  Query: {
    ...userResolvers.Query,
    ...sheetMusicResolvers.Query,
    ...practiceResolvers.Query
  },
  Mutation: {
    ...authResolvers.Mutation,
    ...userResolvers.Mutation,
    ...practiceResolvers.Mutation
  },
  User: userResolvers.User,
  SheetMusic: sheetMusicResolvers.SheetMusic,
  PracticeSession: practiceResolvers.PracticeSession
};

// dist/utils/rateLimiter.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function createRateLimiter(_namespace, _identifier) {
  return {
    async checkLimit() {
      return true;
    }
  };
}
__name(createRateLimiter, "createRateLimiter");

// dist/schema/index.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var typeDefs = `
scalar DateTime
scalar JSON

# Core Types
type User {
  id: ID!
  email: String!
  displayName: String
  primaryInstrument: Instrument!
  preferences: UserPreferences!
  stats: UserStats!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserPreferences {
  theme: Theme!
  notationSize: NotationSize!
  practiceReminders: Boolean!
  dailyGoalMinutes: Int!
  customSettings: JSON
}

type UserStats {
  totalPracticeTime: Int!
  consecutiveDays: Int!
  piecesCompleted: Int!
  accuracyAverage: Float!
}

type SheetMusic {
  id: ID!
  title: String!
  composer: String!
  opus: String
  movement: String
  instrument: Instrument!
  difficulty: Difficulty!
  difficultyLevel: Int!
  gradeLevel: String
  durationSeconds: Int!
  timeSignature: String!
  keySignature: String!
  tempoMarking: String
  suggestedTempo: Int!
  stylePeriod: StylePeriod!
  tags: [String!]!
  measures: [Measure!]!
  metadata: SheetMusicMetadata
  thumbnail: String
}

type SheetMusicMetadata {
  source: String
  license: String
  arrangedBy: String
  year: Int
}

type Measure {
  number: Int!
  notes: [Note!]!
  timeSignature: String
  keySignature: String
  clef: String
  tempo: Tempo
}

type Note {
  keys: [String!]!
  duration: String!
  time: Float!
}

type Tempo {
  bpm: Int!
  marking: String
  originalMarking: String
  practiceTempos: PracticeTempos
}

type PracticeTempos {
  slow: Int!
  medium: Int!
  target: Int!
  performance: Int!
}

type PracticeSession {
  id: ID!
  user: User!
  instrument: Instrument!
  sheetMusic: SheetMusic
  sessionType: SessionType!
  startedAt: DateTime!
  completedAt: DateTime
  pausedDuration: Int!
  accuracy: Float
  notesAttempted: Int!
  notesCorrect: Int!
  logs: [PracticeLog!]!
}

type PracticeLog {
  id: ID!
  session: PracticeSession!
  activityType: ActivityType!
  durationSeconds: Int!
  tempoPracticed: Int
  targetTempo: Int
  focusAreas: [String!]!
  selfRating: Int
  notes: String
  createdAt: DateTime!
}

type AuthPayload {
  success: Boolean!
  message: String!
}

type TokenPayload {
  accessToken: String!
  refreshToken: String!
  expiresIn: Int!
  user: User!
}

# Enums
enum Instrument {
  PIANO
  GUITAR
}

enum Difficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum Theme {
  LIGHT
  DARK
  AUTO
}

enum NotationSize {
  SMALL
  MEDIUM
  LARGE
}

enum StylePeriod {
  BAROQUE
  CLASSICAL
  ROMANTIC
  MODERN
  CONTEMPORARY
}

enum SessionType {
  FREE_PRACTICE
  GUIDED_PRACTICE
  ASSESSMENT
}

enum ActivityType {
  SIGHT_READING
  SCALES
  REPERTOIRE
  ETUDES
  TECHNIQUE
  OTHER
}

# Input Types
input UserPreferencesInput {
  theme: Theme
  notationSize: NotationSize
  practiceReminders: Boolean
  dailyGoalMinutes: Int
  customSettings: JSON
}

input UpdateUserInput {
  displayName: String
  primaryInstrument: Instrument
  preferences: UserPreferencesInput
}

input SheetMusicFilterInput {
  instrument: Instrument
  difficulty: Difficulty
  minDifficultyLevel: Int
  maxDifficultyLevel: Int
  stylePeriod: StylePeriod
  maxDuration: Int
  tags: [String!]
  search: String
}

input StartPracticeSessionInput {
  sessionType: SessionType!
  instrument: Instrument!
  sheetMusicId: ID
}

input CompletePracticeSessionInput {
  sessionId: ID!
  accuracy: Float
  notesAttempted: Int
  notesCorrect: Int
}

input CreatePracticeLogInput {
  sessionId: ID!
  activityType: ActivityType!
  durationSeconds: Int!
  tempoPracticed: Int
  targetTempo: Int
  focusAreas: [String!]
  selfRating: Int
  notes: String
}

# Queries
type Query {
  # User queries
  me: User
  user(id: ID!): User

  # Sheet music queries
  sheetMusic(id: ID!): SheetMusic
  listSheetMusic(
    filter: SheetMusicFilterInput
    offset: Int
    limit: Int
  ): SheetMusicConnection!
  randomSheetMusic(
    instrument: Instrument!
    difficulty: Difficulty
    maxDuration: Int
  ): SheetMusic

  # Practice session queries
  practiceSession(id: ID!): PracticeSession
  myPracticeSessions(
    instrument: Instrument
    offset: Int
    limit: Int
  ): PracticeSessionConnection!
}

# Mutations
type Mutation {
  # Authentication mutations
  requestMagicLink(email: String!): AuthPayload!
  verifyMagicLink(token: String!): TokenPayload!
  refreshToken(refreshToken: String!): TokenPayload!
  logout: AuthPayload!

  # User mutations
  updateUser(input: UpdateUserInput!): User!
  deleteAccount: AuthPayload!

  # Practice session mutations
  startPracticeSession(input: StartPracticeSessionInput!): PracticeSession!
  pausePracticeSession(sessionId: ID!): PracticeSession!
  resumePracticeSession(sessionId: ID!): PracticeSession!
  completePracticeSession(input: CompletePracticeSessionInput!): PracticeSession!
  
  # Practice log mutations
  createPracticeLog(input: CreatePracticeLogInput!): PracticeLog!
}

# Connection types for pagination
type SheetMusicConnection {
  edges: [SheetMusicEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SheetMusicEdge {
  node: SheetMusic!
  cursor: String!
}

type PracticeSessionConnection {
  edges: [PracticeSessionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PracticeSessionEdge {
  node: PracticeSession!
  cursor: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
`;

// dist/middleware/logging.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function logRequest(request) {
  console.log("=== Incoming Request ===");
  console.log("URL:", request.url);
  console.log("Method:", request.method);
  console.log("Headers:", Object.fromEntries(request.headers.entries()));
  if (request.method === "POST" && request.headers.get("content-type")?.includes("application/json")) {
    try {
      const clonedRequest = request.clone();
      const body = await clonedRequest.text();
      console.log("Body:", body);
      try {
        const parsed = JSON.parse(body);
        console.log("Parsed GraphQL:", {
          query: parsed.query,
          variables: parsed.variables,
          operationName: parsed.operationName
        });
      } catch (e) {
        console.log("Body is not valid JSON");
      }
    } catch (e) {
      console.log("Could not read body:", e);
    }
  }
  console.log("======================");
}
__name(logRequest, "logRequest");

// dist/config/cors.js
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getCorsConfig(environment) {
  const envKey = environment === "production" ? "production" : environment === "development" ? "local" : void 0;
  const config2 = getConfig(envKey);
  const origins = getCorsOrigins(config2);
  const domains = origins.filter((origin) => !origin.includes("*"));
  const patterns = origins.filter((origin) => origin.includes("*"));
  if (!patterns.includes("https://*.workers.dev")) {
    patterns.push("https://*.workers.dev");
  }
  if (!patterns.includes("https://*.pages.dev")) {
    patterns.push("https://*.pages.dev");
  }
  return {
    production: {
      domains: domains.filter((d) => d.startsWith("https://")),
      patterns
    },
    development: {
      origins: domains.filter((d) => d.startsWith("http://localhost") || d.startsWith("http://127.0.0.1"))
    }
  };
}
__name(getCorsConfig, "getCorsConfig");
var corsConfig = getCorsConfig();
function isOriginAllowed2(origin, environment) {
  const envKey = environment === "production" ? "production" : "local";
  const config2 = getConfig(envKey);
  return isOriginAllowed(origin, config2);
}
__name(isOriginAllowed2, "isOriginAllowed");

// dist/index.js
function getCorsHeaders(request, env2) {
  const origin = request.headers.get("Origin") || "";
  const corsHeaders = {
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    "Access-Control-Max-Age": "86400"
  };
  const environment = env2.ENVIRONMENT || "production";
  const isAllowed = isOriginAllowed2(origin, environment);
  console.log(`CORS check: origin="${origin}", env="${environment}" (raw: ${env2.ENVIRONMENT}), allowed=${isAllowed}`);
  if (isAllowed) {
    corsHeaders["Access-Control-Allow-Origin"] = origin;
  } else if (origin) {
    console.log(`CORS rejected: origin "${origin}" not in allowed list`);
  }
  return corsHeaders;
}
__name(getCorsHeaders, "getCorsHeaders");
function addCorsHeaders(response, request, env2) {
  const newResponse = new Response(response.body, response);
  const corsHeaders = getCorsHeaders(request, env2);
  if (corsHeaders) {
    Object.entries(corsHeaders).forEach(([key, value]) => {
      newResponse.headers.set(key, value);
    });
  }
  return newResponse;
}
__name(addCorsHeaders, "addCorsHeaders");
var dist_default = {
  async fetch(request, env2) {
    const url = new URL(request.url);
    if (request.method === "OPTIONS") {
      return new Response(null, {
        status: 204,
        headers: getCorsHeaders(request, env2)
      });
    }
    if (url.pathname === "/health" || url.pathname === "/test") {
      return addCorsHeaders(new Response(JSON.stringify({
        message: "Backend is working!",
        env: env2.ENVIRONMENT,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }), {
        headers: {
          "Content-Type": "application/json"
        }
      }), request, env2);
    }
    if (url.pathname === "/debug/cors") {
      const origin = request.headers.get("Origin") || "no-origin";
      const environment = env2.ENVIRONMENT || "production";
      const isAllowed = isOriginAllowed2(origin, environment);
      const corsConfig2 = getCorsConfig(environment);
      return addCorsHeaders(new Response(JSON.stringify({
        origin,
        environment,
        envRaw: env2.ENVIRONMENT,
        isAllowed,
        corsConfig: {
          production: corsConfig2.production.domains,
          patterns: corsConfig2.production.patterns,
          development: corsConfig2.development.origins
        },
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }), {
        headers: { "Content-Type": "application/json" }
      }), request, env2);
    }
    if (url.pathname === "/graphql") {
      if (env2.ENVIRONMENT === "development") {
        await logRequest(request);
      }
      try {
        const server = new ApolloServer({
          typeDefs,
          resolvers,
          introspection: true
          // Enable in development
        });
        const handleGraphQL = startServerAndCreateCloudflareWorkersHandler(server, {
          context: /* @__PURE__ */ __name(async ({ request: request2 }) => {
            console.log("Creating GraphQL context");
            const requestId = nanoid();
            const ip = request2.headers.get("CF-Connecting-IP") || void 0;
            if (env2.RATE_LIMITER) {
              const rateLimiter = createRateLimiter(env2.RATE_LIMITER, ip);
              const allowed = await rateLimiter.checkLimit();
              if (!allowed) {
                throw new Error("Rate limit exceeded");
              }
            }
            let user;
            const authorization = request2.headers.get("Authorization");
            if (authorization?.startsWith("Bearer ")) {
              const token = authorization.slice(7);
              try {
                const payload = await verifyJWT(token, env2.JWT_SECRET);
                user = payload.user;
              } catch (error3) {
              }
            }
            return {
              env: env2,
              user,
              requestId,
              ip
            };
          }, "context")
        });
        const response = await handleGraphQL(request);
        console.log("GraphQL response status:", response.status);
        if (env2.ENVIRONMENT === "development" && response.status >= 400) {
          const clonedResponse = response.clone();
          const responseBody = await clonedResponse.text();
          console.log("GraphQL error response:", responseBody);
        }
        return addCorsHeaders(response, request, env2);
      } catch (error3) {
        console.error("GraphQL handler error:", error3);
        return addCorsHeaders(new Response(JSON.stringify({
          error: "Internal server error",
          message: error3 instanceof Error ? error3.message : "Unknown error",
          stack: env2.ENVIRONMENT === "development" && error3 instanceof Error ? error3.stack : void 0
        }), {
          status: 500,
          headers: { "Content-Type": "application/json" }
        }), request, env2);
      }
    }
    if (url.pathname === "/health" || url.pathname === "/livez") {
      const response = new Response(JSON.stringify({
        status: "ok",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        version: env2.CF_VERSION_METADATA?.id || "unknown",
        environment: env2.ENVIRONMENT || "unknown"
      }), {
        headers: {
          "Content-Type": "application/json",
          "X-Version": env2.CF_VERSION_METADATA?.id || "unknown",
          "X-Environment": env2.ENVIRONMENT || "unknown"
        }
      });
      return addCorsHeaders(response, request, env2);
    }
    return addCorsHeaders(new Response("Not Found", { status: 404 }), request, env2);
  }
};

// ../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// ../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } catch (e) {
    const error3 = reduceError(e);
    return Response.json(error3, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-kaawHL/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = dist_default;

// ../node_modules/wrangler/templates/middleware/common.ts
init_strip_cf_connecting_ip_header();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env2, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env2, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env2, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env2, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-kaawHL/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env2, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env2, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env2, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type2, init) {
        if (type2 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env2, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env2, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env2, ctx) => {
      this.env = env2;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type2, init) => {
      if (type2 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

negotiator/index.js:
  (*!
   * negotiator
   * Copyright(c) 2012 Federico Romero
   * Copyright(c) 2012-2014 Isaac Z. Schlueter
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=index.js.map
